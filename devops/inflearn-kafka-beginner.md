# 데브원영 아파치 카프카 for beginner

- [인프런 무료 강의](https://www.inflearn.com/course/%EC%95%84%ED%8C%8C%EC%B9%98-%EC%B9%B4%ED%94%84%EC%B9%B4-%EC%9E%85%EB%AC%B8)

## 아파치 카프카 개요

- 카프카는 source / target 시스템 간 결합도를 낮추기 위해 나왔다.
  - source application은 데이터를 카프카에게 보내고 target application은 카프카에서 데이터를 가져오면 된다.
- 카프카에는 각종 데이터를 담는 Topic이 있는데 쉽게 말해 큐라고 보면 된다.
  - Topic에 데이터를 넣는 역할은 producer가 하고, 데이터를 가져오는 역할은 consumer가 담당한다.
- 카프카는 fault tolerant, 즉 고가용성을 제공하고 서버에 장애가 생겨도 데이터를 손실없이 복구할 수 있다.
  - 또 낮은 지연과 높은 처리량을 통해 대용량의 데이터 처리가 가능하다.

## 카프카 토픽

- 카프카는 여러 토픽을 가질 수 있고, 각 토픽에 프로듀서가 데이터를 넣게 되고 컨슈머는 데이터를 가지고 가게 된다.
- 토픽은 이름을 가질 수 있는데 예를 들어 click_log, send_sms 등 무슨 데이터를 담는지 명확하게 명시해야 한다.
- 하나의 토픽은 여러개의 파티션으로 구성되며 첫 번째 파티션 번호는 0번부터 시작된다.
  - 하나의 파티션은 큐처럼 데이터가 파티션 끝에서부터 순서대로 쌓인다.
  - 토픽에 컨슈머가 붙게되면 데이터를 가장 오래된 순서대로 가져가는데, 데이터를 가져가더라도 카프카 내부의 데이터는 삭제되지 않는다.
  - 파티션에 남은 데이터는 새로운 컨슈머가 붙었을 때 다시 0번부터 가져갈 수 있다.
- 파티션이 2개 이상일 경우
  - 기존에 데이터들이 있고 새로운 데이터가 추가될 때 파티션 2개 중 어디로 들어가야 할까?
    - 프로듀서가 데이터를 보낼 때 키를 지정할 수 있는데, 키가 없다면 RR으로 동작하고, 키가 있다면 해쉬값을 구해 특정 파티션에 할당한다.
- 파티션을 늘리는건 조심해야 하는데, 늘리는건 가능하지만 줄이는 건 불가능하기 때문이다.
- 파티션에 데이터는 언제 삭제될까?
  - 옵션에 따라 달라지는데 일정시간 or 일정 데이터 크기만큼 유지하고 삭제할 수 있다.

## 브로커, Replication, ISR(In-Sync-Replication)

- 브로커는 카프카가 설치되어 있는 서버 단위를 말하며, 보통 3개 이상의 브로커로 구성하여 사용하는 것을 권장한다.
- Replication은 파티션의 복제를 뜻한다. 만약 Replication이 1이라면 브로커 1개에 파티션이 1개만 존재하고 Replication이 2라면 브로커 2개에 걸쳐 파티션은 원본 1개, 복제본 1개로 총 2개가 존재한다.
- 브로커 개수에 따라 Replication이 제한되는데 브로커 개수가 3이면 Replication은 4가 될 수 없다는 의미이다.
- 원본 파티션은 leader 파티션이라고 부른다. 나머지 복제본은 follower 파티션이라고 부른다. leader + follower 파티션을 합쳐 ISR이라고 부른다.
- 왜 Replication을 사용할까?
  - 고가용성과 관련있다. 만약 브로커가 3개인 카프카에서 Replication이 1이라 leader 파티션만 있을 때, 이 브로커를 사용할 수 없다면 해당 파티션은 복구할 수 없다.
  - 만약 Replication가 2라면 leader가 죽더라도 follower가 있으므로 파티션 복구가 가능하다.
- learder와 follower 파티션의 차이는 뭘까?
  - 프로듀서가 데이터를 전달할 때 전달받는 주체가 leader 파티션이다.
  - 프로듀서는 ack라는 상세 옵션이 있는데, ack 값 (0, 1, all)에 따라 고가용성을 유지할 수 있다.
    - ack 값이 0: leader 파티션에게 데이터를 전송하고 응답값은 받지 않는다.
    - ack 값이 1: leader 파티션에게 데이터를 전송하고 응답값을 받는다.
    - ack 값이 all
      - leader 파티션에게 데이터를 전송하고 follower 파티션에 정상 복제되었는지 응답값을 받는다.
      - all을 사용하면 데이터 유실은 없지만 확인하는 부분이 많아 속도가 느리다는 단점이 있다.
