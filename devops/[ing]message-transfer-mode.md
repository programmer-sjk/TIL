# 메시지 시스템들의 전송 방식

- 메시지 전송 방식의 `적어도 한 번 전송(at-least-once)`, `최대 한 번 전송(at-most-once)`, `중복 없는 전송`, `정확히 한 번 전송`을 알아보자.

## 적어도 한 번 전송 (at-least-once)

<img src="https://github.com/programmer-sjk/TIL/blob/main/images/devops/at-least-once.png" width="500">

- 위 그림은 적어도 한 번 전송 과정을 그림으로 나타낸 것으로 순서대로 살펴보자
  - 프로듀서가 브로커의 특정 토픽으로 메시지 A를 전송한다.
  - 브로커는 잘 받았다는 의미로 ACK를 프로듀서에게 응답한다.
  - 브로커의 ACK를 받은 프로듀서는 다음 메시지 B를 브로커에게 전송한다.
  - 브로커는 메시지를 받았지만 네트워크 오류나 브로커 장애로 인해 결국 ACK가 프로듀서에게 전달되지 않는다.
  - 메시지 B의 ACK를 받지 못한 프로듀서는 브로커가 메시지 B를 받지 못했다고 판단해 메시지 B를 재전송한다.
- 프로듀서가 메시지 B의 ACK를 받지 못한 시점에, 프로듀서 입장에선 브로커가 데이터를 받고 ACK를 전송하지 못한건지 데이터를 받지 못해서 ACK를 전송하지 못한건지 알 수가 없다. 이때 적어도 한 번 전송 방식에 따라 메시지 B를 다시 전송한다. 만약 브로커가 데이터를 받지 못했다면 처음 메시지를 저장하고, 브로커가 데이터를 받은 상태라면 중복 저장이 된다.
- 이렇게 일부 메시지 중복이 발생하더라도 최소한 하나의 메시지는 반드시 보장한다는 것이 적어도 한 번 전송 방식이며 카프카는 기본적으로 이 방식으로 동작한다.

## 최대 한 번 전송 (at-most-once)

<img src="https://github.com/programmer-sjk/TIL/blob/main/images/devops/at-most-once.png" width="500">

- 위 그림은 최대 한 번 전송 과정을 그림으로 나타낸 것으로 순서대로 살펴보자
  - 프로듀서가 브로커의 특정 토픽으로 메시지 A를 전송한다.
  - 브로커는 잘 받았다는 의미로 ACK를 프로듀서에게 응답한다.
  - 브로커의 ACK를 받은 프로듀서는 다음 메시지 B를 브로커에게 전송한다.
  - 브로커는 메시지를 받았지만 네트워크 오류나 브로커 장애로 인해 결국 ACK가 프로듀서에게 전달되지 않는다.
  - 프로듀서는 브로커가 받았다고 가정하고 메시지 C를 전송한다.
- 최대 한 번 전송은 ACK를 받지 못해도 재전송하지 않는다. 위 그림에서 사실 ACK를 받는 부분은 의미가 없지만 적어도 한 번 전송과 비교하기 위해 넣어두었다. 정리하면 최대 한 번 전송은 메시지 손실을 감안하더라도 중복 전송은 하지 않는 경우이다.
- 일부 메시지가 손실되더라도 높은 처리량을 필요로 하는 대량의 로그 수집이나 IoT 같은 환경에서 사용된다.

## 중복 없는 전송 (멱등성 프로듀서)

- 카프카의 0.11 버전부터 프로듀서가 메시지를 중복 없이 브로커로 전송할 수 있는 기능이 추가되었다.

<img src="https://github.com/programmer-sjk/TIL/blob/main/images/devops/no-duplicate.png" width="500">

- 위 그림은 중복 없는 전송 과정을 그림으로 나타낸 것으로 순서대로 살펴보자
  - 프로듀서가 브로커의 특정 토픽으로 메시지 A를 전송한다. 이때 PID(Producer ID)와 메시지의 시퀀스 번호 0을 같이 전달한다.
  - 브로커는 메시지를 저장하고 PID와 시퀀스 번호를 기록해둔다. 그리고 ACK를 프로듀서에게 응답한다.
  - 브로커의 ACK를 받은 프로듀서는 다음 메시지 B를 브로커에게 전송한다. PID는 동일하지만 시퀀스 번호는 증가한 1 값을 보낸다.
  - 브로커는 메시지를 저장하고 PID와 시퀀스 번호를 기록해둔다. 하지만 네트워크 오류나 브로커 장애로 인해 결국 ACK가 프로듀서에게 전달되지 않는다.
  - 메시지 B의 ACK를 받지 못한 프로듀서는 브로커가 메시지 B를 받지 못했다고 판단해 메시지 B를 재전송한다.
- 위 과정은 적어도 한 번 전송과 동일하다. 하지만 프로듀서가 메시지 B를 재전송할 경우의 동작은 다르다. 브로커는 전달받은 데이터로부터 PID와 시퀀스 번호를 확인하여 메시지 B가 이미 저장된 것을 확인하고 중복 저장하지 않고 ACK 응답만 보낸다. 결국 메시지의 중복 저장을 피할 수 있게 된다.
- 메시지 중복을 피하기 위해 사용되는 PID와 시퀀스 번호는 브로커의 메모리에 유지되고, 리플리케이션 로그에도 저장된다. 따라서 예기치 못한 브로커의 장애로 리더가 변경되더라도 새로운 리더가 PID와 시퀀스 번호를 정확히 알 수 있어 중복 없는 메시지 전송이 가능하다.
- 컨플루언트 블로그 글에 의하면 중복 없는 전송의 경우 오버헤드로 인해 20% 정도의 성능이 감소했다고 하는데 이는 그렇게 높은 편은 아니다. 따라서 성능이 민감하지 않은 상황에서 중복 없는 메시지 전송이 필요하다면 이 방식을 적용해야 한다.
- 중복 없는 전송을 위해 프로듀서 설정 값의 일부를 변경해야 한다.
  - enable.idempotence: true로 설정
  - max.in.flight.requests.per.connection: ACK를 받지 않은 상태에서 하기본 값은 5이며, 5 이하로 설정해야 한다.
  - acks: all로 설정해야 한다.
  - retries: ACK를 못 받은 경우 재시도 해야 하므로 0보다 큰 값으로 설정
- 위 설정을 반영하여 중복없는 전송을 제공하는 프로듀서를 멱등성 프로듀서라고 부른다. 만약 멱등성 프로듀서로 동작하는 어플리케이션이 종료되고 재시작되면 PID가 달라진다. PID가 달라지면 브로커 입장에선 다른 프로듀서 어플리케이션에서 데이터를 보냈다고 판단하기 때문에 장애가 발생하지 않을 경우에만 중복없는 전송이 보장되는 것을 고려해야 한다.
