# 선착순 이벤트 시스템

- [인프런 강의](https://www.inflearn.com/course/%EC%84%A0%EC%B0%A9%EC%88%9C-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%8B%A4%EC%8A%B5/dashboard)

## 요구사항

- 선착순 100 명에게 할인 쿠폰을 제공해야 한다.
- 100개가 초과되어 발급되면 안 된다.
- 순간적으로 몰리는 트래픽을 감당할 수 있어야 한다.

## 쿠폰 발급 로직

- Coupon Entity는 다음과 같다.

```java
@Entity
public class Coupon {
  private Long id;
  private Long userId; // 발급받은 user id

  public Coupon() {}
  public Coupon(Long userId) {
    this.userId = userId;
  }

  public Long getId() {
    return id;
  }
}
```

- Coupon을 발급하는 Service 로직은 아래와 같다.

```java
@Service
public class ApplyService {
  private final CouponRepository couponRepository;
  public ApplyService(CouponRepository couponRepository) {
    this.couponRepository = couponRepository;
  }

  public void apply(Long userId) {
    long count = couponRepository.count();

    if (count > 100) {
      return;
    }

    couponRepository.save(new Coupon(userId));
  }
}
```

## 쿠폰 발급 로직에서 문제점

- 실제로 동시에 요청이 들어오면 race condition이 발생한다.
- 쿠폰이 99개 발급된 시점에 동시에 여러 쓰레드가 이미 count 로직을 실행하고 있어서 save 메서드로 실행되기 전에 여러 쓰레드들이 count 로직에서 99개로 조회해서 if문에서 return 되지 않고 save 메서드를 실행
- 결과적으로 100개가 넘는 쿠폰이 생성
- race condition을 해결하기 위한 방법은 몇 가지 있지만 이 강의에서는 Redis를 활용

## Redis를 활용한 문제점 해결

- 위에서 문제는 결국 쿠폰 개수에 대한 정합성으로 기반한다.
- Redis에는 increment 메서드가 있는데 key에 해당하는 value를 1 올려주는 메서드이다.
- Redis는 싱글 스레드로 동작하여 Race Condition이 발생하지 않고 increment는 성능이 매우 빠른 메서드이다.

### Redis를 추가한 코드

- 추가 된 CouponCountRepository

```java
@Repository
public class CouponCountRepository {
  private final RedisTemplate<String, String> redisTemplate;
  public CouponCountRepository(RedisTemplate<String, String> redisTemplate) {
    this.redisTemplate = redisTemplate;
  }

  public Long increment() {
    return redisTemplate.opsForValue().increment("coupon_count");
  }
}
```

- 수정 된 ApplyService

```java
@Service
public class ApplyService {
  private final CouponRepository couponRepository;
  private final CouponCountRepository couponCountRepository;

  public ApplyService(
    CouponRepository couponRepository,
    CouponCountRepository couponCountRepository
  ) {
    this.couponRepository = couponRepository;
    this.couponCountRepository = couponCountRepository;
  }

  public void apply(Long userId) {
    Long count = couponCountRepository.increment(); // couponCountRepository 기반으로 수정 됨

    if (count > 100) {
      return;
    }

    couponRepository.save(new Coupon(userId));
  }
}
```

### 어떻게 해결되었나

- 위 코드에서 `couponCountRepository.increment()` 메서드는 여러 쓰레드에 의해 동시에 호출될 수 있다.
- 하지만 코드 내부에서 Redis의 increment를 임의의 쓰레드가 실행하게 되면 다른 쓰레드들은 대기하게 되어 쿠폰 개수의 정합성을 보장할 수 있다.
