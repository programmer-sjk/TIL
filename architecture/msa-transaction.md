# MSA 환경에서 분산 트랜잭션

- MSA 환경에선 여러 DB로 서비스가 구성되기에 트랜잭션 처리가 힘들다는 단점이 있다.
- MSA 환경에서 분산 트랜잭션을 위한 방법들을 정리한다.

## 2 Phase Commit Pattern (2PC 패턴)

- **`중간에 코디네이터(트랜잭션 관리자)를 두는 방식`**. prepare, commit 2 단계로 나뉜다.
- 주문 DB와 재고 DB가 나뉘어있다고 가정하자.
  - prepare 단계: 주문 요청을 받은 코디네이터는 주문 서비스와 재고 서비스에 각각 쿼리를 처리할 수 있는지 요청한다. 주문은 사용자의 쿠폰이나 포인트 등 주문을 진행할 수 있는지 유효성을 확인하고 문제가 없다면 가능하다고 응답한다. 재고 서비스도 재고에 문제가 없으면 가능하다고 응답한다.
  - commit 단계: 코디네이터는 분산된 서비스로부터 모두 가능하다는 응답을 받으면 commit 요청을 전달하고 각각의 서비스가 commit 하는 구조이다.
- **`분산 DB에서 트랜잭션이 가능하지만 아래와 같은 단점들이 있다`**.
  - 코디네이터가 SPOF가 될 수 있다.
  - 코디네이터와 각 서비스간 결합도가 강해진다.
  - 각 DB는 특정 레코드를 조회하거나 업데이트시 레코드에 락을 걸기 때문에 응답시간이 지연된다.
- 결론적으로 2PC 패턴은 이론적인 방법이나 **`실무에서는 성능 이슈가 커 잘 사용하지 않는다`**.

## Saga 패턴

- **`각 DB의 트랜잭션을 순차적으로 처리하고 문제가 발생할 경우 메시지를 발행해 보정하는 방식이다`**.
- 주문 서비스는 먼저 주문 DB에 commit을 하고 메시지 큐를 이용해 재고 서비스에게 이벤트를 발행한다. 재고 서비스는 이벤트를 받아 재고를 감소시키고 commit 한다. 성공할 때도 메시지를 전달할 것인지는 선택할 수 있다. 하지만 실패한다면 메시지 큐를 이용해 주문 서비스에게 실패 이벤트를 전달하고 주문 서비스는 해당 주문이 실패했다고 보정 작업을 하는 방식이다.
- **`Saga 패턴은 Orchestrator를 사용하지 않은 방법과 사용하는 방법으로 나뉜다`**. 사용하지 않는다면 각 이벤트를 발행하는 주체는 각 서비스가 된다. Orchestrator를 사용한다면 트랜잭션에 관여하는 모든 서비스는 Orchestrator에 의해 트랜잭션을 실행하고 Orchestrator에게 결과를 응답한다. 만약 하나의 트랜잭션이 실패하면 Orchestrator가 각 서비스에게 롤백 요청을 전달한다.
- Orchestrator를 사용하지 않는다면 쉽게 구성할 수 있으나 서비스가 많아질수록 현재 트랜잭션의 상태를 파악하기 어렵다는 단점이 있다. 사용한다면 각 서비스간에 이벤트 순환이 없어지고 각 서비스들이 서로를 몰라도 되기에 결합도가 낮아진다. 또한 트랜잭션 상태를 Orchestrator에서 쉽게 추적할 수 있는 장점이 있는 반면 Orchestrator가 SPOF가 될 수 있는점, 추가적인 인프라를 구성해야 한다는 점, 구현이 상대적으로 어렵다는 단점이 있다.