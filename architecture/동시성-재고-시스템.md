# 재고 시스템으로 알아보는 동시성 이슈 해결방법

- [인프런 강의](https://www.inflearn.com/course/%EB%8F%99%EC%8B%9C%EC%84%B1%EC%9D%B4%EC%8A%88-%EC%9E%AC%EA%B3%A0%EC%8B%9C%EC%8A%A4%ED%85%9C/dashboard)

## 재고 감소 로직

```java
// Stock service layer
public void decrease(Long id, Long quantity) {
  Stock stock = stockRepository.findById(id).orElseThrow();
  stock.decrease(quantity);

  stockRepository.saveAndFlush(stock);
}

// Stock entity
public decrease(Long quantity) {
  if (this.quantity - quantity < 0) {
    throw new RunTimeException("재고는 0개 미만이 될 수 없음")
  }

  this.quantity -= quantity;
}
```

## 위 코드의 문제점

- 100개의 쓰레드가 동시에 접근하면 테스트를 통해 재고가 0개가 아닌 96이 남은 것을 확인할 수 있었다.
- 문제는 Race Condition 때문.
  - 우리가 원하는 건 A 쓰레드가 재고를 감소시키고, 감소시킨 재고가 저장된 후 B 쓰레드 접근을 원함
  - 실제로는 동시에 여러 쓰레드들이 `findById` 메서드를 실행시켜 순차적으로 감소가 불가능
