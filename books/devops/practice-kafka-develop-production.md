# 실전 카프카 개발부터 운영까지

- [링크](https://www.yes24.com/Product/Goods/104410708)

## 1. 카프카 개요

- 아파치 카프카와 컨플루언트 카프카를 비교하자면 아파치 카프카를 자동차의 핵심 엔진이라고 비유할 때,
  컨플루언트 카프카는 내비게이션, 각종 편의기능이 모두 탑재된 완성된 자동차라고 할 수 있다.

### 카프카의 주요 특징

- 높은 처리량과 낮은 지연시간
- 높은 확장성
- 고 가용성 / 내구성
- 개발 / 운영 / 관리 편의성

### 카프카의 성장

- 2011년 카프카가 공개된 후 추가된 기능들을 살펴보자
  - v0.8: 리플리케이션 추가
    - 브로커에 장애가 발생해도 복제 기능으로 데이터 유실 없이 안정적으로 사용이 가능해짐
  - v0.8.2: 스키마 레지스트리
    - 프로듀서 / 컨슈머 간에 서로 데이터 구조를 설명할 수 있는 스키마를 등록할 수 있는 기능
  - v0.9: 카프카 커넥트
    - 다양한 시스템과 프로토콜을 별도의 코드 작성 없이도 연동이 가능해짐
  - v0.10: 카프카 스트림즈
    - 실시간 처리를 간편하게 제공
  - v3.0: 주키퍼 의존성 해방
    - 분산 코디네이터 시스템은 주키퍼는 카프카가 높은 성능을 갖는데 장벽이 되어옴
    - 주키퍼 의존성이 제거된 정식 카프카를 발표했지만 아직 운영 환경에서 사용은 추천하지 않음
    - 프로듀서의 전송 보장에 대해 중복 없는 전송(멱등성) 방식을 기본값으로 채택

## 3. 카프카 기본 개념과 구조

### 3.1 카프카 기초 다지기

- 카프카를 구성하는 주요 요소
  - 프로듀서 / 컨슈머 / 토픽 / 파티션 / 메시지
  - 주키퍼: 카프카의 메타데이터 관리 및 정상 상태 점검(health check)을 담당
  - 카프카 클러스터: 여러 대의 브로커로 구성된 클러스터를 의미
  - 브로커: 카프카 어플리케이션이 설치된 서버
  - 세그먼트: 메시지가 브로커의 로컬 디스크에 저장되는 파일을 의미

#### 3.1.1 리플리케이션

- 각 메시지를 복제해 카프카 클러스터 내 브로커들에 분산시키는 동작을 의미한다. 리플리케이션 덕분에 하나의 브로커가 종료되더라도 카프카는 안정성을 유지할 수 있다.
- replication-factor 옵션으로 지정할 수 있고 factor 수가 커지면 안정성은 높아지지만 브로커 리소스를 많이 사용하게 된다. 따라서 아래와 같은 기준을 세우는게 좋다.
  - 테스트나 개발환경: 팩터 수 1
  - 운영 환경(로그성 메시지나 유실 허용): 팩터 수 2
  - 운영 환경(유실 허용하지 않음): 팩터 수 3
- 저자의 경험 상 팩터 수가 3일 경우 메시지 안정성도 보장하고 적절한 디스크 공간을 사용가능

#### 3.1.2 파티션

- 토픽 하나의 처리량을 늘리기 위해 토픽 내에 여러 파티션을 둘 수 있다. 파티션 수는 줄일 수 없기 때문에 초기에 토픽을 생성할 땐 파티션 수를 작게 2개나 4개 정도로 생성 후 메시지 처리량이나 컨슈머 LAG을 모니터링 하면서 조금씩 늘려가는게 좋다.

#### 3.1.3 세그먼트

- 프로듀서가 전송한 메시지는 토픽의 파티션에 저장되며, 각 메시지들은 세그먼트라는 로그 파일의 형태로 브로커의 로컬 디스크에 저장된다.

### 3.2 카프카 핵심 개념

- 카프카가 높은 처리량과 안정성을 지니게 된 특성들을 정리한다.

#### 3.2.1 분산 시스템

- 분산 시스템은 단일 시스템이 갖지 못한 높은 성능을 목표로 하며, 하나의 서버에 장애가 발생할 때 다른 서버가 대신 처리하므로 장애 대응이 탁월하고 부하가 높은 경우 시스템 확장이 용이하다는 장점이 있다.
- 카프카도 분산 시스템이므로 높은 메시지 처리량이 필요할 경우 브로커를 추가하는 방식으로 확장이 가능하고 이는 카프카의 큰 장점 중 하나이다.

#### 3.2.2 페이지 캐시

- OS는 성능을 높이기 위해 꾸준히 개선되고 있는데 페이지 캐시 활용이 대표적이다. 카프카는 OS의 페이지 캐시를 활용하는 방식으로 설계되어 디스크 I/O를 줄여 성능을 높일 수 있다.

#### 3.2.3 배치전송 처리

- 카프카는 프로듀서 / 컨슈머와 통신하며 수 많은 메시지를 주고받는다. 수 많은 통신을 묶어서 처리한다면 단건으로 통신할 때에 비해 네트워크 오버헤드를 줄일 수 있고 장기적으로 더욱 빠르고 효율적으로 처리할 수 있다.

#### 3.2.4 압축 전송

- 카프카는 메시지 전송 시 성능이 높은 압축 전송을 사용하는 것을 권장한다. 높은 압축률이 필요하면 gzip, zstd를 권장하고 빠른 응답 속도가 필요하다면 lz4나 snappy를 권장한다.

#### 3.2.5 토픽, 파티션, 오프셋

- 카프카는 토픽에 데이터를 저장하고 토픽은 병렬 처리를 위해 여러 개의 파티션으로 나뉜다. 파티션의 메시지가 저장되는 위치를 오프셋이라고 부르며 오프셋은 순차적으로 증가하는 숫자 형태로 되어 있다. 각 파티션마다 오프셋은 고유한 숫자로 카프카는 오프셋을 통해 메시지의 순서를 보장하고 컨슈머가 마지막까지 읽은 위치를 알 수 있다.

#### 3.2.6 고가용성 보장

- 앞에 말한 것처럼 카프카는 분산 시스템이기 때문에 하나의 서버가 다운되어도 안정적인 서비스가 가능하다.
- 고가용성 보장을 위해 카프카는 리플리케이션 기능을 제공한다. 복제 기능은 토픽의 파티션을 복제하는 것으로 리더 파티션과 팔로워 파티션이라는 용어를 사용한다.
- 팔로워 수만큼 브로커의 디스크 공간도 소비되므로 일반적으로 리플리케이션 팩터 수를 3으로 구성하도록 권장한다. 리더는 프로듀서 / 컨슈머로부터 오는 모든 읽기 / 쓰기 요청을 처리하고, 팔로워는 오직 리더로부터 데이터를 복제하게 된다.

#### 3.2.7 주키퍼의 의존성

- 주키퍼는 하둡의 서브 프로젝트 중 하나로 출발해 2011년 아파치 탑 레벨 프로젝트로 승격되었다. 오늘날 아파치 산하 프로젝트인 카프카, 하둡, HBase 등 많은 분산 어플리케이션의 코디네이터 역할을 하는 어플리케이션으로 사용되고 있다.
- 주키퍼는 여러 대의 서버로 구성되고, 살아 있는 노드수가 과반수 이상이 유지되면 지속적인 서비스가 가능한 구조이다. 따라서 주키퍼는 반드시 홀수로 구성되어야 한다.
- 주키퍼는 브로커의 노드, 토픽, 컨트롤러를 관리하는 중요한 역할을 맡지만 카프카가 성장하면서 주키퍼 성능의 한계가 드러나기 시작했다. 현재는 카프카에서 주키퍼의 의존성을 제거하려는 움직임이 진행중이며 실제로 현재 주키퍼가 삭제된 카프카 버전이 릴리즈 되었다.
