# 아파치 카프카 애플리케이션 프로그래밍 with 자바

- [책 링크](https://www.yes24.com/Product/Goods/99122569)

## 1. 들어가며

### 1.1 카프카의 탄생

- 링크드인은 초기에 단방향 통신을 통해 소스 어플리케이션에서 타겟 어플리케이션으로 연동하는 소스 코드를 작성하여 운영했다. 시간이 지날수록 아키텍처는 복잡해졌고 소스/타겟 어플리케이션이 많아지면서 데이터를 전송하는 라인이 복잡해지기 시작했다.
- 링크드인의 데이터 팀은 신규 시스템을 만들기로 결정했고 그 결과물이 아파치 카프카다. 각 어플리케이션이 연결하여 데이터를 처리하는 것이 아니라 한 곳에 모아 처리할 수 있도록 중앙집중화했다. 웹 사이트, 어플리케이션, 센서에서 취합한 데이터 스트림을 카프카 한 곳에서 수집하고 사용자들이 실시간으로 소비할 수 있게 동작한다.
- 기존에 1:1 매칭으로 운영하던 시스템에선 한쪽의 장애가 한쪽에 영향을 미치곤 했지만 카프카는 이러한 의존도를 타파한다. 소스 어플리케이션에서 생성되는 데이터는 어떤 타겟 어플리케이션으로 보낼 것인지 고민하지 않고 카프카로 넣으면 된다. 카프카 내부에 데이터가 저장되는 파티션의 동작은 FIFO 방식의 큐와 유사하다. 큐에 데이터를 보내는 것이 프로듀서고, 큐에서 데이터를 가져가는 것이 컨슈머다.
- 상용 환경에서 카프카는 3대 이상의 브로커에서 분산 운영하여 데이터를 안전하게 기록한다. 3대 이상으로 이루어진 카프카 클러스터 중 일부 서버에 장애가 발생하더라도 데이터를 지속적으로 복제하기 때문에 안전하게 운영할 수 있다.

### 1.2 빅데이터 파이프라인에서 카프카 역할

- 빅 데이터를 저장하고 활용하기 위해, 우선 생성되는 데이터를 모두 모으는 것이 중요한데 이때 사용되는 개념이 데이터 레이크다. 데이터 웨어 하우스와는 다르게 필터링되거나 패키지화 되지 않은 데이터가 저장된다는 점이 특징이다.
- 서비스에서 발생하는 데이터를 데이터 레이크에 모으려면 단순히 생각할 때 발생하는 데이터를 직접 end-to-end 방식으로 넣을 수 있다. 하지만 서비스가 커지고 복잡해질수록 링크드인처럼 파편화되고 복잡도가 올라가는 문제가 발생한다. 이 때 데이터 파이프라인을 안정적이고 확장성 높게 운영하기 위해 좋은 방법 중 하나가 카프카를 활용하는 것이다. 왜 카프카가 적합한지 상세히 살펴보자.
  - 높은 처리량: 카프카는 프로듀서/컨슈머가 데이터를 보내고 받을 때 모두 묶어서 전송한다. 많은 양의 데이터를 묶음 단위로 배치에서 빠르게 처리할 수 있기 때문에 대용량의 실시간 로그데이터를 처리하는데 적합하다.
  - 확장성: 카프카는 데이터 양이 가변적인 환경에서 안정적으로 확장 가능하도록 설계되었다. 데이터가 적을 때는 브로커를 최소한의 개수로 운영하다가 데이터가 많아지면 브로커 개수를 늘려 스케일 아웃 할 수 있다.
  - 영속성: 영속성은 프로그램이 종료되더라도 사라지지 않는 데이터 특성을 뜻한다. 카프카는 다른 메시징 시스템과는 다르게 전송받은 데이터를 파일 시스템에 저장한다. 파일 시스템을 사용하는 것이 느리다고 생각하겠지만 카프카는 OS 레벨에서 파일 I/O 성능 향상을 위해 페이지 캐시 영역을 메모리에 따로 생성해서 사용한다.
  - 고가용성: 3개 이상의 서버로 운영되는 카프카 클러스터는 일부 서버에 장애가 발생하더라도 무중단으로 안전하고 지속적으로 데이터를 처리할 수 있다.
- 카프카 클러스터를 3대 이상의 브로커들로 구성해야 하는 이유
  - 브로커를 1대만 유지한다면 테스트 목적으로만 사용한다.
  - 브로커를 2대로 유지하면 한 대의 브로커에 장애가 발생하더라도 한 대가 살아 있어 안정적으로 데이터를 처리할 수 있다. 하지만 브로커 간에 데이터가 복제되는 시간차이로 일부 데이터가 유실될 가능성이 있다. 예를 들면 leader가 데이터를 받고 follower가 복제를 해야 하는데 leader가 죽은 경우.
  - 유실을 막기 위해 min.insync.replicas 옵션을 사용할 수 있는데 2로 설정하면 최소 2개 이상의 브로커에 데이터가 완전히 복제됨을 보장한다. 이 옵션을 2로 설정하면 브로커를 3대 이상으로 운영해야 한다.
  - 정리하면 유실없이 데이터를 복제하기 위해 min.insync.replicas 값을 2로 설정해야 한다. 그래야 최소 2개 이상의 브로커에 데이터가 완전히 복제되니까. 근데 브로커가 2대이면 한 대가 죽을 경우 replicas 2보다 작은 한 대의 브로커만 받기 때문에 에러가 발생한다. 따라서 3대로 운영하고 min.insync.replicas 값이 2면 카프카 한 대가 죽어도 정상적으로 동작한다.
