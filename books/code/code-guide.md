# 읽기 쉽고 코드 리뷰하기 좋은 코드 작성 가이드

- [책 링크](https://m.yes24.com/Goods/Detail/125977771)

## 가독성 높은 코드를 작성하는 법

### 생산성 개선

- 개발자들은 쓰는 것 보다 **`읽는 것에 개발 시간을 더 많이 할애한다`**.
- 코드를 읽을 읽이 많아진다는 것은 **`가독성을 높여야 생산성을 개선한다는 의미이다`**.

#### 개발 규모와 생산성의 관계

- 대규모 코드베이스에서 버그가 발생해서 코드 몇 줄을 수정하게 되었다.
  - **`가독성이 충분히 높으면 영향 범위를 쉽게 확인하고 안전하게 수정할 수 있다`**.
  - 가독성이 낮은 상황에서는 영향 범위를 확인하는데만 시간이 오래 걸리고, 또 다른 버그를 만들 수 있다.
- 장기간에 걸친 SW 개발은 코드를 계속 변경하며 성장해야 한다.
  - **`이해하기 쉽고 안정된 코드베이스가 성장을 이어가기 위한 열쇠다`**.
  - 코드를 이해하기 어렵다면 새로운 가치를 창출하는게 어려워지며, 인원을 추가로 투입해도 성과를 얻을 수 없다.
- 결국 **`코드의 가독성은 지속 가능한 개발 환경을 만드는데 큰 도움이 된다`**.

#### 가독성을 높이기 위한 환경과 평가 체계

- 만약 **`팀이 개발속도(구현한 기능의 수와 규모) 만으로 개발자를 평가하면`**, 팀 전체의 생산성을 높일 수 있는 동기를 부여하기 어렵다.
- 개발자 A,B 가 있다. A는 시간이 들더라도 가독성이 높은 코드를, B는 짧은 시간에 코드를 작성하는 중점을 둔다.
  - 결국 A도 더 좋은 평가를 받기 위해 가독성을 고려하지 않고 빠르게 개발하는 것만 신경쓰게 된다.
- 개발한 기능의 개수와 규모만으로 개발자를 평가해서는 안 되며, 생산성에 미치는 기여도를 고려한 제도도 필요하다.

### 가독성 높은 코드를 작성하기 위한 요건

#### 가독성을 높이기 위해 주의할 점

- 지식과 기술의 선택
  - 수단과 목적을 혼동해 **`무턱대고 신기술을 도입하면 오히려 코드나 설계의 품질이 떨어질 수 있다`**.
  - 프로그래밍 패러다임과 환경은 시대에 따라 변화하기 때문에 무조건적으로 적용하기 보다 상황에 따라 적절히 선택하자.
- 가치와 복잡도의 균형
  - 기능이 늘어날수록 복잡해지기 때문에, **`복잡도만 높일 뿐 가치가 없는 기능을 구현하는 일은 피해야 한다`**.
  - 가치를 바꾸지 않는 선에서 요구사항을 변경하여 구현에 필요한 코드의 양을 줄이는 것은 매우 필요하다.
  - 개발자는 요구사항을 수립하는 자리에서 복잡도 관점에서 의견을 적극적으로 제시해야 한다.

### 대표적인 프로그래밍 원칙

- **`가독성을 높이기 위해 제시된 프로그래밍 원칙들이 있다`**.
- 유용한 원칙도 무분별하게 적용하면 가독성을 떨어뜨린다. 비교적 부작용이 적은 원칙 다섯 가지를 소개한다.
  - 보이스카우트 원칙
  - YAGNI
  - KISS
  - 단일 책임의 원칙
  - 성급한 최적화는 모든 악의 근원

#### 보이스카우트 원칙

- 코드를 변경할 때 변경 전 보다 코드를 더 나아진 상태로 만들려고 노력한다는 원칙

#### YAGNI (You Aren't Gonna Need It)

- 그런 건 필요하지 않아를 뜻하며, **`미래를 위한 현재 필요하지 않은 기능을 미리 구현해도 정작 사용되지 않는다는 의미다`**.
- YAGNI를 준수하지 않는 코드로, 사용되지 않는 코드나 과도하게 확장된 코드가 있다.
- 사용되지 않는 코드 예시
  - 참조되지 않는 변수 / 호출되지 않는 함수 / 주석 처리 된 코드
- 과도하게 확장된 코드
  - 호출하는 곳이 하나뿐인 공개 유틸리티 함수 / 자식 클래스가 하나뿐인 추상 클래스

#### KISS (Keep It Simple Stupid)

- 단순하게 만들라는 원칙이다.
- 단순히 **`라이브러리, 프레임워크, 디자인 패턴을 사용하고 싶어서 복잡하게 만들면 안 된다`**.
- 이미 프레임워크나 라이브러리에서 제공하는 기능을 재구현 하는 것도 코드를 복잡하게 만든다.
  - **`불필요한 것을 추가하지 않는 것이 단순함을 향한 지름길이다`**.
- 아름답고 우아한 코드가 반드시 가독성이 높다고 할 수는 없다.
  - 자신이 작성하기 편한 코드가 아닌, 다른 사람이 읽기 편한 코드인가에 주목하자.

#### 단일 책임의 원칙

- 클래스가 변경 되는 이유는 단 한 가지어야 한다는 원칙
- 클래스에 부여하는 책임과 역할은 오직 하나뿐이라는 의미도 지닌다.

#### 섣부른 최적화는 만악의 근원

- 컴퓨터 과학의 거장 도널드 커누스는 최적화의 97%는 쓸모없는 일이라고 주장한다.
  - 충분한 효과를 기대할 수 없는 최적화는 코드를 복잡하게 만들고 가독성을 떨어뜨리는 결과를 가져온다.
- **`코드를 복잡하게 만들지 않는 선에서 최적화는 허용된다`**. 또 최적화를 통해 코드를 간결하게 만들 수 있다면 너무 좋다.

### 정리

- 코드를 읽는 작업에 투입되는 비용은 실제로 매우 크다.
- 코드의 가독성을 높이면 제품의 성장 한계치를 높일 수 있다.
- 이를 실현하기 위해 개인의 평가 기준을 포함한 업무 환경 개선도 고려해야 한다.

## 네이밍

- 코드의 가독성을 높이려면 네이밍은 정확하고 설명적이어야 한다.
- 정확하다는 것은 명명된 이름과 실제 사용되는 의미가 일치한다는 뜻이다.
- 설명적이라는 것은 이름만 보고도 그것이 무엇인지 알 수 있는 것을 의미한다.

### 네이밍에 사용하는 영문법

- 영문법을 무시하고 단순히 단어를 나열하면 이름을 해석하기 어려워진다.
- `ListerEventMessageClickViewText` 라는 이름의 클래스가 있다고 가정하자.
  - 리스너 일수도, 이벤트 일수도, 뷰일 수도 있는 클래스 같은 이름은 혼란스럽다.
- `MessageTextViewClickEventListener` 라는 네이밍을 생각해보자.
  - 이벤트 리스너라는 사실을 알 수 있고, 구체적인 정보는 앞 부분을 통해 얻을 수 있다.

#### 명사 또는 명사구

- 명사구를 사용할 때는 대상이 무언지를 나타내는 단어를 마지막에 두는 것이 좋다.
  - 버튼의 높이라면 높이에 해당하는 height을 이름 마지막에 두는게 좋다.
- 전치사를 사용하는 것은 예외적인 경우이며, 기본적으로 중요한 단어를 마지막에 두는 것이 바람직하다.
- 사용자의 수를 정수로 표현하는 네이밍을 생각해보자.
  - numUsers는 num이 마지막에 위치하므로 좋지 않다.
  - numOfUsers는 후보지만 가급적이면 전치사를 사용하는 것보다 인원수를 의미하는 단어를 마지막에 두는게 좋다.
  - userNumber로 바꿀 수 있지만, 사용자의 식별자(ID)로 오해할 수 있다.
  - userCount나 userTotal이 오해의 소지가 적고 명확해진다.

#### 명령문

- 메서드의 네이밍에는 명령문을 사용한다. 명령문을 사용할 때는 동사 원형을 이름 앞에 붙이는게 좋다.

### 이름에서 알 수 있는 내용

- 이름은 대상이 무엇이며, 무엇을 하는지를 표현해야 한다.
- 바꾸어 말해 대상이 언제, 어디서, 어떻게 사용되는지를 언급하면 안 된다.

#### 인수 이름

- 사용자 목록을 가져와서 표시하는 showUserList 라는 함수가 있다고 가정하자.
- 이 함수는 boolean 변수를 받아 오류 대화 상자 표시 여부를 결정한다.

  ```js
    // 무엇을 하는지에 초점을 둔 네이밍. GOOD
    function showUserList(shouldShowDialogOnError: boolean)

    // 어디서 호출하는지를 설명하는 네이밍. BAD
    function showUserList(isCalledFromLandingScreen: boolean)
  ```

- `shouldShowDialogOnError` 이름은 boolean으로 전달될 때 어떤일이 일어나는지 함수 선언만 봐도 알 수 있다.
- `isCalledFromLandingScreen` 이름은 어떤 일이 발생하는지 함수 내부의 코드를 읽어야 한다.
  - 또한 사양이 조금만 변경되어도 함수 이름과 실제 기능에 차이가 발생하게 된다. (LandingScreen이 아닌 EditScreen의 경우)
  - 또한 값의 책임 범위가 명확하지 않아 원래 목적과 다른 용도로 사용될 수 있다.

#### 함수 이름

- 메시지를 받았을 때 내용을 표시하는 함수를 네이밍해보자.
  - 내용을 표시한다에 초점을 맞추어 `showReceivedMessage`는 적절하다.
  - 메시지를 받았을 때에 초점을 맞추어 `onMessageReceived`로 네이밍하면 적절하지 않다.
- 메시지를 받았을 때 저장하는 함수의 경우
  - `storeReceivedMessage`는 적절하지만 `onMessageReceived`는 적절하지 않다.
- 두 네이밍의 차이는 호출하는 쪽의 코드를 비교하면 명확해진다.

  ```js
  // 호출하는 쪽에서 무엇을 하는지 알 수 있음
  presenter.showReceivedMessage(messageModel);
  repository.storeReceivedMessage(messageModel);

  // 호출하는 쪽에서 뭐하는지 알 수 없음
  presenter.onMessageReceived(messageModel);
  repository.onMessageReceived(messageModel);
  ```

- `onMessageReceived` 이름은 호출하는 쪽에서 무엇을 하는지 알 수가 없어서 세부 구현까지 읽어야 한다.
  - 호출자 입장에서 호출하는 시점이 메시지를 받았을 때로 이미 알고 있으므로 이름의 정보가 도움이 되질 않는다.
  - 함수의 책임 범위도 모호하다. 메시지를 표시하는 역할을 책임져야 하지만, DB에 데이터를 저장하는 코드가 있더라도 이름을 봐서는 이상함을 알 수 없다.

#### 예외: 추상 메서드

- 이름은 대상이 무엇이며, 무엇을 할 것인가를 명시해야 한다고 설명했다.
- 하지만 추상 메서드는 선언 시점에 무엇을 할 것인지 정해져있지 않은 경우가 많다.
- 이럴 때는 onClicked, onDestroyed 등과 같이 언제, 어디서 호출되는지를 기준으로 네이밍해도 된다.

### 단어 선택

#### 모호하지 않은 단어 선택하기

- 값의 한계를 나타내는 limit 단어는 상한선인지 하한선인지 모호하기 때문에 max, min을 사용하는게 명확하다.
- 모호할 수 있는 flag, check, old 세 가지를 예로 들어보자.

  ```js
  // 모호한 단어 flag
  // isInitializing, canInitialize, shouldInitialize 등이 더 권장됨

  // 모호한 단어 check
  // hasNewMessage, ifMessageFormatValid, throwIfMessageIdEmpty 등이 더 권장됨

  // 모호한 단어 old
  // previous, invalidated, expired, original, cached, deprecated 등이 더 권장됨
  ```

- 같은 무효화라도, 외부에서 무효화 된거면 invalidated, 예정된 시각에 무효화 된거면 expired를 쓰는게 좋다.

#### 혼란스러운 약어 피하기

- 약어를 사용할때는 정의를 찾아보지 않고도 그 의미를 알 수 있을지를 고려해야 한다.
- 즉 코드를 읽을 다른 사람이 이해하기 쉬운지가 판단하는 기준이 되어야 한다.
- 반면 VIP, TCP, str 같이 사실상 표준화되어 사용되는 약어는 사용해도 좋다.

#### 단위나 실체를 나타내는 단어 추가하기

- 정수 등 값의 타입만 봐서는 무슨 단위인지 알 수 없는 경우, 단위를 추가하는게 좋다.
  - `timeout` 정수형 변수보다는 `timeoutInSeconds, timeoutInMillis` 가 낫다.

#### 긍정적인 단어 사용하기

- 긍정과 부정의 단어가 모두 존재한다면 긍정적인 단어를 사용하는게 가독성에 더 좋다.
- 특히 부정 연산자를 비교해보면 `!isEnabled`, `!isDisabled` 가 되는데, 후자는 이중 부정이 되어 읽기 어렵다.
- 만약 `isNotEmpty`를 사용하다가 부정연산자 `!isNotEmpty`로 쓰게 되면 isEmpty로 쓰는것이 더 좋다.
- 특히 `isNotDisabled`와 같이 부정적인 단어와 부정어를 동시에 쓰는 표현은 피해야 한다.

### 언어, 플랫폼, 코딩 규약

- 이 책에서 설명한 내용은 일반론으로 언어나 프로젝트에서 정한 컨벤션이 있다면 그걸 따라야 한다.
- 설령 납득할 수 없는 컨벤션이라도, 개인이 임의로 판단해 그것을 어겨서는 안 된다.

### 정리

- 네이밍에 가장 중요한 단어를 마지막에 넣고, 동사 원형은 앞에 두기
- 이름이 표현해야 할 내용은 대상이 무엇을 하는지이다. 언제, 누가, 어떻게는 고려 대상이 아니다.
- 단어는 모호하거나 약어는 피하고, 긍정적인 단어를 사용하자.
