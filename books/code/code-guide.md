# 읽기 쉽고 코드 리뷰하기 좋은 코드 작성 가이드

- [책 링크](https://m.yes24.com/Goods/Detail/125977771)

## 가독성 높은 코드를 작성하는 법

### 생산성 개선

- 개발자들은 쓰는 것 보다 **`읽는 것에 개발 시간을 더 많이 할애한다`**.
- 코드를 읽을 읽이 많아진다는 것은 **`가독성을 높여야 생산성을 개선한다는 의미이다`**.

#### 개발 규모와 생산성의 관계

- 대규모 코드베이스에서 버그가 발생해서 코드 몇 줄을 수정하게 되었다.
  - **`가독성이 충분히 높으면 영향 범위를 쉽게 확인하고 안전하게 수정할 수 있다`**.
  - 가독성이 낮은 상황에서는 영향 범위를 확인하는데만 시간이 오래 걸리고, 또 다른 버그를 만들 수 있다.
- 장기간에 걸친 SW 개발은 코드를 계속 변경하며 성장해야 한다.
  - **`이해하기 쉽고 안정된 코드베이스가 성장을 이어가기 위한 열쇠다`**.
  - 코드를 이해하기 어렵다면 새로운 가치를 창출하는게 어려워지며, 인원을 추가로 투입해도 성과를 얻을 수 없다.
- 결국 **`코드의 가독성은 지속 가능한 개발 환경을 만드는데 큰 도움이 된다`**.

#### 가독성을 높이기 위한 환경과 평가 체계

- 만약 **`팀이 개발속도(구현한 기능의 수와 규모) 만으로 개발자를 평가하면`**, 팀 전체의 생산성을 높일 수 있는 동기를 부여하기 어렵다.
- 개발자 A,B 가 있다. A는 시간이 들더라도 가독성이 높은 코드를, B는 짧은 시간에 코드를 작성하는 중점을 둔다.
  - 결국 A도 더 좋은 평가를 받기 위해 가독성을 고려하지 않고 빠르게 개발하는 것만 신경쓰게 된다.
- 개발한 기능의 개수와 규모만으로 개발자를 평가해서는 안 되며, 생산성에 미치는 기여도를 고려한 제도도 필요하다.

### 가독성 높은 코드를 작성하기 위한 요건

#### 가독성을 높이기 위해 주의할 점

- 지식과 기술의 선택
  - 수단과 목적을 혼동해 **`무턱대고 신기술을 도입하면 오히려 코드나 설계의 품질이 떨어질 수 있다`**.
  - 프로그래밍 패러다임과 환경은 시대에 따라 변화하기 때문에 무조건적으로 적용하기 보다 상황에 따라 적절히 선택하자.
- 가치와 복잡도의 균형
  - 기능이 늘어날수록 복잡해지기 때문에, **`복잡도만 높일 뿐 가치가 없는 기능을 구현하는 일은 피해야 한다`**.
  - 가치를 바꾸지 않는 선에서 요구사항을 변경하여 구현에 필요한 코드의 양을 줄이는 것은 매우 필요하다.
  - 개발자는 요구사항을 수립하는 자리에서 복잡도 관점에서 의견을 적극적으로 제시해야 한다.

### 대표적인 프로그래밍 원칙

- **`가독성을 높이기 위해 제시된 프로그래밍 원칙들이 있다`**.
- 유용한 원칙도 무분별하게 적용하면 가독성을 떨어뜨린다. 비교적 부작용이 적은 원칙 다섯 가지를 소개한다.
  - 보이스카우트 원칙
  - YAGNI
  - KISS
  - 단일 책임의 원칙
  - 성급한 최적화는 모든 악의 근원

#### 보이스카우트 원칙

- 코드를 변경할 때 변경 전 보다 코드를 더 나아진 상태로 만들려고 노력한다는 원칙

#### YAGNI (You Aren't Gonna Need It)

- 그런 건 필요하지 않아를 뜻하며, **`미래를 위한 현재 필요하지 않은 기능을 미리 구현해도 정작 사용되지 않는다는 의미다`**.
- YAGNI를 준수하지 않는 코드로, 사용되지 않는 코드나 과도하게 확장된 코드가 있다.
- 사용되지 않는 코드 예시
  - 참조되지 않는 변수 / 호출되지 않는 함수 / 주석 처리 된 코드
- 과도하게 확장된 코드
  - 호출하는 곳이 하나뿐인 공개 유틸리티 함수 / 자식 클래스가 하나뿐인 추상 클래스

#### KISS (Keep It Simple Stupid)

- 단순하게 만들라는 원칙이다.
- 단순히 **`라이브러리, 프레임워크, 디자인 패턴을 사용하고 싶어서 복잡하게 만들면 안 된다`**.
- 이미 프레임워크나 라이브러리에서 제공하는 기능을 재구현 하는 것도 코드를 복잡하게 만든다.
  - **`불필요한 것을 추가하지 않는 것이 단순함을 향한 지름길이다`**.
- 아름답고 우아한 코드가 반드시 가독성이 높다고 할 수는 없다.
  - 자신이 작성하기 편한 코드가 아닌, 다른 사람이 읽기 편한 코드인가에 주목하자.

#### 단일 책임의 원칙

- 클래스가 변경 되는 이유는 단 한 가지어야 한다는 원칙
- 클래스에 부여하는 책임과 역할은 오직 하나뿐이라는 의미도 지닌다.

#### 섣부른 최적화는 만악의 근원

- 컴퓨터 과학의 거장 도널드 커누스는 최적화의 97%는 쓸모없는 일이라고 주장한다.
  - 충분한 효과를 기대할 수 없는 최적화는 코드를 복잡하게 만들고 가독성을 떨어뜨리는 결과를 가져온다.
- **`코드를 복잡하게 만들지 않는 선에서 최적화는 허용된다`**. 또 최적화를 통해 코드를 간결하게 만들 수 있다면 너무 좋다.

### 정리

- 코드를 읽는 작업에 투입되는 비용은 실제로 매우 크다.
- 코드의 가독성을 높이면 제품의 성장 한계치를 높일 수 있다.
- 이를 실현하기 위해 개인의 평가 기준을 포함한 업무 환경 개선도 고려해야 한다.

## 네이밍

- 코드의 **`가독성을 높이려면 네이밍은 정확하고 설명적이어야 한다`**.
- 정확하다는 것은 명명된 이름과 실제 사용되는 의미가 일치한다는 뜻이다.
- 설명적이라는 것은 이름만 보고도 그것이 무엇인지 알 수 있는 것을 의미한다.

### 네이밍에 사용하는 영문법

- 영문법을 무시하고 단순히 단어를 나열하면 이름을 해석하기 어려워진다.
- `ListerEventMessageClickViewText` 라는 이름의 클래스가 있다고 가정하자.
  - 리스너 일수도, 이벤트 일수도, 뷰일 수도 있는 클래스 같은 이름은 혼란스럽다.
- `MessageTextViewClickEventListener` 라는 네이밍을 생각해보자.
  - 이벤트 리스너라는 사실을 알 수 있고, 구체적인 정보는 앞 부분을 통해 얻을 수 있다.

#### 명사 또는 명사구

- 명사구를 사용할 때는 **`대상이 무언지를 나타내는 단어를 마지막에 두는 것이 좋다`**.
  - 버튼의 높이라면 높이에 해당하는 `height`을 이름 마지막에 두는게 좋다.
- **`전치사를 사용하는 것은 예외적인 경우이며`**, 기본적으로 중요한 단어를 마지막에 두는 것이 바람직하다.
- 사용자의 수를 정수로 표현하는 네이밍을 생각해보자.
  - `numUsers`는 num이 마지막에 위치하므로 좋지 않다.
  - `numOfUsers`는 후보지만 가급적이면 전치사를 사용하는 것보다 인원수를 의미하는 단어를 마지막에 두는게 좋다.
  - `userNumber`로 바꿀 수 있지만, 사용자의 식별자(ID)로 오해할 수 있다.
  - `userCount나 userTotal`이 오해의 소지가 적고 명확해진다.

#### 명령문

- 메서드의 네이밍에는 명령문을 사용한다. 명령문을 사용할 때는 동사 원형을 이름 앞에 붙이는게 좋다.

### 이름에서 알 수 있는 내용

- **`네이밍은 대상이 무엇이며, 무엇을 하는지를 표현해야 한다`**.
- 바꾸어 말해 **`대상이 언제, 어디서, 어떻게 사용되는지를 언급하면 안 된다`**.

#### 인수 이름

- 사용자 목록을 가져와서 표시하는 `showUserList` 라는 함수가 있다고 가정하자.
- 이 함수는 `boolean` 변수를 받아 오류 대화 상자 표시 여부를 결정한다.

  ```js
    // 무엇을 하는지에 초점을 둔 네이밍. GOOD
    function showUserList(shouldShowDialogOnError: boolean)

    // 어디서 호출하는지를 설명하는 네이밍. BAD
    function showUserList(isCalledFromLandingScreen: boolean)
  ```

- `shouldShowDialogOnError` 이름은 boolean으로 전달될 때 어떤일이 일어나는지 함수 선언만 봐도 알 수 있다.
- `isCalledFromLandingScreen` 이름은 **`어떤 일이 발생하는지 함수 내부의 코드를 읽어야 한다`**.
  - 또한 사양이 조금만 변경되어도 함수 이름과 실제 기능에 차이가 발생하게 된다. (`LandingScreen`이 아닌 `EditScreen`의 경우)
  - 또한 값의 책임 범위가 명확하지 않아 원래 목적과 다른 용도로 사용될 수 있다.

#### 함수 이름

- 메시지를 받았을 때 내용을 표시하는 함수를 네이밍해보자.
  - 내용을 표시한다에 초점을 맞추어 `showReceivedMessage`는 적절하다.
  - 메시지를 받았을 때에 초점을 맞추어 `onMessageReceived`로 네이밍하면 적절하지 않다.
- 메시지를 받았을 때 저장하는 함수의 경우
  - `storeReceivedMessage`는 적절하지만 `onMessageReceived`는 적절하지 않다.
- 두 네이밍의 차이는 호출하는 쪽의 코드를 비교하면 명확해진다.

  ```js
  // 호출하는 쪽에서 무엇을 하는지 알 수 있음
  presenter.showReceivedMessage(messageModel);
  repository.storeReceivedMessage(messageModel);

  // 호출하는 쪽에서 뭐하는지 알 수 없음
  presenter.onMessageReceived(messageModel);
  repository.onMessageReceived(messageModel);
  ```

- `onMessageReceived` 이름은 **`호출하는 쪽에서 무엇을 하는지 알 수가 없어서 세부 구현까지 읽어야 한다`**.
  - 호출자 입장에서 호출하는 시점이 메시지를 받았을 때로 이미 알고 있으므로 이름의 정보가 도움이 되질 않는다.
  - 함수의 책임 범위도 모호하다. 메시지를 표시하는 역할을 책임져야 하지만, DB에 데이터를 저장하는 코드가 있더라도 이름을 봐서는 이상함을 알 수 없다.

#### 예외: 추상 메서드

- 이름은 대상이 무엇이며, 무엇을 할 것인가를 명시해야 한다고 설명했다.
- 하지만 추상 메서드는 선언 시점에 무엇을 할 것인지 정해져있지 않은 경우가 많다.
- 이럴 때는 `onClicked, onDestroyed` 등과 같이 언제, 어디서 호출되는지를 기준으로 네이밍해도 된다.

### 단어 선택

#### 모호하지 않은 단어 선택하기

- 값의 한계를 나타내는 limit 단어는 상한선인지 하한선인지 모호하기 때문에 `max, min`을 사용하는게 명확하다.
- 모호할 수 있는 `flag, check, old` 세 가지를 예로 들어보자.

  ```js
  // 모호한 단어 flag
  // isInitializing, canInitialize, shouldInitialize 등이 더 권장됨

  // 모호한 단어 check
  // hasNewMessage, ifMessageFormatValid, throwIfMessageIdEmpty 등이 더 권장됨

  // 모호한 단어 old
  // previous, invalidated, expired, original, cached, deprecated 등이 더 권장됨
  ```

- 같은 무효화라도, 외부에서 무효화 된거면 `invalidated`, 예정된 시각에 무효화 된거면 `expired`를 쓰는게 좋다.

#### 혼란스러운 약어 피하기

- **`약어를 사용할때는 정의를 찾아보지 않고도 그 의미를 알 수 있을지를 고려해야 한다`**.
- 즉 코드를 읽을 다른 사람이 이해하기 쉬운지가 판단하는 기준이 되어야 한다.
- 반면 VIP, TCP, str 같이 사실상 표준화되어 사용되는 약어는 사용해도 좋다.

#### 단위나 실체를 나타내는 단어 추가하기

- 정수 등 값의 타입만 봐서는 무슨 단위인지 알 수 없는 경우, 단위를 추가하는게 좋다.
  - `timeout` 정수형 변수보다는 `timeoutInSeconds, timeoutInMillis` 가 낫다.

#### 긍정적인 단어 사용하기

- 긍정과 부정의 단어가 모두 존재한다면 긍정적인 단어를 사용하는게 가독성에 더 좋다.
- 특히 부정 연산자를 비교해보면 `!isEnabled`, `!isDisabled` 가 되는데, **`후자는 이중 부정이 되어 읽기 어렵다`**.
- 만약 `isNotEmpty`를 사용하다가 부정연산자 `!isNotEmpty`로 쓰게 되면 isEmpty로 쓰는것이 더 좋다.
- 특히 `isNotDisabled`와 같이 **`부정적인 단어와 부정어를 동시에 쓰는 표현은 피해야 한다`**.

### 언어, 플랫폼, 코딩 규약

- 이 책에서 설명한 내용은 일반론으로 언어나 **`프로젝트에서 정한 컨벤션이 있다면 그걸 따라야 한다`**.
- 설령 납득할 수 없는 컨벤션이라도, 개인이 임의로 판단해 그것을 어겨서는 안 된다.

### 정리

- 네이밍에 가장 중요한 단어를 마지막에 넣고, 동사 원형은 앞에 두기
- **`이름이 표현해야 할 내용은 대상이 무엇을 하는지이다. 언제, 누가, 어떻게는 고려 대상이 아니다`**.
- 단어는 모호하거나 약어는 피하고, 긍정적인 단어를 사용하자.

## 주석

- 이름만으로 내용을 설명할 수 없는 경우나, 직관적이지 않은 코드의 경우 주석이 필요할 수도 있다.
- 그러나 **`무분별하게 주석을 추가하면 오히려 코드의 가독성과 유지보수성을 떨어뜨린다`**.

### 주석의 종류와 목적

- 주석을 적절히 작성하면 코드를 더 쉽게 이해할 수 있지만, 이점이 없다면 굳이 주석을 작성하지 않아도 된다.
- 대표적인 **`주석의 목적은 아래와 같다`**.
  - 코드를 좀 더 빠르게 이해하기 위해 (복잡한 알고리즘, 라이브러리의 사용법이 복잡한 경우)
  - 실수를 방지하기 위해 (왜 존재하는지 알 수 없는 코드가 있을 때, 설명이 없다면 제거될 수 있음)
  - 리팩터링을 쉽게 하기 위해
- 사전에 새로운 키워드와 의미를 등록하는 add 메서드를 보자.

  ```kotlin
    /**
     * 추가한 값은 getDescription으로 참조할 수 있다.
     * 이미 추가된 키워드라면 함수는 false를 반환, 그렇지 않으면 추가한 후 true를 반환
     */
    fun add(newData: Pair<String, String>): Boolean
  ```

- **`메서드의 동작은 간단한데 주석이 복잡한 경우, 네이밍이 적절치 못하거나 메서드의 사양이 필요 이상으로 복잡할 수 있다`**.
- 메서드를 살펴보면 아래와 같은 문제점을 발견할 수 있다.
  - add 메서드의 이름이 실제 동작에 비해 광범위하다.
  - newData 매개변수 이름에서 얻을 수 있는 정보가 부족하다.
  - 컬렉션의 경우 중복되면 덮어쓰는 방식이므로 중복시 무시라는 사양이 직관적이지 않다.
- 이 세가지 문제를 아래와 같이 개선해보자.

  ```kotlin
    /**
    * 키워드와 의미를 새로 추가 또는 덮어쓰기
    * 추가한 값은 getDescription으로 참조할 수 있다
    */
    fun registerDescription(keyword: String, description: String)
  ```

- 위처럼 **`주석의 길이와 복잡성은 어느정도 상관관계를 가진다`**. 단순한 코드에 주석이 길다면 개선할 여지가 있는지 확인하자.

### 문서화 주석

- 문서화 주석은 프로그래밍 언어나 문서화 도구에 따라 달라진다.
- 자바나 코틀린의 경우 `JavaDoc, KDoc`을 사용하며 `/**`로 시작하는 주석이 문서화 주석으로 해석된다.
- 문서화 주석만 보고, 코드가 무엇을 하는지 이해해야 하기 때문에 **`주의해야 할 안티패턴을 살펴보자`**.

#### 안티패턴. 선언과 같은 내용을 반복해서 쓴다

- 클래스나 함수 선언과 동일한 정보만 가지고 있다면 그 주석은 필요 없다고 할 수 있다.

  ```js
  // keyword에 대한 설명을 취득한다.
  function getDescription(keyword: string) { ... }
  ```

#### 안티패턴. 코드를 자연어로 직역한다

- 코드를 단순하게 직역한 주석으로는 코드를 이해하기 어렵다.
- **`문서화 주석은 코드를 읽지 않아도, 무엇을 하는지 이해할 수 있어야 한다`**.

  ```js
    /**
     * 만약 조건 A가 성립하면 doA를 호출한다.
     * 그렇지 않으면 doB를 호출한다.
     * 만약 조건 C가 성립한다면... (생략)
     */
    function getDescription(keyword: string) {
      if (A) {
        doA()
      } else {
        doB()
        if (c) {...}
      }
    }
  ```

#### 안티패턴. 구현의 세부 내용을 언급한다

- **`문서화 주석을 읽는 사람이 구현의 상세를 알고 있을 것이라고 전제해서는 안 된다`**.
- 이미 코드 내부까지 알고 있다면 굳이 주석을 읽을 필요가 없다.

  ```js
  // private 멤버 dictionary가 가지는 문자열을 반환한다.
  function getDescription(keyword: string) { ... }
  ```

#### 문서화 주석의 구성

- **`문서화 주석의 구성은 요약을 먼저 작성하고`**, 세부적인 내용을 보충하는 것이 좋다.
- 요약은 추상화된 자연어로 핵심적인 기능을 제공해야 한다.

  ```js
  /**
   * ex1) 사용자에 해당하는 프로필 이미지를 원 모양으로 잘라내어 표시한다.
   *
   * ex2) 수신된 메시지를 본문 텍스트에 표시한다.
   * 표시 레이아웃(텍스트, 발신자 이름, 발신 시각)을 업데이트 한다.
   */
  ```

#### 문서화 주석의 상세

- 상세는 모든 문서화 주석에 반드시 필요한 기능은 아니지만, 보충 설명이 필요한 경우엔 작성하는게 좋다.
- **`상세는 코드의 사용법을 구체적으로 설명해 개발자가 더 쉽게 코드를 사용하도록 돕는다`**.
- 실제 인수와 반환값의 상세한 예를 보여주는 문서화 주석

  ```js
  /**
   * 주어진 문자열을 쉼표 "," 분리하며 문자열 리스트로 반환한다.
   *
   * "a, bc ,,d"를 입력하면 ["a", "bc", "", "d"]를 반환한다.
   */
  function splitByComma(string: string): string[] {}
  ```

- 반환값의 제약 조건을 상세하게 설명하는 주석

  ```js
  /**
   * ...(요약)...
   *
   * 반환되는 값은 [0.0, 1.0] 범위로 제한된다.
   */
  function getDownloadProgress(): number {}
  ```

### 비형식 주석

- 프로그래밍 언어에서 `//, /* */`의 형태로 **`비형식 주석을 작성할 수 있다`**. 둘의 차이는 아래와 같다.
  - 문서화 주석: 코드를 읽지 않고도 내용을 파악할 수 있도록 하는 주석
  - 비형식 주석: 코드를 읽을 때 이해를 돕기 위한 주석
- 비형식 주석은 코드가 무엇을 하는지 설명하거나, 코드의 배경, 작성한 이유, 주의점을 적는다.

### 정리

- 문서화 주석은 선언이나 정의 부분에 작성하며 요약을 반드시 포함하고, 필요하다면 상세를 작성한다.
- 비형식 주석은 코드를 읽는데 도움을 주며 직관적이지 않은 코드를 설명하기 위해 작성한다.

## 상태

- **`불변 값을 사용하거나, 부수 효과가 없는 함수를 사용하면`** 코드가 견고해진다.
- 단, 불변 값과 부수 효과가 없는 함수는 **`가독성과 견고함을 향상시키기 위한 수단일 뿐, 그 자체가 목적이 되면 안 된다`**.

### 가변 값이 더 적합한 경우

- **`이진 트리의 너비 우선 탐색을`** 가변과 불변을 이용하는 두 가지 방법을 구현하면, **`가변 큐를 사용하는 로직이 더 쉽다`**.
- **`일반적으로는 불변 상태나 부수 효과가 없는 함수를 사용하는게 좋지만`**, 구현 대상에 따라 가변 값을 사용하는게 가독성 측면에서 유리할 수 있다.

### 변수 간의 관계, 직교

- 두 변수가 서로에게 영향을 주지 않는다면, 이 변수의 관계를 직교라고 한다.
- 반대로 직교하지 않는 관계. 서로에게 영향을 준다면 비직교로 정의한다.
- 비직교 관계를 배제하는 것은 가독성과 견고함을 높이기 위한 중요한 기법이다.

### 상태 전이의 설계

- `불변성, 멱등성, 비순환을` 통해 잘못된 상태 전이가 일어나지 않도록 설계하는 방법을 알아보자.

#### 불변성

- 처음부터 상태가 변하지 않는, 불변성을 가진 자료구조를 사용하면 잘못된 상태 전이가 일어나지 않는다.
- 불변과 읽기 전용은 전혀 다른 개념이다. 읽기 전용은 참조를 통해 값이 변경될 수 있다.

#### 멱등성

- 멱등성이란 한 번 실행하든, 여러 번 실행하든 결과가 동일하다는 개념이다.
- 멱등성을 지닌 함수는 그 함수를 호출하기 전에 현재 상태를 확인하지 않아도 된다
  - 반대로 멱등성이 없는 함수를 호출할 때는 잘못된 상태를 유발하지 않는지 미리 확인해야 한다.

#### 비순환

- 원래 상태로 돌아갈 수 있다면 그 상태 전이는 순환한다고 할 수 있다.
  - ex) `state1 -> state2 -> state3 -> state1`
- 반대로 원래 상태로 돌아갈 수 없다면 비순환이라고 부른다.
- 일반적으로 원래 상태로 돌아가는 순환은 피하는게 좋다.

## 함수

- 함수의 이름, 인수, 반환 타입등의 정보로 함수 동작을 예측할 수 있다면 코드를 읽는 비용을 줄일 수 있다.
- 특히 호출하는 쪽의 코드만으로 동작을 예측할 수 있다면, 훨씬 빠르게 코드를 읽을 수 있다.

### 함수의 책임

- 단일 책임의 원칙은 클래스뿐만 아니라 함수에도 적용되어야 한다는 것이 저자의 입장이다.
- 함수가 여러 책임을 지면 함수의 동작을 이해하기 어려워진다. 또한 재사용이 어렵고 설계에 악영향을 끼칠 수 있다.
- 하나의 함수가 지는 책임은 오직 하나여야 하며, 이를 위해 함수를 적절히 분할해야 한다.

#### 명령과 쿼리의 분리

- 명령과 쿼리 분리 원칙은 함수를 분할하는데 있어 중요한 기준이 된다.
- 이 원칙은 상태를 변경하는 함수와 상태를 조회하는 함수를 분리해야 한다는 개념이다.
  - 명령: 외부 상태를 변경하는 함수. 반환값을 가지지 않는다.
  - 쿼리: 반환값으로 정보를 취득하는 함수. 외부 상태를 변경하지 않는다.
- 명령과 쿼리의 분리 원칙 역시 가독성과 견고함을 위한 수단일 뿐, 목적이 되어서는 안 된다.
  - 이 원칙을 지나치게 적용하면, 함수와 호출자 사이에 강한 의존 관계가 발생하게 된다.

### 함수의 흐름

- 짧은 시간에 대략적으로 봐도 흐름이 명확한 함수를 만드려면, 함수가 아래 특성을 갖춰야 한다.
  - 세부 동작(중첩, 값 할당, 예외처리)을 읽지 않고도 이해할 수 있다.
  - 함수의 핵심이 되는 부분을 쉽게 파악할 수 있다.
  - 모든 조건 분기를 확인하지 않아도 이해할 수 있다.
- 위 특성을 만족시키기 위해 정의 기반 프로그래밍, 조기 반환을 소개한다.

#### 정의기반 프로그래밍

- 정의 기반 프로그래밍은 이름이 있는 변수, 함수를 주로 사용하는 프로그래밍 스타일을 말한다.
- 정의 기반 프로그래밍은 높은 추상화와 쉽게 파악할 수 있는 코드라는 장점을 제공한다.
- 아래 함수의 인자가 중첩된 구조를 살펴보자.

  ```js
  showDialogOnError(
    presenter.updateSelfProfileView(repository.queryUserModel(userId))
  );
  ```

- 위 코드의 문제는 어느 부분이 중요한 코드인지 알기 어렵다는 점이다.
- 정의 기반 프로그래밍으로 바꿔보면, 함수에 어떤 동작들이 있는지 더 쉽게 파악할 수 있다.

  ```js
  const userModel = repository.queryUserModel(userId);
  const viewUpdateResult = presenter.updateSelfProfileView(userModel);

  showDialogOnError(viewUpdateResult);
  ```

- 아래 if문 중첩은 지역변수나 비공개 함수를 이용해 개선해볼 수 있다.

  ```js
  if (messageModel.hasValidModel(messageId)) {
    if (messagePresenter.isMessageShown(messageId)) {
      if (queue.contains(messageId)) {
        showText('Sending');
      }
    }
  }

  // 지역변수 예제
  const isMessageValid = messageModel.hasValidModel(messageId);
  const isMessageShown = messagePresenter.isMessageShown(messageId);
  const isMessageSendingOnGoing = queue.contains(messageId);

  if (isMessageValid && isMessageShown && isMessageSendingOnGoing) {
    showText('Sending');
  }

  // 비공개 함수 예제
  if (
    isValidMessage(messageId) &&
    isViewShown(messageId) &&
    isUnderSending(messageId)
  ) {
    showText('Sending');
  }
  ```

- 이렇게 지역변수와 비공개 함수를 사용한다. 다만 비공개 함수가 너무 많으면 오히려 가독성을 떨어뜨리기 쉽다.
  - 지역변수로 충분하다면 비공개 함수를 사용하는 방법은 고려하지 않아도 된다.
- 이름이 없는 리터럴을 매직넘버라고 한다.
  - 의미가 명확하고 값이 변하지 않는 매직 넘버는 문제가 되지 않는다.
  - 배열 인덱스의 맨 앞을 나타내는 0이나, 다음을 구하는 +1, 중간을 나타내는 / 2는 모두 의미가 명확하다.
- 이렇게 명확하지 않은 매직 넘버는 그대로 사용하지 말고 읽기 전용 변수로 정의해야 한다.

  ```kotlin
    private const val QUERY_TIMEOUT_IN_MILLIS = 10000
  ```

- 정의 기반 프로그래밍을 적용할 때는 적용 범위에 주의하자. 범위가 부적절하면 오히려 가독성이 저하된다.

#### 조기 반환

- 함수의 로직이 성공 경로와 실패 경로가 있다고 가정하자.
- 성공 로직이 눈에 띄게 하고, 실패 경로를 깔끔하게 정리하기 위해서는 조기 반환을 활용하는게 좋다.
- 조기 반환은 함수 구현 초반부에 실패를 처리하는 부분을 모아두고 return 하여 함수를 종료시킨다.
- 결과적으로 함수의 초반부를 제외하고는 모두 성공 경로가 되기 때문에 흐름을 이해하기 수월해진다.

  ```js
  // Bad
  if (isNetworkAvailable()) {
    const queryResult = queryToServer();
    if (queryResult.isValid) {
      // 성공 경로 처리
    } else {
      showInvalidResponseDialog();
    }
  } else {
    showNetworkUnavailableDialog();
  }
  ```

- 위 코드보다는 조기 리턴을 적용시킨 아래 코드가 읽기 쉽다.

  ```js
  // Good. 조기 리턴 적용
  if (!isNetworkAvailable()) {
    showNetworkUnavailableDialog();
    return;
  }

  const queryResult = queryToServer();
  if (!queryResult.isValid) {
    showInvalidResponseDialog();
    return;
  }

  // 성공 경로 처리
  ```

### 정리

- 함수의 책임을 명확히 하기 위해 단일 책임 원칙을 함수에도 적용하는 것이 중요하다.
- 함수의 흐름을 명확하게 하기 위한 방법으로 정의 기반 프로그래밍, 조기 리턴 기법 등이 있다.

## 의존 관계

- 결합되는 두 클래스 사이에는 사용하는 클래스와 사용되는 클래스가 존재하는데 이를 의존 관계라고 한다.

### 의존 관계의 예

- 의존 관계는 필수적인 요소이지만, 적절히 다루지 않으면 가독성을 쉽게 해칠 수 있다.
- 아래 코드에선 두 클래스가 서로 의존적이라 fun1 동작을 이해하려면 Y의 세부사항을 알아야 한다.

  - 또한 Y도 X에 의존적이라 fun1의 동작을 쉽게 파악할 수 없다.

  ```kotlin
    class X {
      private val y = Y(this)
      fun func1() {
        y.func2();
      }

      fun func3() {
        ...
      }
    }

    class Y(private val x: X) {
      fun func2() {
        x.func3()
      }
    }
  ```

- 위처럼 극단적인 코드는 드물거라 생각하지만, 코드가 거대해지는 과정에서 의존 관계가 꼬이는 일은 흔히 발생한다.
- 결론적으로 의존도는 약하게, 순환하지 않고, 중복되지 않으며 관계는 명확하게 하는 것이 좋다. 왜 그런지 알아보자.

### 의존의 강도: 결합도

- 결합도란 클래스 간의 의존 정도를 나타내는 지표로 결합도는 낮을수록 좋다.

#### 호출 순서가 정해져있는 결합

- 아래는 함수의 호출 순서가 정해져 있는 코드의 예시다.
- Calculator는 Caller가 다음 제약 사항을 충족할 것을 기대한다.

  - calculate 호출 전에는 prepare(), 호출 후에는 teardown()을 호출한다.

  ```js
  class Calculator {
    prepare() {...}
    calculate() {...}
    teardown() {...}
  }

  class Caller {
    private readonly calculator = new Calculator();

    callCalculator() {
      calculator.prepare();
      calculator.calculate();
      calculator.teardown();
    }
  }
  ```

- 호출하는 쪽에 제약을 두는 것은, 그 제약 조건을 잊어버리고 위반하면 잘못 사용하는 것을 뜻한다.
- 따라서 Caller의 제약을 최소화하기 위해, 호출할 순서가 정해져 있는 함수들을 묶어서 은닉한다.

  ```js
  class Calculator {
    calculate() {
      prepare();
      // 실제 계산 로직
      teardown();
    }

    prepare() {...}
    teardown() {...}
  }

  class Caller {
    private readonly calculator = new Calculator();

    callCalculator() {
      calculator.calculate();
    }
  }
  ```
