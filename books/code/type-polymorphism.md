# 타입으로 견고하게 다형성으로 유연하게

- [책 링크](https://product.kyobobook.co.kr/detail/S000210397750)

## 타입 검사 흝어보기

### 타입 검사의 정의와 필요성

- **`타입 검사는 무엇이며 왜 필요할까?`** 타입검사는 불편하지만 불편을 감수하면서도 사용할 가치가 있다.
- 우선 버그에 대한 이야기를 해야 한다. 버그는 개발자에게 가장 큰 적이면서도 피할 수 없는 존재다.
- 버그의 가장 흔한 원인은 타입 오류다. 타입은 프로그램에 존재하는 값을 분류한 것이다.
- **`의도한 타입의 값이 아닌 다른 타입이 들어와 실행된다면 기능이 중단되고 오류 메시지를 출력한다`**.
- 타입 오류로 인한 버그를 프로그램 실행 중에 찾기보다 **`자동으로 타입 오류를 판단해주는 타입 검사기를 사용한다`**.
  - 타입 검사기는 어디서 타입 오류가 발생하는지 알려준다.
  - 코드를 보고 타입 오류가 있다면 코드를 고치면 된다.
  - 코드를 보고 타입 오류가 없다면 타입 검사기가 그 사실을 올바르게 알 수 있도록 코드를 살짝 바꾸면 된다.
- **`타입 검사는 프로그램에서 버그를 자동으로 찾아 준다는 가치를 지닌다`**.
  - 버그는 아주 많고 사람의 힘만으로 모든 버그를 찾기란 매우 어렵다.
- 그래서 사람들은 타입 검사기를 사용한다.

### 정적 타입 언어

- 여러 언어가 타입 검사기를 제공한다. 자바, C, C++, 타입 스크립트, Go, 코틀린 등이 그 예다.
- 이런 언어들은 **`정적 타입 언어라고 부른다`**. 정적의 의미는 프로그램을 **`실행하기 전에를 뜻한다`**.
  - 정적 타입 언어는 프로그램을 실행하기 전 타입이 올바르게 사용되었는지 확인하는 언어다.
  - 프로그램이 타입 검사를 통과하면 실행 중 타입 오류가 일어나지 않는다는 보장과 함께 실행된다.
- 한편 **`타입 검사기를 제공하지 않는 언어도 있다`**. 자바스크립트, 파이썬, 루비, 리스프가 대표적이다.
  - 프로그램이 그냥 실행될 수 있지만, 실행 중에 타입 오류가 발생할 수도 있다.
  - 이런 언어들을 **`동적 타입 언어라고 부른다`**. 동적은 프로그램 **`실행 중에를 뜻한다`**.
  - 타입이 잘못 사용되었어도 그 사실을 실행중에야 파악할 수 있는 언어인 것이다.

### 타입 검사의 원리

- 타입 검사기가 작동하는 원리는 현실 세계에서 자동차 검사 과정과 비슷한다.
  - 자동차를 검사할 때는 작은 부품에서 큰 부품으로 가면서 검사를 한다.
  - 타이어부터 두 타이어를 연결한 차축과 같은 방향으로 검사를 한다.
- **`PrintInt(5 + 7)`** 검사 방식을 살펴보자.
  - 우선 기본 부품인 `5,7`이 정수인지 살펴본다.
  - 큰 부품인 `PrintInt와 5 + 7`을 살펴본다.
  - 함수의 인자 타입과 인자로 전달되는 `5 + 7` 타입은 정수이므로 문제 없이 통과된다.
- 어떤 언어들은 정수와 문자열의 덧셈을 허용한다
  - 그런 언어에서는 `(5 + "7")`이 타입 검사를 통과한다.
  - 따라서 핵심은 덧셈에는 특정 타입을 요구하며 타입 검사 과정에서 덧셈을 하는 부품이 그 요구를 만족하는지 확인한다.

#### 함수

- 함수의 타입은 매개변수 타입과 결과 타입으로 구성된다.
- 타입 검사기는 함수를 호출하는 쪽에서 전달하는 인자가 매개 변수 타입과 일치하는지 확인한다.
- 함수의 경우 함수 몸통(body)도 검사 대상이다.
  - 몸통 내부에서 타입 오류를 발생시키는지, return 코드가 실제 반환 타입과 일치하는지 확인한다.
- 어떤 값도 반환하지 않는 함수(void)의 경우 return에 아무 값도 주어지지 않았는지 확인한다.

### 타입 검사 결과의 활용

- 여태 알아본 **`정적 타입 언어의 장점은 아래 두 가지이다`**.
  - 타입 오류를 모두 찾을 수 있다는 것
  - 타입 검사기의 오류 메시지로 코드를 올바르게 고치기 쉽다는 점이다.
  - 이 외에도 **`타입 검사로 얻을 수 있는 이점은 두 가지 더 있다`**.
- 코드 편집기
  - 타입 검사기는 프로그램 각 부품의 타입을 알아내 자동완성 기능을 정확히 추측할 수 있도록 돕는다.
  - 예를 들어 문자열에 `contains` 메서드가 있고 `collect` 메서드가 없다고 가정하자.
  - 개발자가 변수.co 까지 작성하면 변수가 String일 경우 `collect`는 바로 선택지에서 제외할 수 있다.
- 프로그램 성능
  - 같은 프로그램을 작성해도 정적 타입 언어의 경우 타입 검사 덕분에 실행 중에 할일을 줄일 수 있다.
  - 예를 들어 자바스크립트에서 변수의 자료형이 number가 아닌 경우를 처리하는 if문을 예로 들 수 있다.
  - **`언어의 성능을 최대한 높이고 싶다면 타입 검사기의 도움을 받아야 한다`**.
    - 성능을 중요한 목표로 두는 `C, C++, Rust`가 모두 정적 타입 언어인 것은 다 이유가 있다.

### 타입 추론

- 타입 표시를 매 번 붙이기 번거롭다면, 타입 검사기가 똑똑해서 타입 검사를 할 수 있는게 좋다.
- 실제로 여러 언어가 그런 기능을 제공하는데, 이를 **`타입 추론이라고 부른다`**.

#### 동적 언어에서 주석으로 타입을 작성할 경우

- 타입 표시가 귀찮기만 하고 안 좋은건 아니다. 코드에 더 많은 정보를 담아 가독성을 높일 수 있다.
  - `function readFile(file) {...}`
- 위 코드보다 아래 코드를 보면 파일명을 받아 내용을 리턴하는 함수란 걸 짐작해 볼 수 있다.
  - `String readFile(String file) {...}`
- 주석으로 정보를 제공하면 되지 않냐고 주장할 수 있다.
  - `// file의 타입: String, 결과 타입: String`
  - **`주석은 치명적인 단점이 있는데, 주석이 틀릴 수 있다는 점이다`**.
  - 프로그램은 지속적으로 수정되는데 주석을 깜빡하고 수정하지 않는다면, 그때부터 주석은 잘못된 정보를 제공하게 된다.
- 반대로 **`타입은 주석과 같이 정보 불 일치 단점이 없다`**.
  - `readFile` 내부에서 리턴 타입이 String이 아닌 Path 객체로 바꿨다고 가정하자.
  - 이 실수는 타입 검사 때문에 바로 들통난다. **`타입 표시는 절대 낡지 않는 주석인 셈이다`**.

#### 타입 추론은 양날의 검

- 하지만 타입이 길어지고 코드가 장황해지면 **`개발자들은 타입 선언을 꺼리게 된다`**.
  - **`그래서 중요한게 타입 추론이다`**. 개발자가 타입 표시를 생략해도 타입 검사기가 타입을 추론하는 것이다.
- 가장 간단한 형태의 타입 추론은 변수의 타입을 알아내는 것이다.
  - `var num = 1 + 2` 코드에서 타입 검사기는 num 변수가 정수형이라는 타입을 알 수 있다.
- 함수의 타입을 생략하면 변수의 경우와 달리 타입 추론이 쉽지 않다.
- 타입 추론의 좋은 점은 개발자가 타입 추론의 원리를 이해하지 않고도 타입 검사기가 생략된 타입을 알아내는 것이다.
  - 단 사용중인 언어가 어디까지 타입을 추론해 주는지는 알아야 한다.
  - 변수의 타입 표시만 생략할 수 있는 언어부터 함수의 타입 표시를 항상 생략할 수 있는 언어까지 타입 추론의 범위는 다양하다.
- **`정적 타입 언에에서 타입 표시는 양날의 검이다`**.
  - 타입 표시를 모두 붙이면 코드가 장황해지고, 타입 추론이 허용하는 범위에서 다 생략하는게 꼭 좋지만도 않다.
  - 타입 표시를 적당히 남겨두어 코드에 정보를 더 담는 편이 좋을 때도 있으니 적절히 활용하는 지혜가 필요하다.

### 더 세밀한 타입

- **`타입 검사기를 만든 목적은 버그를 찾는 것이다`**. 다른 혜택도 있지만 주 목표는 버그다.
- 문제는 타입 오류로는 0으로 나누기나 널 접근 오류 등을 찾을 수 없다는 점이다. 이 버그를 찾을 순 없을까?
- 놀랍게도 타입 검사가 해결책이 될 수 있다. 어떤 언어에서 타입이 정상인게 다른 언어에서는 타입 오류가 될 수 있다.
  - 자바에서는 널 접근이 타입 오류가 아니기에 실행 중에 널 접근 오류가 발생할 수 있다.
  - 반대로 코틀린에서는 널 접근이 타입 오류다. 코틀린이 값을 더 세밀하게 분류하기 때문이다.
- 그렇다면 **`무조건 값을 세밀하게 분류하는게 좋지 않을까?`** 생각할 수 있다.
  - 값을 세밀하게 분류하면 사용성이 불편해진다.
  - 널을 나타내는 특별한 타입이 필요하고, 널이 아닌지 확인하기 위해 여러 제약이 추가되게 된다.
- **`언어 설계자가 개발자의 자유에 가치를 둔다면`** 값을 대걍 분류하도록 타입 검사기를 만들 것이다.
- 반대로 **`언어 설계자가 더 많은 버그를 찾는데 가치를 둔다면`** 값을 더 세밀하게 분류하게 된다.

### 정적 타입 언어의 장단점

- **`정적 언어의 장점은 아래와 같다`**.
  - 프로그램의 모든 타입 오류를 찾을 수 있고, IDE가 타입 검사기 결과를 활용해 생산성을 높일 수 있다.
  - 불필요한 실행 중 검사 코드를 없앨 수 있고, 타입 표시를 적절히 한다면 가독성을 높일 수 있다.
- 정적 언어도 단점은 있다.
  - 타입 표시 때문에 코드가 장황해진다.
  - 분명히 타입 오류를 일으키지 않는 프로그램인데 타입 검사를 통과하지 못해 쓸데없이 코드를 고쳐야 한다.
- 정적 타입 언어는 큰 프로그램을 만들 때 유용하다.
  - 프로그램이 크면 버그가 많으니 모두 찾기 어렵다.
  - 타입 오류를 모두 자동으로 찾고, IDE 능력을 최대로 이끌어내고, 가독성이 좋은 정적 타입 언어가 최적이다.
- 반면 **`작은 프로그램을 만들 때는 정적 타입 언어의 장점이 크게 유용하지 않다`**.
  - 프로그램을 빨리 만들고 싶은데 타입을 붙이느라 시간을 소모하거나
  - 정상인데 타입 검사를 통과하지 못해 지체되는 상황이 발생한다.
- 두 종류의 언어의 장/단점을 잘 보여주는게 트위터의 사례다.
  - 트위터는 초반에 루비를 서버 개발에 사용해 빠르게 기능을 개발했다.
  - 시간이 지나면서 코드의 규모가 커지고, 버그가 늘어나면서 동적 타입 언어의 한계가 보이기 시작했다.
  - 이 시점에 트위터는 정적 타입 언어인 스칼라로 옮겨가면서 시간은 걸렸지만 옮긴 후, 정적 타입 언어의 혜택을 볼 수 있었다.
  - 루비를 사용하던 시절보다는 버그를 찾기 쉬워지고 가독성도 좋아졌다.

### 다형성

- 정적 타입 언어의 치명적인 단점 중 한가지. **`문제가 없는데 타입 검사기가 오류라고 판단하는 경우가 있다`**.
- 이 단점은 튜링이 증명했듯 완벽하게 해결할 순 없다. 다만 잘못 말하는 경우를 줄이는 방법이 있다.
  - **`첫 번째 방법은`** 타입 검사의 틀 안에서 개발자를 돕는 안전한 기능이다.
  - **`두 번째 방법은`** 타입 검사를 무력화하는 위험한 기능으로 타입 검사 원칙을 아예 파괴해 버린다.
    - 대표적으로 코틀린의 `!!` 연산자기 있다. 타입 검사기가 널을 String 타입으로 취급하도록 강제한다.
    - 이는 **`개발자가 타입 검사기에게 나를 믿고 그냥 통과시켜라고 말하는 것과 동일하다`**.
    - 개발자의 판단이 옳았다면 문제는 없겠지만 틀렸다면 실행 중에 오류가 발생하는 참사가 발생한다.
    - 그러므로 타입 검사가 제공하는 큰 **`이점을 스스로 포기하는 이런 행위는 하지 않는게 좋다`**.
- **`다형성은 타입 검사기의 오판을 줄이는 안전한 기능을 제공한다`**.
  - 다형성은 프로그램의 한 개체가 여러 타입에 속하게 만든다.
  - 다형성은 크게 **`서브타입에 의한 다형성, 매개변수에 의한 다형성, 오버로딩에 의한 다형성으로`** 나눌 수 있다.
