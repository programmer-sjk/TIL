# 클린 코드

- [책 링크](https://product.kyobobook.co.kr/detail/S000001032980)

## 깨끗한 코드

- 80년대 후반 어떤 앱이 출시되었으나 제품 출시 주기가 점점 길어지기 시작했다. 이전 버전에 있었던 버그가 현재 버전에도 그대로 있고 프로그램이 죽는 횟수도 늘어났다. 결국 회사는 얼마 못가 망했다. 20년이 지나 그 회사의 초창기 직원을 만나 들었는데 짐작한대고 출시에 바빠 코드를 마구 짜고 결국은 감당이 불가능한 수준에 이르렀다. **`회사가 망한 원인은 바로 나쁜 코드 탓이었다`**. 우리 모두는 자신이 짠 쓰레기 코드를 쳐다보며 나중에 손보겠다고 생각한 경험이 있다. 우린 르블랑의 법칙을 법칙을 몰랐다. **`나중은 결코 오지 않는다`**.
- 나쁜 코드는 개발 속도를 떨어뜨린다. 프로젝트 초반에는 번개처럼 나가다가 1-2년 만에 굼벵이처럼 기어가는 팀도 많다. 코드를 고칠때마다 엉뚱한 곳에 문제가 생기고 시간이 지나면서 쓰레기 더미는 점점 높아지고 깊어진다. 생산성이 떨어지면 관리층은 나름대로 복구를 시도하기 위해 새로운 인력을 투입한다. 하지만 새 인력은 시스템 설계에 대한 조예가 깊지 않다. **`새 인력은 생산성을 향상시켜야 한다는 압박으로 나쁜 코드를 더 많이 양산한다`**. 결과적으로 생산성은 더욱 떨어져 거의 0이 된다.
- **`코드는 왜 나쁜 코드가 되었을까?`** 우리는 온갖 이유를 들이댄다. 요구사항이 변했고 일정이 촉박해 제대로 할 시간이 없었다고 한탄한다. 멍청한 관리자와 조급한 고객 때문이라고 말하지만 잘못은 전적으로 프로그래머에게 있다. 관리자가 일정과 요구사항을 밀어붙이는 이유는 그것이 그들의 책임이기 때문이다. **`좋은 코드를 사수하는 일은 바로 프로그래머들의 책임이다`**. 나쁜 코드의 위험을 이해하지 못하는 관리자 말을 그대로 따르는 행동은 전문가답지 못하다.
- 진짜 전문가는 기한을 맞추려면 나쁜 코드를 생산해야 한다고 생각하지 않는다. 나쁜 코드를 양산하면 기한을 맞추지 못한다. **`기한을 맞추는 유일한 방법은 언제나 코드를 최대한 깨끗하게 유지하는 습관이다`**. 그렇다면 깨끗한 코드를 어떻게 작성할까?

### 깨끗한 코드란?

- 프로그래머 수 만큼 정의도 다양할 것이다. 저자는 유명하고 노련한 프로그래머들에게 깨끗한 코드에 대한 의견을 물었다.
- **`비야네 스트롭스트룹 (C++ 창시자)`**
  - 나는 우아하고 효율적인 코드를 좋아한다. 논리가 간단해야 버그가 숨어들지 못한다. 의존성을 최대한 줄여야 유지보수가 쉬워진다. 오류는 명백한 전략에 의거해 철저히 처리한다. 성능을 최적으로 유지해야 사람들이 코드를 망치려는 유혹에 빠지지 않는다. 깨끗한 코드는 한 가지를 제대로 한다.
  - 비야네에 따르면 깨끗한 코드는 보기에 즐거운 코드다. 또한 유혹이란 단어를 사용했는데, **`나쁜 코드는 나쁜 코드를 유혹한다. 마지막으로 깨끗한 코드란 한 가지를 잘 한다고 단언한다`**. 수 많은 SW 설계 원칙이 이 간단한 교훈으로 귀결된다는 사실은 우연이 아니다. 나쁜 코드는 너무 많은 일을 하려다 목적이 흐려지지만, 깨끗한 코드는 한 가지에만 집중한다.
- **`그래디 부치`**
  - 깨끗한 코드는 단순하고 직접적이다. 또한 잘 쓴 문장처럼 읽힌다. 깨끗한 코드는 설계자의 의도를 숨기지 않는다. 오히려 명쾌한 추상화와 단순한 제어문으로 가득하다.
- **`데이브 토마스`**
  - 깨끗한 코드는 작성자가 아닌 사람도 읽기 쉽고 고치기 쉽다. 테스트 케이스가 존재하며 의미있는 이름이 붙는다.
- **`마이클 페더스`**
  - 깨끗한 코드는 누군가 주의깊게 짰다는 느낌을 준다. 고치려고 살펴봐도 딱히 손 댈 곳이 없어 제자리로 돌아온다. 그리고는 누군가 남겨준 코드, 누군가 주의깊게 짜놓은 작품에 감사를 느낀다.
- **`론 제프리스`**
  - 모든 테스트를 통과하고, 중복이 없고, 시스템 내 모든 설계 아이디어를 표현하고, 클래스와 메서드 함수 등을 최대한 줄인다. 중복 줄이기, 표현력 높이기, 추상화 고려하기. 내게는 이 세가지가 깨끗한 코드를 만드는 비결이다.
- **`워드 커닝햄`**
  - 코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다. 코드가 그 문제를 풀기 위한 언어처럼 보인다면 아름다운 코드라 불러도 되겠다.

### 깨끗한 코드의 중요성

- 코드를 읽는 시간 vs 코드를 작성하는 시간 비율은 10대 1을 훌쩍 넘는다. 새 코드를 작성하며 우리는 기존 코드를 읽는다. 비율이 이렇게 높으므로 읽기 쉬운 코드가 매우 중요하다. 이 논리에서 빠져나갈 방법은 없다. 주변 코드를 읽기 쉬우면 새 코드를 짜기도 쉽다. 주변 코드를 읽기가 어려우면 새 코드를 짜기도 어렵다. **`급하고 서둘러서 끝내려면, 읽기 쉽게 만들면 된다`**.
- 잘 짠 코드가 전부는 아니다. 시간이 지나도 언제나 깨끗하게 유지해야 한다. 미국 보이스카우트가 따르는 간단한 규칙이 우리에게도 유용하다. 캠프장은 처음 왔을 때 보다 더 깨끗하게 해놓고 떠나라. **`한꺼번에 많은 시간과 노력을 투자해 코드를 정리할 필요는 없다`**. 변수 이름 하나를 개선하고 조금 긴 함수를 분할하고 약간의 중복을 제거하면 충분하다. 시간이 지날수록 코드가 좋아지는 프로젝트에서 작업한다니! 지속적인 개선이야 말로 전문가 정신의 본질이 아니던가?

## 의미 있는 이름

- 이름만 잘 지어도 여러모로 편하다. 이 장에서는 이름을 잘 짓는 간단한 규칙을 소개하도록 하겠다.

### 의도를 분명히 밝혀라

- 의도가 분명한 이름이 정말로 중요하다는 사실을 거듭 강조한다. 아래 코드에서 d는 아무 의미도 드러나지 않는다. 특정하려는 값과 단위를 표현하는 이름이 중요하다.

  ```java
  int d; // 경과 시간

  // 좋은 예시
  int elapsedTimeInDays;
  int daysSinceCreation;
  int daysSinceModification;
  int fileAgeInDays;
  ```

### 그릇된 정보를 피하라

- 여러 계정을 그룹으로 묶을 때 실제 List가 아니라면 `accountList`라고 명명하지 않는다. 프로그래머에게 List는 특수한 의미다. 실제 List가 아니라면 프로그래머에게 그릇된 정보를 제공하는 셈이니 `accountGroup, accounts`라 명명한다.
- 유사한 개념은 유사한 표기법을 사용한다. 이것도 정보다. 일관성이 떨어지는 표기법은 그릇된 정보다.

### 의미 있게 구분하라

- 아래 코드는 저자의 의도가 전혀 드러나지 않는다. 인수 이름으로 `source와 destination`을 사용하면 코드 읽기가 훨씬 쉬워진다.

  ```java
    public static void copyChars(char a1[], char a2[]) {
      for (int i = 0; i < a1.length; i++) {
        a2[i] = a1[i];
      }
    }
  ```

- 고객 급여 이력을 찾으려면 아래에서 어느 클래스를 뒤져야 할까?

  ```java
    getActiveAccount();
    getActiveAccounts();
    getActiveAccountInfo();
  ```

- 명확한 관례가 없다면 moneyAmount는 money와 구분이 안된다. customerInfo는 customer와 theMessage는 message와 구분이 안 된다. 읽는 사람이 차이를 알도록 이름을 지어라.

### 클래스 이름

- 클래스 이름은 명사나 명사구가 적합하다. `Customer, WikiPage, Account` 등이 좋은 예다. `Manager, Processor, Data, Info` 등과 같은 추상적인 단어는 피하고 동사는 사용하지 않는다.

### 메서드 이름

- 메서드 이름은 동사나 동사구가 적합하다. `postPayment, deletePage, save` 등이 좋은 예다.
- 생성자를 중복 정의할 때는 정적 팩토리 메서드를 사용한다. 메서드는 인수를 설명하는 이름을 사용한다.

  ```java
    Complex fulCrumPoint = Complex.FromRealNumber(23.0); // 이 코드가 아래 코드보다 좋다.
    Complex fulCrumPoint = new Complex(23.0);
  ```

- 생성자 사용을 제한하려면 해당 생성자를 private로 선언한다.

### 한 개념에 한 단어를 사용하라

- 클래스마다 메서드 이름에 `fetch, get, retrieve`로 제각각 부르면 혼란스럽다. 마찬가지로 동일한 코드 기반에 `controller, manager, driver`를 섞어 쓰면 혼란스럽다. `DeviceManager와 ProtocolController`는 근본적으로 어떻게 다른가? 왜 둘다 Controller가 아닌가?

### 불 필요한 맥락을 없애라

- 고급 휘발유 충전소(Gas Station Deluxe)라는 어플리케이션을 만든다고 가정하자. 모든 클래스 이름을 GSD로 시작하겠다는 생각은 전혀 바람직하지 못하다.
- **`일반적으로 짧은 이름이 긴 이름보다 좋다. 단, 의미가 분명한 경우에 한해서다`**. 이름에 불필요한 맥락을 추가하지 않도록 주의한다.
