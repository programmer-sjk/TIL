# 가상 면접 사례로 배우는 대규모 시스템 설계 기초 2

- [책 링크](https://product.kyobobook.co.kr/detail/S000211656186)

## 근접성 서비스

- 근접성 서비스는 현재 위치에서 가까운 시설을 찾는데 이용된다.

### 문제 이해 및 설계 범위 확정

```text
지원자: 사용자가 검색 반경을 지정할 수 있어야 하나요? 검색 반경내에 사업장이 충분치 않으면 시스템이 알아서 넓혀도 될까요?
면접관: 일단은 주어진 반경 내의 사업장을 대상으로 한다고 하시죠.

지원자: 최대 허용 반경은 얼마입니까? 20km로 가정해도 괜찮을까요?
면접관: 네 좋습니다.

지원자: 사용자가 UI에서 검색 반경을 변경할 수 있어야 하나요?
면접관: 네. 0.5km, 1km, 2km, 5km, 20km 내에서 선택할 수 있어야 합니다.

지원자: 사업장 정보는 어떻게 시스템에 추가되고, 삭제되고, 갱신됩니까? 사업장 정보가 사용자에게 실시간으로 보여져야 할까요?
면접관: 사업장 소유주가 사업장 정보를 시스템에 추가,삭제,갱신할 수 있어야 합니다. 추가되거나 갱신된 정보는 다음날까지 반영된다고 가정합시다.
```

- 위 대화에 근거하여 **`다음 세 가지 기능에 집중하자`**.
  - 사용자의 위치와 검색 반경 정보에 매칭되는 사업장 목록을 반환
  - 사업장 소유주가 사업장 정보를 추가,삭제,갱신할 수 있도록 하되 그 정보가 실시간으로 반영될 필요는 없다고 가정
  - 고객은 사업장의 상세 정보를 살필 수 있어야 함

### 개략적 설계안 제시 및 동의 구하기

- RESTFUL API 관례를 따르는 간단한 API를 만들어 보도록 하겠다.
  - **`GET /v1/search/nearby`**
- 이 API는 특정 검색 기준에 맞는 사업장 목록을 반환한다. 실제로 사용되는 어플리케이션의 경우 페이지 단위로 반환하겠지만 여기서는 신경쓰지 않겠다. API 호출 시에 전달할 인자는 다음과 같다.
  - `latitude` (위도), `longitude` (경도), `radius` (선택적 인자로 기본값은 5000m)
- 반환되는 결과는 다음과 같은 형태를 띤다.
  - `{ total: 10, businesses: [{ business object }]}`
  - business object는 각 사업장을 표현하는 객체로 페이지에 표시될 모든 정보를 포함한다.
- 아래는 사업장 객체 관련 API이다.
  - `GET /v1/businesses/:id` 특정 사업자의 상세 정보 반환
  - `POST /v1/businesses/:id` 새로운 사업자 추가
  - `PUT /v1/businesses/:id` 사업장 상세 정보 갱신
  - `DELETE /v1/businesses/:id` 특정 사업장 정보 삭제

#### 데이터 모델

- 주변 사업장 검색, 사업장 정보 확인. **`이 두 가지 용도로 읽기 연산은 굉장히 자주 수행된다`**.
- 한편 쓰기 연산 빈도는 낮은데, 사업장 정보를 추가하거나 삭제, 편집하는 행위는 빈번하지 않기 때문이다.
- **`읽기 연산이 압도적인 시스템에서는 MySQL 같은 관계형 데이터베이스가 바람직할 수 있다`**.
- 시스템의 핵심이 되는 테이블은 business와 지리적 위치 색인 테이블이다.

  - **`지리적 위치 색인 테이블은`** 위치 정보 연산의 효율성을 높이는데 쓰인다. 지오해시(geohash) 지식이 필요하므로 뒤에서 논의한다.

  <img src="https://github.com/programmer-sjk/TIL/blob/main/images/books/architecture/system-design2/proximity.png" width="500">

- 위 그림에서 **`LBS는 위치 기반 서비스이다`**. 주어진 위치와 반경 정보를 가지고 주변 사업장을 검색한다.
  - 쓰기 요청이 적고 읽기 요청이 빈번하게 발생하는 서비스이다.
  - QPS가 높다. 특히 특정 시간대의 인구 밀집 지역일수록 그 경향이 심하다.
  - 무상태 서비스이므로 수평적 규모 확장이 쉽다.

#### 주변 사업장 검색 알고리즘

- 실제로 많은 회사가 **`Redis의 지오해시나 PostGIS 확장을 설치한 Postgres 데이터베이스를 활용한다`**.
- 지리적 정보 색인을 만드는 방법에는 여러 알고리즘이 있지만 **`지오해시나 쿼드트리가 많이 쓰이고 있다`**.
- 이 둘을 가볍게 비교해보자.
  - 지오해시
    - 구현과 사용이 쉽고 트리를 새로 구축할 필요가 없다.
    - 지정 반경 이내 사업장 검색을 지원한다.
    - 인구 밀도에 따라 동적으로 격자 크기를 조정할 수는 없다.
    - 색인 갱신이 쉽다. 색인에서 사업장 하나를 삭제하려면 지오해시 값과 사업장 식별자가 같은 열 하나를 제거하기만 하면 된다.
  - 쿼드 트리
    - 트리를 구축해야 해서 구현하기가 살짝 더 까다롭다.
    - 가장 근거리의 k개의 무언가를 찾기 쉽다.
    - 인구 밀도에 따라 동적으로 격자 크기를 조정할 수 있다.
    - 지오해시보다 색인 갱신은 까다롭다.

### 상세 설계

- 지오해시나 쿼드트리 둘 다 널리 사용되지만 **`본 설계에서는 좀 더 단순한 지오해시를 사용하도록 하겠다`**.
- 지오해시 테이블 구성 방법은 두 가지이다.
  - 각각의 지오해시에 연결되는 모든 사업장 ID를 JSON 배열로 만들어 같은 열에 저장하는 방안이다.
  - 지오해시에 해당하는 사업장 ID를 각각 별도의 열로 저장하는 방법이다. 따라서 같은 지오해시에 해당하는 여러 열이 존재한다.
- 위 방법 중 두번째 방법을 추천한다.
  - 방안 1의 경우, 사업자 정보를 갱신하려면 JSON 배열을 읽고 사업장 ID를 찾아내야 한다. 새 사업장을 등록해야 하는 경우에도 이미 데이터가 있는지 전부 살펴봐야 한다.

#### 지리 정보 색인의 규모 확장

- **`지리 정보 색인의 규모를 확장할 때 성급하게 샤딩 방법을 결정하는 실수를 저지르곤 한다`**. 하지만 현재 보고 있는 설계안의 경우 필요한 전체 데이터 양은 많지 않다. 색인 전부를 최신 DB 서버 한 대에 수용할 수 있다. 하지만 읽기 연산의 빈도가 높다면 서버 한대의 CPU와 네트워크 대역폭으로는 감당하지 못할 수도 있다. 그런 상황에선 여러 DB 서버로 부하를 분산해야 한다.
- **`관계형 DB의 부하분산에는 두 가지 방법이 있다`**. 하나는 읽기 연산을 지원할 사본 DB를 늘리는 방법이고 다른 하나는 샤딩을 적용하는 것이다. 지오해시 테이블은 샤딩이 까다로우므로 샤딩을 강제할 필요는 없다. 따라서 이번 설계에서는 읽기 부하를 나눌 방법으로 읽기 DB를 두는 방법을 택하겠다.

#### 캐시

- 캐시 도입 전에 이런 질문을 던져야 한다. **`정말 필요한가?`** 정말 좋은 결과로 이어지리라는 결론을 내리기는 어려울 것이다.
- 대부분 읽기 중심이고 DB 데이터 크기가 작아서 모든 데이터는 한 대의 DB 서버에 수용가능하다. 이런 경우 DB 버퍼 풀에 의해 캐시되어 I/O 부하가 크게 좌우되지 않는다.
- 만약 캐시를 사용하기로 했다면 **`가장 직관적인 캐시 키는 사용자의 위도와 경도 정보다`**. 하지만 사용자가 이동하면 위도와 경도 정보가 미세하게 변한다. 위치가 조금 달라지더라도 변화가 없어야 이상적이다. 지오해시나 쿼드트리는 이 문제를 효과적으로 해결한다. 같은 격자 내 모든 사업장이 같은 해시 값을 갖도록 만들 수 있기 때문이다.

## 주변 친구

- 앞서 살펴본 근접성 서비스와 비슷해 보이지만 두 기능 사이에는 큰 차이가 있다.
- **`근접성 서비스의 경우 사업장 주소는 정적이지만 주변 친구 위치는 자주 바뀔 수 있기 때문이다`**.

### 문제 이해 및 설계 범위 확정

```text
지원자: 지리적으로 얼마나 가까워야 주변에 있다고 할 수 있나요?
면접관: 5마일입니다. 이 수치는 설정 가능해야 합니다.

지원자: 그 거리는 두 사용자 사이의 직선거리라고 가정해도 될까요?
면접관: 네 좋습니다.

지원자: 얼마나 많은 사용자가 이 앱을 사용하나요? 10억명을 가정하고 그 중 10% 정도가 이 기능을 활용한다고 생각해도 될까요?
면접관: 네 좋습니다.

지원자: 사용자의 이동 이력을 보관해야 하나요?
면접관: 네. 이동 이력은 기계 학습 등 다양한 용도로 사용될 수 있으니까요

지원자: 친구가 10분 이상 비활성 상태면 해당 사용자를 주변 친구 목록에서 사라지도록 하게 할까요? 아니면 마지막 위치를 표시해야 할까요?
면접관: 사라지게 합시다.
```

- 기능 요구사항
  - 사용자는 앱에서 주변 친구를 확인할 수 있어야 한다. 주변 친구에 보이는 해당 친구까지 거리, 해당 정보가 갱신된 시간이 함께 표시되어야 한다.
  - 친구 목록은 몇 초마다 한번씩 갱신되어야 한다.

### 개략적 설계안 제시 및 동의 구하기

- 먼저 떠오르는 방법은 공용 백엔드를 사용하는 것이다.

  <img src="https://github.com/programmer-sjk/TIL/blob/main/images/books/architecture/system-design2/find-friend-common-backend.png" width="500">

- 이 **`백엔드는 어떤 역할을 해야 할까`**?
  - 모든 활성 상태 사용자의 위치 변화 내역을 수신한다.
  - 사용자 위치 변경 내역을 수신할 때마다 해당 사용자의 모든 친구를 찾아서 그 친구들의 단말로 변경 내역을 전달한다.
  - 두 사용자 사이의 거리가 특정 임계치보다 먼 경우에는 변경 내역을 전송하지 않는다.
- 단순하고 명쾌한 설명 같지만, 큰 규모에 적용하기 쉽지 않다는 문제가 있다. 문제의 가정은 동시 접속 사용자가 천만명 정도라는 것이다. 위치 정보를 30초마다 갱신한다고 하면 초당 334,000번의 위치 정보 갱신을 처리해야 한다.
- 우선은 소규모 백엔드를 위한 개략적 설계안부터 만들어보자.

  <img src="https://github.com/programmer-sjk/TIL/blob/main/images/books/architecture/system-design2/find-friend-basic.png" width="500">

- **`친구 위치 정보 변경은 거의 실시간에 가깝게 처리하는 서버 클러스터이다`**. 각 클라이언트는 웹 소켓 서버와 지속적으로 연결을 유지한다. 검색 반경 내 친구 위치가 변경되면 웹소켓 연결을 통해 클라이언트로 전송된다. 웹소켓 서버는 클라이언트 앱이 처음 실행되면 온라인 상태인 모든 친구 위치를 해당 클라이언트로 전송하는 역할도 한다. 그 절차는 나중에 상세히 보자.
- **`레디스 pub/sub은 초경량 메시지 버스다`**. 레디스 pub/sub에 **`새로운 채널을 생성하는 것은 아주 값싼 연산이다`**. 기가바이트급 메모리를 갖춘 최신 레디스 서버에는 수백만개의 채널을 생성할 수 있다.

  <img src="https://github.com/programmer-sjk/TIL/blob/main/images/books/architecture/system-design2/find-friend-pub-sub.png" width="500">

- 웹소켓 서버를 통해 수신한 특정 사용자의 위치 정보 변경 이벤트는 사용자에게 배정된 pub/sub 채널에 발행한다. 해당 사용자의 친구 각각과 연결된 웹소켓 연결 핸들러는 해당 채널의 구독자로 설정되어 있다. 따라서 특정 사용자의 위치가 바뀌면 사용자의 모든 친구의 웹소켓 연결 핸들러가 호출된다. 각 핸들러는 위치 변경 이벤트를 수신할 친구가 활성 상태면 거리를 다시 계산해서 검색 반경 이내면 갱신된 위치와 갱신 시간을 웹소켓 연결을 통해 해당 친구의 클라이언트 앱으로 보낸다.
- 모바일 클라이언트가 위치 변경 내역을 전송할 때 절차를 살펴보자.
  - 모바일 클라이언트가 변경된 위치를 로드밸런서에 전송한다.
  - 로드 밸런서는 위치 변경 내역을 클라이언트와 연결된 웹소켓 서버로 보낸다.
  - 웹소켓 서버는 해당 이벤트를 위치 이동 이력 DB에 저장한다.
  - 웹소켓 서버는 새 위치를 위치 정보 캐시에 보관하며 TTL도 새롭게 갱신한다.
  - 웹소켓 서버는 레디스 pub/sub 서버의 해당 사용자의 채널에 새 위치를 발행한다.
  - 레디스 pub/sub에 발생된 이벤트는 모든 구독자에게 broadcase로 전달된다. 결과적으로 각 구독자의 웹소켓 연결 핸들러는 이벤트를 수신한다.
  - 웹소켓 연결 핸들러는 새위치를 기반으로 사용자와 메시지를 받은 사용자 사이의 거리를 계산해서 검색 반경을 넘지 않는다면 구독자의 클라이언트 앱으로 전송한다. 검색 반경을 넘었다면 보내지 않는다.

#### 데이터 모델

- 살펴 봐야 할 주제로 **`데이터 모델이`** 있다. 위치 정보 캐시와 위치 이동 이력 DB를 살펴보자.
- 위치 정보 캐시
  - 본 설계안에서는 **`DB 대신 레디스를 사용해 이 캐시를 구현한다`**.
  - 주변 친구 기능은 사용자의 현재 위치만을 이용하기에 하나만 보관하면 충분하다.
  - 레디스는 읽기/쓰기 연산 속도가 엄청 빠르기 때문에 이런 목적에 아주 적합하다.
  - TTL을 지원하므로 친구가 활성 상태가 아닌 경우에는 사용자 정보를 자동으로 제거할 수도 있다.
  - 주변 친구 기능에서 제공되는 위치 정보는 영속성을 보장할 필요가 없다는 사실을 유의하자.
- 위치 이동 이력 데이터 베이스
  - **`우리가 필요로 하는 것은 막대한 쓰기 연산 부하를 감당할 수 있고, 수평적 규모 확장이 가능한 데이터베이스다`**.
  - 카산드라는 그런 요구에 잘 부합한다.
  - RDB도 사용할 수 있으나 이력 데이터 양이 너무 많을 수 있어 샤딩이 필요하다.
  - **`사용자 ID를 기준 삼는 샤딩 방안이 가장 기본이다`**. 부하를 모든 샤드에 고르게 분산시킬 수 있고, DB 운영 관리도 간편하다.

### 상세 설계

- **`웹 소켓 서버`**
  - 웹소켓 클러스터도 사용률에 따라 규모를 자동으로 늘리는 것은 그다지 어렵지 않다.
- **`클라이언트 초기화`**
  - 모바일 클라이언트는 기동되면 웹소켓 클러스터 내의 서버 가운데 하나와 지속성 연결을 맺는다.
  - 웹소켓 연결이 초기화되면 클라이언트는 해당 모바일 단말의 위치, 즉 사용자의 위치 정보를 전송한다.
  - 그 정보를 받은 웹소켓 연결 핸들러는 다음 작업을 수행한다.
    - 위치 정보 캐시에 사용자 위치를 갱신한다.
    - 사용자 DB를 조회해 모든 친구 정보를 가져온다.
    - 위치 정보 캐시에 모든 친구의 위치를 한번에 가져온다.
    - 캐시가 돌려준 친구 위치 각각에 대해 웹소켓 서버는 해당 친구와 사용자 사이의 거리를 계산한다. 거리가 검색 반경 이내이면 친구의 위치를 웹소켓 연결을 통해 클라이언트에 반환한다.
    - 웹소켓 서버는 더불어 각 친구의 레디스 pub/sub 채널을 구독한다.
    - 사용자의 현재 위치를 레디스 pub/sub 채널을 통해 모든 친구에게 전송한다.
- **`사용자 데이터베이스`**
  - 사용자 상세 정보 데이터, 친구 관계 데이터 두 종류의 데이터가 보관된다.
  - 설계의 규모를 감안하면 한 대의 RDB 서버로는 감당할 수 없다. 하지만 사용자 ID를 기준으로 샤딩하면 관계형 DB라해도 수평적 규모 확장이 가능하다. 관계형 DB 샤딩은 널리 사용되는 기술이다.
- **`위치 정보 캐시`**
  - 위치 정보를 캐시하기 위해 레디스를 사용하였다. 시스템이 가장 붐빌때 천만 명의 사용자가 활성화되어 있고, 위치 정보 보관에 100 바이트가 필요하다고 가정하면 수 GB 이상의 메모리를 갖춘 레디스 한 대로 모든 위치를 캐시할 수 있다.
  - 하지만 천만 명의 활성 사용자가 대략 30초마다 변경된 위치 정보를 전송한다고 가정하면 레디스 서버는 초당 334K에 요청이 오는데 고사양 서버를 쓴다 해도 살짝 부담되는 수치이다. 다행스럽게 캐시할 데이터는 쉽게 샤딩할 수 있다. 각 사용자의 위치 정보는 서로 독립적인 데이터이므로 사용자 ID를 기준으로 여러 서버에 샤딩하면 부하를 고르게 분배할 수 있다.
- **`레디스 pub/sub 서버`**
  - 모든 온라인 친구에게 보내는 위치 변경 내역 메시지의 라우팅 계층으로 레디스 pub/sub 서버를 사용한다.
  - 선택한 이유는 pub/sub 채널을 만드는 비용이 아주 저렴하기 때문이다.
  - 채널 하나를 유지하기 위해서는 구독자 관계를 추적하기 위한 해시 테이블과 연결 리스트가 필요한데, 아주 소량의 메모리만을 사용한다.
  - 주변 친구 기능을 사용하는 모든 사람들에게 채널을 하나씩 할당하면, 10억 사용자의 10%가 친구 기능을 쓴다고 가정하고 1억개라고 추정된다. 한 사람의 친구 중 100명이 주변 친구 기능을 사용한다고 가정하고, 구독자 한 명을 추적하기 위해 내부 해시 테이블과 연결 리스트에 20바이트를 저장한다고 가정하자. 모든 채널을 저장하는데는 200GB의 메모리가 필요하니, 100GB 최신 레디스 pub/sub 서버 두 대면 될 것이다.
- **`분산 레디스 pub/sub 서버 클러스터`**
  - pub/sub 서버가 구독자에게 전송해야 하는 데이터는 초당 1400만 건에 달하기에 한 대의 서버로 감당할 수 없다.
  - 수백 대의 레디스 서버에 채널을 분산할 방법은 무엇일까? 다행인점은 모든 채널을 독립적이라는 사실이다. 그러니 메시지를 발행할 사용자 ID르 기준으로 pub/sub 서버들을 샤딩하면 된다. 하지만 현실적으로 수백대의 서버와 관련된 문제이므로 서비스 탐색 컴포넌트를 도입해 이 문제를 푼다. 가장 널리 알려진 주키퍼 등이 사용된다.

### 마무리

- 이 설계안의 **`핵심 컴포넌트는 다음과 같다`**.
  - 웹소켓: 클라이언트와 서버 사이의 실시간 통신을 지원한다.
  - 레디스: 위치 데이터의 빠른 읽기/쓰기를 지원한다.
  - 레디스 pub/sub: 한 사용자의 위치 정보 변경 내역을 모든 온라인 친구에게 전달하는 라우팅 계층이다.

## 분산 메시지 큐

- **`메시지 큐를 사용하면 어떤 이점을 얻을 수 있을까?`**
  - 결합도 완화: 메시지 큐를 사용하면 컴포넌트 사이의 강한 결합이 사라지므로 각각을 독립적으로 갱신할 수 있다.
  - 규모 확장성 개선: 생산자와 소비자 시스템 규모를 트래픽 부하에 맞게 독립적으로 늘릴 수 있다. 트래픽이 많이 몰리는 시간에 소비자를 추가하여 처리 용량을 늘린다.
  - 가용성 개선: 시스템의 특정 컴포넌트에 장애가 발생해도 다른 컴포넌트는 큐와 상호작용을 이어나갈 수 있다.
  - 성능 개선: 메시지 큐를 사용하면 비동기 통신이 쉽게 가능하다. 생산자는 응답을 기다리지 않고 메시지르 보낼 수 있고 소비자는 읽을 메시지가 있는 경우에만 메시지르 소비하면 된다.
- 메시지 큐 대 이벤트 스트리밍 플랫폼
  - 엄밀하게 말하면 카프카는 메시지 큐가 아니라 이벤트 스트리밍 플랫폼이다.
  - 하지만 지원하는 기능이 서로 닮아가면서 점차 구분이 희미해지고 있다.
- 이번 장에서는 데이터 장기 보관, 메시지 반복 서비스 등의 부가 기능을 갖춘 분산 메시지 큐를 설계해 볼 것이다.

### 문제 이해 및 설계 범위 확정

```text
지원자: 메시지의 형태와 평균 크기를 알려주실 수 있나요?
면접관: 텍스트 형태 메시지만 지원하면 되고, 메시지 크기는 수 킬로바이트 수준이라고 보면 됩니다.

지원자: 메시지는 반복적으로 소비할 수 있어야 하나요?
면접관: 네 하나의 메시지를 여러 소비자가 수신하는 것이 가능해야 합니다.

지원자: 메시지는 큐에 전달된 순서대로 소비되어야 하나요?
면접관: 생산된 순서 그대로 소비되어야 합니다.

지원자: 데이터의 지속성은 얼마 동안 보장되어야 하나요?
면접관: 2주라고 가정합시다.

지원자: 어떤 메시지 전달 방식을 지원해야 하나요? 최대 한 번, 최소 한 번, 정확히 한 번 중에서요.
면접관: 최소 한번 방식은 반드시 지원해야 합니다.
```

- 기능 요구사항
  - 생산자는 메시지 큐에 메시지를 보낼 수 있고 소비자는 메시지 큐를 통해 메시지를 수신할 수 있다.
  - 메시지는 반복적으로 수신할 수 있어야 하고, 단 한번만 수신하도록 설정될 수도 있어야 한다.
  - 오래된 이력 데이터는 삭제될 수 있다.
  - 메시지 크기는 수 킬로바이트 수준이다.
  - 메시지가 생산된 순서대로 소비자에게 전달할 수 있어야 한다.

### 개략적 설계안 제시 및 동의 구하기

- 가장 널리 쓰이는 메시지 모델은 **`일대일과 발행-구독 모델이다`**.
  - 일대일 모델은 큐를 소비하는 소비자가 많아도 전송된 메시지를 오직 한 소비자만 가져갈 수 있다.
  - 일대일 모델은 데이터 보관을 지원하지 않기 때문에 본 설계에서는 발행-구독 모델이 좀 더 적합하다.
  - 발행 구독 모델은 토픽이라는 새로운 개념을 도입해야 한다. 토픽은 메시지를 주제별로 정리하는데 사용되며 메시지를 보내고 받을 때는 토픽에 보내고 받게 된다. 이 모델에서 토픽에 전달된 메시지는 해당 토픽을 구독하는 모든 소비가에게 전달된다.
- **`토픽에 보관되는 데이터의 양이 서버 한 대로 감당하기 힘들어지면 어떻게 될까?`**
  - 이 문제를 해결하는 한 가지 방법은 파티션, 즉 샤딩 기법을 활용하는 것이다.
  - 토픽을 여러 파티션으로 분할한 다음 메시지를 모든 파티션에 균등하게 나눠 보낸다.
  - 파티션은 메시지 큐 클러스터 내의 서버에 고르게 분산 배치되며, 파티션을 유지하는 서버를 브로커라고 부른다.
  - 파티션을 브로커에 분산하는 것이 높은 규모 확장서을 달성하는 비결이다. 토픽의 용량을 확장하고 싶으면 파티션 개수를 늘리면 되기 때문이다.
  - 각 파티션은 FIFO 큐처럼 동작해, 같은 파티션 안에서는 순서가 보장된다.
  - 토픽을 구독하는 소비자가 여럿인 경우, 이 소비자들을 소비자 그룹이라고 부른다. 같은 그룹 내의 소비자들은 메시지를 병렬로 소비할 수 있다.
- 한가지 문제는 **`데이터를 병렬로 읽으면 처리량은 좋아지지만 파티션 안에 있는 메시지를 순서대로 소비할 수 없다`**.
  - 어떤 파티션의 메시지는 오직 한 소비자만 읽을수 있도록 하면 문제를 해결할 수 있다.
  - 모든 소비자를 같은 소비자 그룹에 두면 같은 파티션의 메시지는 오직 한 소비자만 가져갈 수 있으므로 일대일 모델을 수렴하게 된다.
  - 파티션은 가장 작은 저장 단위로, 미리 충분한 파티션을 할당해두면 파티션의 수를 동적으로 늘리는 일은 피할 수 있다. 처리 용량을 늘리려면 소비자를 더 추가하면 된다.

### 상세 설계

- **`데이터의 장기 보관 요구사항을 만족하면서 높은 대역폭을 제공하기 위해 아래 세 가지 결정을 내렸다`**.
  - 회전 디스크: 높은 순차 탐색 성능과 현대 OS가 제공하는 적극적 디스크 캐시 전략을 이용한다.
  - 메시지가 소비자에게 전달되기 까지 아무 수정 없이 전송이 가능하도록 설계한다. 전송 데이터 양이 큰 경우 복사에 드는 비용을 최소화한다.
  - 일괄처리: 소규모 I/O가 많으면 높은 대역폭을 처리하기 어렵다. 생산자는 메시지를 일괄 전송하고 소비자도 가능하면 메시지를 일괄 수신하도록 한다.

#### 데이터 저장소

- **`메시지 큐의 트래픽 패턴을 살펴보자`**.
  - 읽기와 쓰기 빈번히 발생한다.
  - 갱신, 삭제 연산을 발생하지 않는다.
  - 순차적인 읽기/쓰기가 대부분이다.
- 첫 번째 선택지는 데이터베이스이다.
  - RDB를 사용한다면 토픽별로 테이블을 만든다. 토픽에 보내는 메시지는 테이블에 새로운 레코드에 추가한다.
  - NoSQL을 사용한다면 토픽별로 컬렉션을 만든다. 토픽에 보내지는 메시지는 하나의 문서가 된다.
  - DB라면 데이터 저장 요구사항은 맞출 수 있지만 읽기 연산과 쓰기 연산이 빈번하게 발생하는 DB를 설계하긴 어렵다.
- 두 번째 선택지는 쓰기 우선 로그 WAL(Write Ahead Log) 이다.
  - WAL은 새로운 항목이 추가되기만 하는 일반 파일이다.
  - WAL은 다양한 시스템에서 사용되는 기술인데 MySQL의 redo log가 WAL로 구현되어 있고 아파치 주키퍼도 해당 기술을 활용한다.
  - 지속성을 보장해야 하는 메시지는 디스크에 WAL로 보관할 것을 추천한다. WAL에 대한 접근 패턴은 읽기/쓰기 모두 순차적으로 접근 패턴이 순차적일 때 디스크는 아주 좋은 성능을 보인다.
- 회전식 디스크가 느려지는 것은 데이터 접근 패턴이 무작위일 때다. 순차적 접근 패턴을 활용하면 수백 MB/sec 성능을 달성하는게 어렵지 않다. 비용 구조도 이쪽이 더 만족스럽다.

#### 메시지 자료 구조

- 메시지 구조는 높은 대역폭 달성의 열쇠다. 설계에서 메시지가 전달되는 과정에서 불필요한 복사가 일어나지 않도록 함으로써 높은 대역폭을 달성할 것이다. 아래는 메시지 자료 구조의 스키마 사례다.

  ```
    필드 이름 | 데이터 자료형
    ------------------------
    key        byte[]
    value      byte[]
    topic      string
    partition  integer
    offset     long
    timestamp  long
    size       integer
    crc        integer
  ```

#### 일괄 처리

- 일괄 처리는 아래의 이유로 시스템 성능에 매우 중요하다.
  - OS로 하여금 여러 메시지를 한 번의 네트워크 요청으로 전송하기에 비싼 네트워크 왕복 비용을 제거할 수 있다.
  - 브로커가 여러 메시지를 한 번에 로그에 기록하면 더 큰 규모의 순차 쓰기 연산이 발생하고 OS가 관리하는 디스크 캐시에서 더 큰 규모의 연속된 공간을 점유하게 된다. 결과적으로 더 높은 디스크 접근 대역폭을 달성할 수 있다.
- 얼마나 많은 메시지를 일괄 처리하는 것이 좋을까? 이에 대한 답은 결국 대역폭과 응답 지연 사이에서 타협점을 찾는 문제다. 일괄 처리할 메시지의 양을 늘리면 대역폭을 늘어나지만 응답속도는 느려진다. 일괄 처리가 가능할 양의 메시지가 쌓이길 기다려야 하기 때문이다. 양을 줄이면 메시지는 더 빨리 보낼 수 있으니 지연은 줄어들지만 대역폭은 손해를 본다.

#### 푸시 VS 풀

- 한 가지 중요하게 봐야 할 것은 브로커가 데이터를 소비자에게 보낼 것이냐 아니면 소비자가 브로커에게서 가져갈 것이냐 하는 부분이다.
- 푸시 모델의 장점은 브로커는 메시지를 받는 즉시 소비자에게 보내는 점이다. 단점은 소비자가 메시지를 처리하는 속도가 느릴 경우 소비자에게 부하가 걸릴 가능성이 있다. 또한 생산자가 데이터 전송 속도를 좌우하므로 소비자는 처리가 가능한 컴퓨팅 자원을 준비해 두어야 한다.
- 풀 모델의 장점은 소비하는 속도를 소비자가 알아서 결정한다. 또 소비하는 속도가 느리다면 소비자를 늘려 해결할 수도 있고 생산 속도를 따라잡을 때까지 기다릴 수 있다. 단점은 브로커에 메시지가 없어도 소비자는 계속 통신하기에 컴퓨팅 자원이 낭비된다. 이 문제를 보완하기 위해 많은 메시지 큐가 롱 폴링을 지원한다. 당장 가져갈 메시지가 없어도 일정 시간 기다리는 것이다.
- 대부분의 메시지 큐는 푸시 모델 대신 풀 모델을 지원한다.

#### 소비자 재조정

- 소비자 재조정은 어떤 소비자가 어떤 파티션을 책임지는지 다시 정하는 프로세스다.
- 새로운 소비자가 합류하거나 기존 소비자가 그룹을 떠나거나, 어떤 소비자에 장애가 발생하거나 파티션이 조정되는 경우 발생한다.
- 이 절차에 코디네이터가 중요한 역할을 한다. 코디네이터는 소비자 재조정을 위해 소비자들과 통신하는 브로커 노드다. 코디네이터는 소비자로부터 오는 하트비트 메시지를 살피고 각 소비자의 파티션 내 오프셋 정보를 관리한다.

#### 상태 저장소

- 메시지 큐 브로커의 상태 저장소에는 아래 정보들이 저장된다.
  - 소비자에 대한 파티션의 배치 관계
  - 각 소비자 그룹이 각 파티션에서 마지막으로 가져간 메시지의 오프셋
- 소비자 상태 정보 데이터가 이용되는 패턴은 다음과 같다.
  - 읽기와 쓰기가 빈번하게 발생하지만 양은 많지 않다.
  - 데이터 갱신은 빈번하게 일어나지만 삭제되는 일은 거의 없다.
  - 읽기와 쓰기 연산은 무작위적 패턴을 보인다.
  - 데이터의 일관성이 중요하다.
- 데이터의 일관성 및 높은 읽기/쓰기 속도에 대한 요구사항을 고려할 때 주키퍼 같은 키-값 저장소를 사용하는 것이 바람직하다.
- 주키퍼는 계층적 키-값 저장소 기능을 제공하는 분산 시스템에 필수적인 서비스이다.

#### 복제

- 분산 시스템에서 하드웨어 장애는 흔한 일이므로 무시해서는 안 된다. 이런 문제를 해결하기 위해 사용하는 방법은 복제다.
- 생산자는 파티션에 메시지를 보낼 때 리더 파티션에게만 보내고 다른 사본은 리더로부터 새 메시지를 지속적으로 가져와 동기화 한다.
- 풀어야 할 마지막 문제는 리더와 복제간 그 모두들 어떻게 동기화 시킬것 인가 하는 점이다. 동기화 된 사본(ISR)은 리더와 동기화 된 사본을 의미한다. 이때 동기화되었다는 것은 토픽의 설정에 따라 달라진다. ISR이 필요한 이유는 무엇인가? ISR은 성능과 영속성 사이의 타협점이다. 이때 ACK 설정에 따라 영속성과 성능 사이의 타협점을 결정한다.
