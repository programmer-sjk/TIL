# 가상 면접 사례로 배우는 대규모 시스템 설계 기초 2

- [책 링크](https://product.kyobobook.co.kr/detail/S000211656186)

## 근접성 서비스

- 근접성 서비스는 현재 위치에서 가까운 시설을 찾는데 이용된다.

### 문제 이해 및 설계 범위 확정

```text
지원자: 사용자가 검색 반경을 지정할 수 있어야 하나요? 검색 반경내에 사업장이 충분치 않으면 시스템이 알아서 넓혀도 될까요?
면접관: 일단은 주어진 반경 내의 사업장을 대상으로 한다고 하시죠.

지원자: 최대 허용 반경은 얼마입니까? 20km로 가정해도 괜찮을까요?
면접관: 네 좋습니다.

지원자: 사용자가 UI에서 검색 반경을 변경할 수 있어야 하나요?
면접관: 네. 0.5km, 1km, 2km, 5km, 20km 내에서 선택할 수 있어야 합니다.

지원자: 사업장 정보는 어떻게 시스템에 추가되고, 삭제되고, 갱신됩니까? 사업장 정보가 사용자에게 실시간으로 보여져야 할까요?
면접관: 사업장 소유주가 사업장 정보를 시스템에 추가,삭제,갱신할 수 있어야 합니다. 추가되거나 갱신된 정보는 다음날까지 반영된다고 가정합시다.
```

- 위 대화에 근거하여 **`다음 세 가지 기능에 집중하자`**.
  - 사용자의 위치와 검색 반경 정보에 매칭되는 사업장 목록을 반환
  - 사업장 소유주가 사업장 정보를 추가,삭제,갱신할 수 있도록 하되 그 정보가 실시간으로 반영될 필요는 없다고 가정
  - 고객은 사업장의 상세 정보를 살필 수 있어야 함

### 개략적 설계안 제시 및 동의 구하기

- RESTFUL API 관례를 따르는 간단한 API를 만들어 보도록 하겠다.
  - GET /v1/search/nearby
- 이 API는 특정 검색 기준에 맞는 사업장 목록을 반환한다. 실제로 사용되는 어플리케이션의 경우 페이지 단위로 반환하겠지만 여기서는 신경쓰지 않겠다. API 호출 시에 전달할 인자는 다음과 같다.
  - latitude (위도), longitude (경도), radius (선택적 인자로 기본값은 5000m)
- 반환되는 결과는 다음과 같은 형태를 띤다.
  - `{ total: 10, businesses: [{ business object }]}`
  - business object는 각 사업장을 표현하는 객체로 페이지에 표시될 모든 정보를 포함한다.
- 아래는 사업장 객체 관련 API이다.
  - `GET /v1/businesses/:id` 특정 사업자의 상세 정보 반환
  - `POST /v1/businesses/:id` 새로운 사업자 추가
  - `PUT /v1/businesses/:id` 사업장 상세 정보 갱신
  - `DELETE /v1/businesses/:id` 특정 사업장 정보 삭제

#### 데이터 모델

- 주변 사업장 검색, 사업장 정보 확인. 이 두 가지 용도로 읽기 연산은 굉장히 자주 수행된다.
- 한편 쓰기 연산 빈도는 낮은데, 사업장 정보를 추가하거나 삭제, 편집하는 행위는 빈번하지 않기 때문이다.
- 읽기 연산이 압도적인 시스템에서는 MySQL 같은 관계형 데이터베이스가 바람직할 수 있다.
- 시스템의 핵심이 되는 테이블은 business와 지리적 위치 색인 테이블이다.

  - 지리적 위치 색인 테이블은 위치 정보 연산의 효율성을 높이는데 쓰인다. 지오해시(geohash) 지식이 필요하므로 뒤에서 논의한다.

  <img src="https://github.com/programmer-sjk/TIL/blob/main/images/books/architecture/system-design2/proximity.png" width="500">

- 위 그림에서 LBS는 위치 기반 서비스이다. 주어진 위치와 반경 정보를 가지고 주변 사업장을 검색한다.
  - 쓰기 요청이 적고 읽기 요청이 빈번하게 발생하는 서비스이다.
  - QPS가 높다. 특히 특정 시간대의 인구 밀집 지역일수록 그 경향이 심하다.
  - 무상태 서비스이므로 수평적 규모 확장이 쉽다.

#### 주변 사업장 검색 알고리즘

- 실제로 많은 회사가 Redis의 지오해시나 PostGIS 확장을 설치한 Postgres 데이터베이스를 활용한다.
- 지리적 정보 색인을 만드는 방법에는 여러 알고리즘이 있지만 지오해시나 쿼드트리가 많이 쓰이고 있다.
- 이 둘을 가볍게 비교해보자.
  - 지오해시
    - 구현과 사용이 쉽고 트리를 새로 구축할 필요가 없다.
    - 지정 반경 이내 사업장 검색을 지원한다.
    - 인구 밀도에 따라 동적으로 격자 크기를 조정할 수는 없다.
    - 색인 갱신이 쉽다. 색인에서 사업장 하나를 삭제하려면 지오해시 값과 사업장 식별자가 같은 열 하나를 제거하기만 하면 된다.
  - 쿼드 트리
    - 트리를 구축해야 해서 구현하기가 살짝 더 까다롭다.
    - 가장 근거리의 k개의 무언가를 찾기 쉽다.
    - 인구 밀도에 따라 동적으로 격자 크기를 조정할 수 있다.
    - 지오해시보다 색인 갱신은 까다롭다.

### 상세 설계

- 지오해시나 쿼드트리 둘 다 널리 사용되지만 본 설계에서는 좀 더 단순한 지오해시를 사용하도록 하겠다.
- 지오해시 테이블 구성 방법은 두 가지이다.
  - 각각의 지오해시에 연결되는 모든 사업장 ID를 JSON 배열로 만들어 같은 열에 저장하는 방안이다.
  - 지오해시에 해당하는 사업장 ID를 각각 별도의 열로 저장하는 방법이다. 따라서 같은 지오해시에 해당하는 여러 열이 존재한다.
- 위 방법 중 두번째 방법을 추천한다.
  - 방안 1의 경우, 사업자 정보를 갱신하려면 JSON 배열을 읽고 사업장 ID를 찾아내야 한다. 새 사업장을 등록해야 하는 경우에도 이미 데이터가 있는지 전부 살펴봐야 한다.

#### 지리 정보 색인의 규모 확장

- 지리 정보 색인의 규모를 확장할 때 성급하게 샤딩 방법을 결정하는 실수를 저지르곤 한다. 하지만 현재 보고 있는 설계안의 경우 필요한 전체 데이터 양은 많지 않다. 색인 전부를 최신 DB 서버 한 대에 수용할 수 있다. 하지만 읽기 연산의 빈도가 높다면 서버 한대의 CPU와 네트워크 대역폭으로는 감당하지 못할 수도 있다. 그런 상황에선 여러 DB 서버로 부하를 분산해야 한다.
- 관계형 DB의 부하분산에는 두 가지 방법이 있다. 하나는 읽기 연산을 지원할 사본 DB를 늘리는 방법이고 다른 하나는 샤딩을 적용하는 것이다. 지오해시 테이블은 샤딩이 까다로우므로 샤딩을 강제할 필요는 없다. 따라서 이번 설계에서는 읽기 부하를 나눌 방법으로 읽기 DB를 두는 방법을 택하겠다.

#### 캐시

- 캐시 도입 전에 이런 질문을 던져야 한다. 정말 필요한가? 정말 좋은 결과로 이어지리라는 결론을 내리기는 어려울 것이다.
- 대부분 읽기 중심이고 DB 데이터 크기가 작아서 모든 데이터는 한 대의 DB 서버에 수용가능하다. 이런 경우 DB 버퍼 풀에 의해 캐시되어 I/O 부하가 크게 좌우되지 않는다.
- 만약 캐시를 사용하기로 했다면 가장 직관적인 캐시 키는 사용자의 위도와 경도 정보다. 하지만 사용자가 이동하면 위도와 경도 정보가 미세하게 변한다. 위치가 조금 달라지더라도 변화가 없어야 이상적이다. 지오해시나 쿼드트리는 이 문제를 효과적으로 해결한다. 같은 격자 내 모든 사업장이 같은 해시 값을 갖도록 만들 수 있기 때문이다.

## 주변 친구

- 앞서 살펴본 근접성 서비스와 비슷해 보이지만 두 기능 사이에는 큰 차이가 있다.
- 근접성 서비스의 경우 사업장 주소는 정적이지만 주변 친구 위치는 자주 바뀔 수 있기 때문이다.

### 문제 이해 및 설계 범위 확정

```text
지원자: 지리적으로 얼마나 가까워야 주변에 있다고 할 수 있나요?
면접관: 5마일입니다. 이 수치는 설정 가능해야 합니다.

지원자: 그 거리는 두 사용자 사이의 직선거리라고 가정해도 될까요?
면접관: 네 좋습니다.

지원자: 얼마나 많은 사용자가 이 앱을 사용하나요? 10억명을 가정하고 그 중 10% 정도가 이 기능을 활용한다고 생각해도 될까요?
면접관: 네 좋습니다.

지원자: 사용자의 이동 이력을 보관해야 하나요?
면접관: 네. 이동 이력은 기계 학습 등 다양한 용도로 사용될 수 있으니까요

지원자: 친구가 10분 이상 비활성 상태면 해당 사용자를 주변 친구 목록에서 사라지도록 하게 할까요? 아니면 마지막 위치를 표시해야 할까요?
면접관: 사라지게 합시다.
```

- 기능 요구사항
  - 사용자는 앱에서 주변 친구를 확인할 수 있어야 한다. 주변 친구에 보이는 해당 친구까지 거리, 해당 정보가 갱신된 시간이 함께 표시되어야 한다.
  - 친구 목록은 몇 초마다 한번씩 갱신되어야 한다.

### 개략적 설계안 제시 및 동의 구하기

- 먼저 떠오르는 방법은 공용 백엔드를 사용하는 것이다.

  <img src="https://github.com/programmer-sjk/TIL/blob/main/images/books/architecture/system-design2/find-friend-common-backend.png" width="500">

- 이 백엔드는 어떤 역할을 해야 할까?
  - 모든 활성 상태 사용자의 위치 변화 내역을 수신한다.
  - 사용자 위치 변경 내역을 수신할 때마다 해당 사용자의 모든 친구를 찾아서 그 친구들의 단말로 변경 내역을 전달한다.
  - 두 사용자 사이의 거리가 특정 임계치보다 먼 경우에는 변경 내역을 전송하지 않는다.
- 단순하고 명쾌한 설명 같지만, 큰 규모에 적용하기 쉽지 않다는 문제가 있다. 문제의 가정은 동시 접속 사용자가 천만명 정도라는 것이다. 위치 정보를 30초마다 갱신한다고 하면 초당 334,000번의 위치 정보 갱신을 처리해야 한다.
- 우선은 소규모 백엔드를 위한 개략적 설계안부터 만들어보자.

  <img src="https://github.com/programmer-sjk/TIL/blob/main/images/books/architecture/system-design2/find-friend-basic.png" width="500">

- 친구 위치 정보 변경은 거의 실시간에 가깝게 처리하는 서버 클러스터이다. 각 클라이언트는 웹 소켓 서버와 지속적으로 연결을 유지한다. 검색 반경 내 친구 위치가 변경되면 웹소켓 연결을 통해 클라리언트로 전송된다. 웹소켓 서버는 클라이언트 앱이 처음 실행되면 온라인 상태인 모든 친구 위치를 해당 클라이언트로 전송하는 역할도 한다. 그 절차는 나중에 상세히 보자.
- 레디스 pub/sub은 초경량 메시지 버스다. 레디스 pub/sub에 새로운 채널을 생성하는 것은 아주 값싼 연산이다. 기가바이트급 메모리를 갖춘 최신 레디스 서버에는 수백만개의 채널을 생성할 수 있다.

  <img src="https://github.com/programmer-sjk/TIL/blob/main/images/books/architecture/system-design2/find-friend-pub-sub.png" width="500">

- 웹소켓 서버를 통해 수신한 특정 사용자의 위치 정보 변경 이벤트는 사용자에게 배정된 pub/sub 채널에 발행한다. 해당 사용자의 친구 각각과 연결된 웹소켓 연결 핸들러는 해당 채널의 구독자로 설정되어 있다. 따라서 특정 사용자의 위치가 바뀌면 사용자의 모든 친구의 웹소켓 연결 핸들러가 호출된다. 각 핸들러는 위치 변경 이벤트를 수신할 친구가 활성 상태면 거리를 다시 계산해서 검색 반경 이내면 갱신된 위치와 갱신 시간을 웹소켓 연결을 통해 해당 친구의 클라이언트 앱으로 보낸다.
- 모바일 클라이언트가 위치 변경 내역을 전송할 때 절차를 살펴보자.
  - 모바일 클라이언트가 변경된 위치를 로드밸런서에 전송한다.
  - 로드 밸런서는 위치 변경 내역을 클라이언트와 연결된 웹소켓 서버로 보낸다.
  - 웹소켓 서버는 해당 이벤트를 위치 이동 이력 DB에 저장한다.
  - 웹소켓 서버는 새 위치를 위치 정보 캐시에 보관하며 TTL도 새롭게 갱신한다.
  - 웹소켓 서버는 레디스 pub/sub 서버의 해당 사용자의 채널에 새 위치를 발행한다.
  - 레디스 pub/sub에 발생된 이벤트는 모든 구독자에게 broadcase로 전달된다. 결과적으로 각 구독자의 웹소켓 연결 핸들러는 이벤트를 수신한다.
  - 웹소켓 연결 핸들러는 새위치를 기반으로 사용자와 메시지를 받은 사용자 사이의 거리를 계산해서 검색 반경을 넘지 않는다면 구독자의 클라이언트 앱으로 전송한다. 검색 반경을 넘었다면 보내지 않는다.

#### 데이터 모델

- 살펴 봐야 할 주제로 데이터 모델이 있다. 위치 정보 캐시와 위치 이동 이력 DB를 살펴보자.
- 위치 정보 캐시
  - 본 설계안에서는 DB 대신 레디스를 사용해 이 캐시를 구현한다.
  - 주변 친구 기능은 사용자의 현재 위치만을 이용하기에 하나만 보관하면 충분하다.
  - 레디스는 읽기/쓰기 연산 속도가 엄청 빠르기 때문에 이런 목적에 아주 적합하다.
  - TTL을 지원하므로 친구가 활성 상태가 아닌 경우에는 사용자 정보를 자동으로 제거할 수도 있다.
  - 주변 친구 기능에서 제공되는 위치 정보는 영속성을 보장할 필요가 없다는 사실을 유의하자.
- 위치 이동 이력 데이터 베이스
  - 우리가 필요로 하는 것은 막대한 쓰기 연산 부하를 감당할 수 있고, 수평적 규모 확장이 가능한 데이터베이스다.
  - 카산드라는 그런 요구에 잘 부합한다.
  - RDB도 사용할 수 있으나 이력 데이터 양이 너무 많을 수 있어 샤딩이 필요하다.
  - 사용자 ID를 기준 삼는 샤딩 방안이 가장 기본이다. 부하를 모든 샤드에 고르게 분산시킬 수 있고, DB 운영 관리도 간편하다.

### 상세 설계

- 웹 소켓 서버
  - 웹소켓 클러스터도 사용률에 따라 규모를 자동으로 늘리는 것은 그다지 어렵지 않다.
- 클라이언트 초기화
  - 모바일 클라이언트는 기동되면 웹소켓 클러스터 내의 서버 가운데 하나와 지속성 연결을 맺는다.
  - 웹소켓 연결이 초기화되면 클라이언트는 해당 모바일 단말의 위치, 즉 사용자의 위치 정보를 전송한다.
  - 그 정보를 받은 웹소켓 연결 핸들러는 다음 작업을 수행한다.
    - 위치 정보 캐시에 사용자 위치를 갱신한다.
    - 사용자 DB를 조회해 모든 친구 정보를 가져온다.
    - 위치 정보 캐시에 모든 친구의 위치를 한번에 가져온다.
    - 캐시가 돌려준 친구 위치 각각에 대해 웹소켓 서버는 해당 친구와 사용자 사이의 거리를 계산한다. 거리가 검색 반경 이내이면 친구의 위치를 웹소켓 연결을 통해 클라이언트에 반환한다.
    - 웹소켓 서버는 더불어 각 친구의 레디스 pub/sub 채널을 구독한다.
    - 사용자의 현재 위치를 레디스 pub/sub 채널을 통해 모든 친구에게 전송한다.
- 사용자 데이터베이스
  - 사용자 상세 정보 데이터, 친구 관계 데이터 두 종류의 데이터가 보관된다.
  - 설계의 규모를 감안하면 한 대의 RDB 서버로는 감당할 수 없다. 하지만 사용자 ID를 기준으로 샤딩하면 관계형 DB라해도 수평적 규모 확장이 가능하다. 관계형 DB 샤딩은 널리 사용되는 기술이다.
- 위치 정보 캐시
  - 위치 정보를 캐시하기 위해 레디스를 사용하였다. 시스템이 가장 붐빌때 천만 명의 사용자가 활성화되어 있고, 위치 정보 보관에 100 바이트가 필요하다고 가정하면 수 GB 이상의 메모리를 갖춘 레디스 한 대로 모든 위치를 캐시할 수 있다.
  - 하지만 천만 명의 활성 사용자가 대략 30초마다 변경된 위치 정보를 전송한다고 가정하면 레디스 서버는 초당 334K에 요청이 오는데 고사양 서버를 쓴다 해도 살짝 부담되는 수치이다. 다행스럽게 캐시할 데이터는 쉽게 샤딩할 수 있다. 각 사용자의 위치 정보는 서로 독립적인 데이터이므로 사용자 ID를 기준으로 여러 서버에 샤딩하면 부하를 고르게 분배할 수 있다.
- 레디스 pub/sub 서버
  - 모든 온라인 친구에게 보내는 위치 변경 내역 메시지의 라우팅 계층으로 레디스 pub/sub 서버를 사용한다.
  - 선택한 이유는 pub/sub 채널을 만드는 비용이 아주 저렴하기 때문이다.
  - 채널 하나를 유지하기 위해서는 구독자 관계를 추적하기 위한 해시 테이블과 연결 리스트가 필요한데, 아주 소량의 메모리만을 사용한다.
  - 주변 친구 기능을 사용하는 모든 사람들에게 채널을 하나씩 할당하면, 10억 사용자의 10%가 친구 기능을 쓴다고 가정하고 1억개라고 추정된다. 한 사람의 친구 중 100명이 주변 친구 기능을 사용한다고 가정하고, 구독자 한 명을 추적하기 위해 내부 해시 테이블과 연결 리스트에 20바이트를 저장한다고 가정하자. 모든 채널을 저장하는데는 200GB의 메모리가 필요하니, 100GB 최신 레디스 pub/sub 서버 두 대면 될 것이다.
- 분산 레디스 pub/sub 서버 클러스터
  - pub/sub 서버가 구독자에게 전송해야 하는 데이터는 초당 1400만 건에 달하기에 한 대의 서버로 감당할 수 없다.
  - 수백 대의 레디스 서버에 채널을 분산할 방법은 무엇일까? 다행인점은 모든 채널을 독립적이라는 사실이다. 그러니 메시지를 발행할 사용자 ID르 기준으로 pub/sub 서버들을 샤딩하면 된다. 하지만 현실적으로 수백대의 서버와 관련된 문제이므로 서비스 탐색 컴포넌트를 도입해 이 문제를 푼다. 가장 널리 알려진 주키퍼 등이 사용된다.

### 마무리

- 이 설계안의 핵심 컴포넌트는 다음과 같다.
  - 웹소켓: 클라이언트와 서버 사이의 실시간 통신을 지원한다.
  - 레디스: 위치 데이터의 빠른 읽기/쓰기를 지원한다.
  - 레디스 pub/sub: 한 사용자의 위치 정보 변경 내역을 모든 온라인 친구에게 전달하는 라우팅 계층이다.

## 분산 메시지 큐

- 메시지 큐를 사용하면 어떤 이점을 얻을 수 있을까?
  - 결합도 완화: 메시지 큐를 사용하면 컴포넌트 사이의 강한 결합이 사라지므로 각각을 독립적으로 갱신할 수 있다.
  - 규모 확장성 개선: 생산자와 소비자 시스템 규모를 트래픽 부하에 맞게 독립적으로 늘릴 수 있다. 트래픽이 많이 몰리는 시간에 소비자를 추가하여 처리 용량을 늘린다.
  - 가용성 개선: 시스템의 특정 컴포넌트에 장애가 발생해도 다른 컴포넌트는 큐와 상호작용을 이어나갈 수 있다.
  - 성능 개선: 메시지 큐를 사용하면 비동기 통신이 쉽게 가능하다. 생산자는 응답을 기다리지 않고 메시지르 보낼 수 있고 소비자는 읽을 메시지가 있는 경우에만 메시지르 소비하면 된다.
- 메시지 큐 대 이벤트 스트리밍 플랫폼
  - 엄밀하게 말하면 카프카는 메시지 큐가 아니라 이벤트 스트리밍 플랫폼이다.
  - 하지만 지원하는 기능이 서로 닮아가면서 점차 구분이 희미해지고 있다.
- 이번 장에서는 데이터 장기 보관, 메시지 반복 서비스 등의 부가 기능을 갖춘 분산 메시지 큐를 설계해 볼 것이다.
