# 실용주의 프로그래머

- [책 링크](https://product.kyobobook.co.kr/detail/S000001033128)

## 실용주의 철학

### 당신의 인생이다

- 당신의, 당신이 사는, 당신이 만드는 세상이다.
- 만나본 많은 개발자가 불만에 가득 차 있었다. 불만의 종류는 다양하지만 우리의 답은 한결같다. **`왜 직접 바꾸지 않습니까?`**
- 소프트웨어 개발은 구직자에게 주도권이 높은 직업이다. 주도적으로 행동해서 그 기회를 잡아라.

### 고양이가 내 소스 코드를 삼켰어요

- 자신의 행동에 책임을 져야 한다. 자신의 경력 개발, 자신의 학습 및 교육, 프로젝트, 자신의 일상 업무에 대해 말이다.
- **`무엇보다 팀이 여러분을 믿고 의지할 수 있어야 한다`**. 여러분도 팀원을 편하게 의지할 수 있어야 한다. 팀에 신뢰가 없다면... 어휴
- 결과에 대해 책임을 지기로 했다면 결과를 감당해야 한다. 과정에서 실수나 잘못이 있었다면 정직하게 인정하고 다른 방안을 제안해야 한다.
- 소스 코드가 날아갔는데 백업이 없다면 그건 여러분의 잘못이다. **`고양이가 내 소스 코드를 삼켰어요.`** 라고 상사에게 말해봤자 도움될 것은 없다.
- **`변명 말고 대안을 제시하라.`** 안된다고 하지 말고 상황을 개선하기 위해 무엇을 할 수 있는지 설명하라.

### 소프트웨어 엔트로피

- **`엔트로피는`** 시스템의 무질서한 정도를 가리키는 물리학 용어다.
- 소프트웨어의 무질서가 증가할 때 우리는 이를 기술 부채라고 부른다.
- **`깨진 창문을 고치지 않은 채로 내버려 두지 말라`**. 나쁜 설계, 잘못된 결정 혹은 형편없는 코드 등이 모두 깨진 창문이다.
  - 깨진 창문을 발견하자마자 바로 고쳐라. 고칠 시간이 없다면 일단 판자로 덮기라도 하자.
- 깨진 창문이 너무 많아 치울만한 시간이 없다고 생각할지도 모르겠다. 그렇다면 큰 쓰레기통을 구하거나 다른 곳으로 이사할 계획을 세우는게 좋을 수 있다.

### 돌멩이 수프와 삶은 개구리

- 전체 시스템을 구상하고 허락을 구하는 순간부터 일들이 복잡해질 수 있다. 각자 자신의 자원을 지키려고 할 것이다.
- 큰 무리없이 요구할 수 있는 돌맹이를 내놓고 잘 개발하자. 그걸 사람들에게 보여주고 조금씩 변화시켜라.
- 천천히 온도가 오르는 물에서 개구리가 변화를 인지하지 못하듯이, 그런 개구리가 되지 말자. 큰 그림에 주의를 기울이고 주변에서 무슨 일이 벌어지는지 살펴봐라.

### 적당히 괜찮은 소프트웨어

- **`우리의 지식과 경험이야 말로 가장 중요하고`** 날마다 쓰이는 전문가 자산이다.
- 우리 지식을 위한 투자를 지속하는 것이 중요하다. 일년에 새로운 언어를 하나를 배우고, 책을 읽고 수업을 들으며, 커뮤니티에 참여해보자.

### 소통하라

- 개발자는 여러 입장에서 소통하고 회의하고, 듣고 말하는데 많은 시간을 보낸다.
- 하루 중 많은 시간을 소통하며 보내기 때문에 이를 잘하기 위해 노력해야 한다.

## 실용주의 접근법

### 좋은 설계의 핵심

- 좋은 설계는 나쁜 설계보다 바꾸기 쉽다. **`바꾸기 쉽게. 이게 전부다`**.
  - 왜 결합도를 줄이면 좋을까? 관심사를 분리해 바꾸기 쉽기 때문이다.
  - 왜 단일 책임 원칙이 좋을까? 요구사항이 바뀌더라도 모듈 하나만 바꿔서 반영할 수 있기 때문이다.
  - 왜 이름 짓기가 중요할까? 코드를 읽기 쉬워지고 바꾸려면 코드를 읽어야 하기 때문이다.
- 코드를 작성할 때 어떤 가치가 중요한지 모르겠다면 언제건 **`바꾸기 쉽게 라는 길을 선택한다`**.
- 교체하기 쉬운 코드를 작성하란 것은 **`코드의 결합도를 낮추고 응집도를 높이라는 이야기일 뿐이다`**.

### DRY: Dont Repeat Yourself

- **`DRY를 따르지 않으면 똑같은 코드가 두 군데 이상에 표현될 것이다`**. 하나를 바꾸면 나머지 하나도 기억해서 바꿔야 함을 의미한다.
  - 이것은 기억하느냐의 문제보다, 언제 잊어버릴까 하는 문제이다.
- DRY는 지식의 중복, 의도의 중복을 의미한다. **`똑같은 개념을 다른 곳 두 군데에서 표현하면 안된다는 것이다`**.
- 발견하기 어려운 중복 중 하나는 개발자들 사이에서 바랭한다. 똑같은 일을 하는 코드가 우연히 중복될 수 있다.
  - 최선책은 개발자들 간 적극적이고 빈번한 소통을 장려하는 것이다.

### 직교성

- 컴퓨터 과학에서 직교성이란 결합도 줄이기를 의미한다. 하나가 바뀌어도 나머지에 영향을 주지 않으면서 서로 직교한다는 뜻이다.
- 직교적인 시스템을 작성하면 생산성 향상과 리스크 감소의 이점을 얻을 수 있다.
- 개발자는 시스템을 직교적으로 설계해야 한다는 것을 안다. 직교적이라는 것을 설명할 때 모듈식, 컴포넌트 기반, 계층과 같은 다른 용어를 사용하며 말이다.
- **`설계가 직교적인지 확인하려면 특정 기능에 대한 요구사항을 대폭 수정하는 겨우 몇 개의 모듈이 영향을 받는지 물어보자`**. 직교적인 시스템에서 답은 하나여야 한다.
- 현실 세계의 변화와 설계 사이의 결합도도 확인해야 한다. 전화번호로 고객을 식별한다면 잘못되었다. 우리가 제어할 수 없고 전화번호 체계가 바뀔수 있기 때문이다. **`자신의 힘으로 제어할 수 없는 속성에 의존하지 말자`**.

### 가역성

- 가진 생각이 단 하나뿐이라면, 그것만큼 위험한 것도 없다.
- 가역성은 초기 상황으로 되돌아 올 수 있는지를 의미하며 문제는 중요한 결정은 쉽게 되돌릴 수 없다는 점에 있다.
  - 특정 데이터베이스, 아키텍처 패턴, 어떤 배포 모델을 사용하기로 결정했다면 큰 비용을 치러야만 되돌릴 수 있다.
- 신기술이 튀어나오고 아키텍처가 변덕스런 상황에서 우리는 바꾸기 쉽게 만드는 선택을 해야 한다.
  - 외부의 API를 우리가 만든 추상화 계층 뒤로 숨기자.
- **`가역성과 관련된 다른 조언은 유행을 좇지 말자`**. 누구도 어떤 미래가 올지 모르기에 락을 할수도 있고 록을 할수도 있도록 준비하자.

### 예광탄

- 전체 기능을 보여주지 않더라도 일부를 만들어 제공할 수 있다.
- 시스템을 정의하는 중요한 요구사항을 찾자. 의문이 드는 부분이나 가장 위험이 커 보이는 곳을 찾고 먼저 개발하도록 우선순위를 정하자.
- **`예광탄 코드는 한 번 쓰고 버리려고 만드는 것이 아니다`**. 이 점에서 프로토 타입과 차이가 있다. 예광탄 코드에는 아직 모든 기능이 들어 있지 않을 뿐이다.
- 프로토 타입은 나중에 버리는 코드를 만들지만 예광탄 코드는 완결된 코드이며 최종 시스템 골격의 일부가 된다.

### 프로토타입과 포스트잇

- **`프로토타이핑의 대상은 어떤게 될까?`** 위험을 수반하는 모든 것이다.
- 이전에 해 본적 없는 것, 최종 시스템에 매우 중요한 것이 프로토타이핑 대상이다. 증명되지 않았거나 실험적이거나 의심이 가는 것 모두.
  - 예를 들면 아키텍처, 추가할 새로운 기능, 외부 데이터의 구조 및 내용, 외부 도구나 컴포넌트, 성능, 사용자 인터페이스 설계가 포함된다.
- 프로토타이핑은 학습 경험이다. **`프로토타이핑의 가치는 생산한 코드가 아니라 이를 통해 배우는 교훈에 있다`**.

## 기본도구

- **`도구가 더 훌륭하고 능숙해질수록 우리들의 생산성은 더 높아질 것이다`**. 사용하는 도구로 해결할 수 없는 문제를 마주쳤다면 새로운 도구를 찾아야 한다.
- shell에 익숙해지면 생산성이 크게 오르게 된다. shell을 우리들의 집으로 만들어라
- 일주일에 에디터를 20시간 사용한다고 가정하면 속도가 4%만 빨라져도 1년이면 일주일의 업무 시간을 아낄 수 있다. 더 중요한건 에디터 사용법을 더 생각하지 않아도 된다는 점이다.
- 언제나 버전 관리 시스템을 사용하라.

### 디버깅

- 아무도 완벽한 SW를 작성하지 못하므로 디버깅을 하게 될 것이란건 기정 사실이다.
- 다른 사람의 버그를 발견한 후 비난에 시간을 쏟지 말고 문제를 고치는데에 집중해야 한다.
- 디버깅을 할 때 근시안의 함정에 주의해라. 표면에 보이는 증상만 고치려는 욕구를 이겨내라. 실제 문제는 몇 단계 떨어져 있고, 다른 여러가지와 연관되어 있을 확률이 있다. **`항상 문제의 근본 원인을 찾으려고 노력하라`**.
- 버그를 고치는 첫걸음으로 가장 좋은 것은 그 버그를 재현할 수 있도록 만드는 것이다.
- 빨간색 에러 메시지가 나오면 코드로 직진하는 개발자들이 많은데 제발 그놈의 오류 메시지좀 읽어라.
- 버그를 마주쳤을 때 고치는 것을 넘어 **`왜 이 문제가 더 일찍 발견되지 않았을까 생각해봐야 한다`**. 미리 잡을수 있도록 테스트를 추가할 필요가 있는지 고민하라.

## 실용주의 편집증

- 모든 사람들은 완벽한 소프트웨어를 만들 수 없다. 삶의 공리로 인정하고 받아들이자.

### 계약에 의한 설계 (Design By Contract)

- 버트런드 마이어는 Eiffel 언어르 만들면서 **`계약에 의한 설계 개념`**을 개발했다.
- DBC는 단순하지만 프로그램의 정확성을 보장하기 위해 소프트웨어 모듈의 권리와 책임을 문서화하고 합의하는데 초점을 맞춘다.
- DBC는 아래 3가지를 만족시킨다.
  - 선행조건: 함수의 선행 조건이 위반된 겨우 함수를 호출해서는 안된다. 제대로 된 데이터를 전달하는 것은 호출하는 쪽의 책임이다.
  - 후행조건: 루틴이 완료될때 상태다.
  - 클래스 불변식: 클래스의 루틴이 끝나고 반환하는 시점에는 항상 불변식이 참이 되어야 한다. (클래스 내부에서 방어로직)
- 루틴 간 코드 계약은 다음과 같다.
  - 만약 호출자가 루틴의 모든 선행 조건을 충족한다면 해당 루틴은 종료시 모든 후행 조건과 불변식이 참이 되는 것을 보장한다.
- 만약 계약 당사자 중 한쪽이라도 이 계약 내용을 지키지 못하면 예외가 발생하거나 프로그램을 종료시킬 수 있다.
  - 계약에 부응하지 못하는 것은 버그라는 것이다.
- DBC는 **`일찍 작동을 멈춰라는 개념과 잘 어울린다`**. 선행조건, 후행조건, 불변식을 검증하면 더 일찍 멈추고 문제를 정확히 알려준다.

### 죽은 프로그램은 거짓말을 하지 않는다

- 모든 오류는 정보를 준다. 무시할수도 있지만 실용주의 프로그래머라면 나쁜 일이 생긴것이라 생각하고 오류 메시지를 읽는다.
- **`문제를 발견하면 빨리 시스템을 멈추는게 낫다`**. 있을 수 없는 일이 발생한 것은 프로그램이 더 유효하지 않다는 의미이다. 이 시점 이후 하는일은 모두 수상쩍다. 되도록 빨리 종료하자.

### 리소스 사용의 균형

- 우리는 코딩하며 언제나 리소스를 사용한다. 메모리, 트랜잭션, 스레드 등 무한히 사용할 수 없는 모든 종류의 것을 관리한다.
- 많은 개발자가 리소스 할당과 해제를 다루는 일관된 방침을 갖고 있진 않다. **`하나의 팁은 자신이 시작한 것은 자신이 끝내라는 방침이다`**.
- 하나의 함수에서 파일 객체를 열고 다른 함수에서 파일 객체를 닫는다면 이 둘은 긴밀히 결합되고 파일 객체가 닫히지 않는 문제가 발생할 수도 있다.

## 구부러지거나 부러지거나

- 가역성을 설명하며 되돌릴 수 없는 결정이 얼마나 위험한지 이야기했다. 이번 장에서는 되돌릴 수 있는 의사 결정을 내리는 구체적인 방법을 설명한다.
- 코드 간 의존도를 나타내는 **`결합도를 살펴볼 것이며 유연하고 바꾸기 쉬운 코드를 만들 수 있는 대안을`** 살펴본다.
- 유연함을 유지하는 한 가지 좋은 방법은 코드를 적게 작성하는 것이다. 코드 수정은 새로운 버그를 만드는 계기이기도 하다.

### 결합도 줄이기

- 높은 결합도는 변경의 적이다.

#### 열차사고

- 아래 코드를 보자.

  ```java
    public void applyDiscount(customer, order_id, discount) {
      totals = customer.orders.find(order_id).getTotals();
      totals.grandTotal = totasl.grandTotal - discount;
      totals.discount = discount;
    }
  ```

- 고객 객체에서 주문 컬렉션을 얻고, 특정 주문을 찾아 합계를 얻는다. 이 코드를 쓰거나 이해하기 위해 알아야 하는 것이 맘ㄶ다.
- 기차의 모든 객차가 서로 연결되어 있듯이 **`메서드나 속성들이 모두 연결되어 있다. 이런 코드를 열차 사고라고 부른다`**.
- 이를 고치기 위해 **`묻지 말고 말하라는 원칙을 적용할 수 있다`**. 이 원칙은 다른 객체의 내부 상태에 따라 판단을 내리고 객체를 갱신해서는 안 된다는 것이다. **`객체의 내부 상태를 묻는 것으로 캡슐화의 장점은 사라지고 구현에 대한 지식이 여기저기 퍼지게 된다`**. 열차 사고를 고쳐보자.

  ```java
    // 먼저 할인 처리를 totals 객체에 위임한다.
    public void applyDiscount(customer, order_id, discount) {
      customer.orders.find(order_id).getTotals().applyDoiscount(discount);
    }

    // 주문 컬렉션을 가져와서 주문을 찾지 말고 고객 객체에서 바로 주문 객체를 얻어와야 한다.
    public void applyDiscount(customer, order_id, discount) {
      customer.findOrder(order_id).getTotals().applyDoiscount(discount);
    }

    // 주문 객체가 합계를 계산하도록 수정한다.
    // 먼저 할인 처리를 totals 객체에 위임한다.
    public void applyDiscount(customer, order_id, discount) {
      customer.findOrder(order_id).applyDoiscount(discount);
    }
  ```

#### 디미터 법칙

- 결합도에 대해 이야기 할 때 **`디미터 법칙을`** 언급하는 경우가 많다. 디미터 프로젝트를 수행하는 도중 개발자들에게 보다 깨끗하고 결합도가 낮은 함수를 작성하는 방법을 알려주기 위해 만들게 되었다.
- 디미터 법칙은 어떤 클래스 A에 정의된 메서드가 다음에 속하는 것만 사용할 수 있다고 제한한다.
  - A의 다른 인스턴스 메서드
  - 메서드의 매개 변수
  - 스택이나 힙에 자신이 생성하는 객체의 메서드
  - 전역 변수
- **`디미터 법칙은 1980년대에 나온 법칙으로 현재는 빛이 바래고 말았다`**. 우리는 전역 변수를 잘 쓰지 않으며 이 법칙을 실제로 사용할때마다 법률 문서를 읽는 느낌이다. 하지만 기반이 되는 원칙은 유효하므로 좀 더 쉬운 표현으로 **`메서드 호출을 엮지 말라라고 정리하고 싶다`**.
- 무언가에 접근할 때 `.`을 딱 하나만 쓰려고 노력해보자.

  ```java
    // 안 좋은 방식
    amount = customer.orders.last().totals().amount;

    // 안 좋은 방식
    orders = customer.orders;
    last = orders.last();
    totals = last.toals();
    amount = totals.amount;
  ```

- 점 하나 규칙에는 예외가 있다. 엮는 것들이 바뀌지 않는다면 이 규칙을 지키지 않아도 된다. **`언어에 기본으로 포함된 라이브러리라면 안정적일 것이고 다음과 같이 써도 될 것이다`**. 위 루비코드는 20년 전에도 동작했고 저자들이 죽어서까지 동작할 것이다.

  ```java
    people.sort_by(~).fisrt(10).map(~)
  ```

#### 결국은 모두 ETC

- 이 외에도 전역 데이터를 피하고 상속은 결합도를 늘리는 측면이 있다.
- 결합된 코드는 바꾸기 힘들다. 코드의 한 곳을 바꾸면 다른 곳에 여파를 미칠수가 있다.
- **`직접적으로 아는 것만 다루는 부끄럼쟁이 코드를 계속 유지하라`**. 그러면 결합도를 낮게 유지할 수 있을 것이고 결과적으로 코드를 바꾸기 쉬워진다.

### 실세계를 갖고 저글링하기

#### 이벤트

- 이벤트는 무언가 정보가 있다는 것을 의미한다. 정보는 사용자가 버튼을 클릭하거나 정보가 갱신될 때처럼 외부에서 올 수 있다. 정보는 내부에서도 생길 수 있다. 계산 결과가 나왔거나 검색이 끝났을 수도 있다.
- 어디에서 온 것이든 어플리케이션이 이벤트에 해당하는 반응을 잘 만들면 진짜 세상에서 더 잘 동작하는 어플리케이션이 탄생할 것이다.
- 이벤트를 다룰 때 도와줄 네가지 전략을 살펴보자.
  - 유한 상태 기계 (FSM)
  - 감시자 패턴
  - 게시-구독
  - 반응형 프로그래밍과 스트림

### 상속세

- OOP 프로그래밍을 하는데 상속을 사용한다면 멈추자. **`상속도 일종의 결합이다`**. 자식이 부모와 조상 클래스들에게 결합하게 된다.
- 만약 부모 클래스를 누군가 수정하면 상속하는 클래스에 영향을 미칠 수 있다. 부모 클래스의 인스턴스 변수 이름은 내부 구현의 세부사항이지만 변수 이름을 바꾸자 자식 클래스가 망가졌다. 결합이 너무 많다.
- 상속을 쓸 필요가 없게 해주는 세가지 방법을소개한다.

#### 인터페이스와 프로토콜

- 클래스가 어떤 동작을 구현한다고 지정할 수 있다. 자바 예시에서는 아래와 같다.

  ```java
    public class Car implements Drivable, Locatable { ... }
  ```

- `Drivable, Locatable`을 인터페이스라고 부르며 언어에 따라 프로토콜이라 트레이트라고 부르는 언어도 있다.
- 인터페이스의 선언들은 아무런 코드도 만들지 않는다. 그냥 인터페이스에 정의된 메서드를 구현해야 한다고 지시할 뿐이다.
- 인터페이스가 강력한 이유는 이들을 타입으로 사용할 수 있고 해당 인터페이스를 구현하는 클래스라면 무엇이든 그 타입과 호환되기 때문이다. 만약 `Car`와 `Phone`이 `Locatable` 인터페이스를 구현했다면 둘 다 Localtable한 것을 담는 리스트에 넣을 수 있다.

  ```java
    List<Locatable> items = new ArrayList<>();
    items.add(new Car());
    items.add(new Phone());
    items.add(new Car());
  ```

- 위 리스트를 처리할 때 모두 Locatable의 메서드를 구현했다고 확신할 수 있으므로 이를 다형성에 활용할 수 있다.

  ```java
    void printLocation(Locatable itesm) {
      if (item.locationIsValid()) {
        print(item.getLocation());
      }
    }
  ```

- **`인터페이스는 상속 없이도 다형성을 가져다준다`**.

#### 위임

- 상속 대신 위임을 사용하면 어떨지 고민하자. **`has-A 보다 is-A가 낫다`**.

#### 믹스인과 트레이트

- 클래스에 상속을 사용하지 않고 새로운 기능을 추가하여 확장하고 싶다. 그래서 일련의 함수를 만들고 이름을 부여한 다음, 이것으로 클래스나 객체를 확장한다. 이를 **`믹스인이라고`** 한다.

### 설정

- 어플리케이션이 바뀔 수도 있는 **`값에 코드가 의존하고 있다면 그 값을 어플리케이션 외부에서 관리하자`**.
- 일반적으로 설정 데이터 안에 넣는 것은 다음과 같다.
  - DB나 외부 API와 같은 외부 서비스의 인증 정보
  - 어플리케이션이 사용하느 포트 번호, IP, 크러스터 이름
  - 라이선스 키
- 기본적으로 나중에 바뀔것을 알고 있는것은 설정에 던져 넣어라.
- 설정 데이터를 동적으로 바꿀 수 있는 거은 고가용성에 중요하다. **`설정 값 하나를 바꾸기 위해 빌드 및 배포해야 하는건 현대의 삶에 어울리지 않는다`**. 설정 정보를 바꾸기 위해 코드 빌드가 필요해서는 안 된다.

## 동시성

- **`동시성이란`** 둘 이상의 코드 조각이 실행될 때 동시에 실행중인 것처럼 행동하는 것이다.
- **`병렬성이란`** 실제로 동시에 실행되는 것이다.
- 세상은 비동기적으로 동작하기 때문에 어플리케이션이 실제 세상을 다루기 원한다면 동시성은 필수다.

### 시간적 결합 깨뜨리기

- 사람들의 사고방식은 이것을 한 뒤 저것을 하고. 이렇게 생각하면 시간적 결합을 만들게 된다. 메서드 A는 언제나 메서드 B보다 먼저 호출되어야 한다. 우리는 동시성을 확보해야 한다. 시간이나 순서에 의존하는 시간적 결합을 끊는 방법을 생각해 내야 한다.

### 공유 상태는 틀린 상태

- 프로세스 A가 메모리의 데이터를 얻은 뒤 덮어썼다. 동일한 시점에 프로세스 B가 메모리의 데이터를 같이 얻은 뒤 다른 값으로 덮어썼다. 이런 **`동시접근에 따른 공유 상태는 갱신하는 동작이 원자적이지 않기 때문이다`**. 그럼 어떻게 원자적으로 바꿀 수 있을까?
- 세마포어와 같은 락을 획득하고 반환하는 방식을 떠올릴 수 있다. 하지만 락을 반환하지 못하게 되거나 데드락이 되지 않도록 신경써야 한다.
- 액터와 프로세스를 사용하면 흥미로운 방식으로 동시성을 구현할 수 있다. 공유 메모리 접근을 동기화하느라 고생할 필요가 없다.
- 액터는 비공개 상태르 가진 가상 처리 장치로 각 액터는 우편함을 가지고 있다. 우편함에 메시지가 도착하면 액터는 한 번에 하나의 메시지만 처리한다. 결과적으로 액터들은 아무것도 공유하지 않으면서 비동기적으로 동시에 실행된다.

## 코딩하는 동안

- 적극적으로 자기 코드에 대해 생각하지 않는 프로그래머는 우연에 맡기는 프로그래밍을 하는 것이다. **`코드가 작동하긴 하지만 왜 그렇게 작동하는지 설명은 못한다`**. 읽고 분석하기 쉬운 코드를 쓰는 것은 대단히 중요하다.

### 파충류의 뇌에 귀 기울이기

- 어떤 작업에 대해 의심되거나 꺼림칙하다면, 그 느낌을 따라라. 어떤 것이 문제라고 정확히 짚지는 못해도, 시간을 좀 주면 의심은 아마도 더 실체가 있고 대응책을 생각할 수 있는 무엇으로 구체화될 것이다.
- 가끔은 코드가 뇌에서 에디터로 술술 옮겨지는 날이 있고, 어떤 날은 오르막길을 걷는 것처럼 느껴지는 날도 있다. **`하지만 전문가라면 계속해 나가야 하지 않을까?`** 진흙 묻은 발을 끌고 또 한 발을 내디뎌서 맡겨진 일을 해야 마땅하지 않을까?
- 직감에 귀 기울이는 방법은 중요한 기술이다. 가끔은 설계가 이상하게 느껴질 수도 있고 요구사항이 마음을 불편하게 할 수도 있다. 하던 일을 멈추고 그 느낌을 분석하라. 어두운 출입구에 무언가가 숨어있을 수 있다. 본능에 귀를 기울이고 문제가 튀어나오기 전에 미리 대처하라.

### 우연에 맡기는 프로그래밍

- 우리는 행운과 우연한 성공에 의존하는 프로그래밍을 해선 안된다. **`대신 의도적인 프로그래밍을 해야 한다`**.
- 한 프로그래머가 약간의 코드를 작성하고 돌려보니 잘 돌아간다. 코드를 조금 덧붙이고 돌려서보니 또 잘 돌아간다. 이렇게 몇번을 반복하다 갑자기 프로그램이 잘 돌아가지 않았다. 왜 코드가 망가졌는지 모르는 이유는 애초에 코드가 왜 잘 돌아가는지도 몰랐기 때문이다.
- 의도적으로 프로그래밍해야 한다. **`언제나 지금 무엇을 하고 있는지 알아야 한다`**. 더 경험이 적은 프로그래머에게 코드를 상세히 설명할 수 있는가? 그렇지 않다면 우연에 기대고 있는 것이다. 자신도 잘 모르는 코드를 만들지 말자. 이해하지 못한 기술을 사용하면 우연의 함정에 빠질 가능성이 높다. 이것이 왜 동작하는지 잘 모른다면 왜 실패하는지도 알리가 없다.
- 과거의 노예가 되지 말라. 기존 코드가 앞으로 짤 코드를 지배하도록 두지 말자. 더는 적절한 코드가 아니다 싶으면 어떤 코드라도 교체할 수 있다.

### 알고리즘의 속도

- 보통 알고리즘은 대문자 `O표기법으로` 측정하는 방식으로 이뤄진다.
- 단순 반복문 하나가 1부터 n까지 돌아간다면 이 알고리즘은 `O(n)`일 가능성이 크다. 반복문 안에 또 반복문이 있다면 알고리즘은 `O(m x n)`이 되며 m과 n은 두 반복문의 반복 횟수다. 이런 알고리즘은 동일한 크기를 가지면 `O(n^2)`이 되기 쉽다. 이진 검색이나 이진 트리의 탐색의 경우 로그적 알고리즘 `O(logN)`이 될 가능성이 크다.
- 적당한 알고리즘을 선택할 때도 실용적이어야 한다. **`가장 빠른 알고리즘이 언제나 가장 좋은 알고리즘은 아니다`**. 입력값의 규모가 작다면 단순한 삽입 정려도 퀵 정렬가 비슷한 성능을 낸다. 그리고 삽입 정렬은 작성하고 디버깅 하기 쉬운 장점이 있다. 우리가 택한 알고리즘이 입력 데이터의 규모가 어느정도 될지 주의 깊게 생각해야 한다.
- **`성급한 최적화를 조심하라`**. 어떤 알고리즘을 개선하느라 우리의 귀중한 시간을 투자하기 전에 정말 그 알고리즘이 병목인지 확인해야 한다.

### 리팩터링

- 프로그램이 발전함에 따라 초기 결정을 다시 고려하고 코드의 일부분을 다시 작성할 일이 생긴다. 이것은 지극히 자연스러운 과정으로 코드는 발전해야 한다.
- 코드 고쳐쓰기, 다시 작업하기, 다시 아키텍처 만들기는 모두 아울러서 리팩터링이라고 부른다. 마틴 파울러는 **`리팩터링의 정의를`** 다음과 같이 했다. **`밖으로 드러나는 동작은 그대로 유지한 채 내부 구조를 변경함으로써 이미 존재하는 코드를 재구성하는 체계적 기법`**. 밖으로 드러나는 동작이 바뀌지 않는것음 보장하려면 좋은 자동화 된 단위 테스트가 필요하다.
- 리팩터링은 언제 할까? 10분 전과 비교해 더 많이 알게 되었다면 리팩터링을 한다. 주저하지 말고 변경하자. 코드를 리팩터링 할 이유는 아주 많다. 리팩터링을 할 몇 가지 사례들을 정리한다.
  - 코드의 중복 / 더 이상 유효하지 않은 지식 / 성능 / 테스트 통과
- 일정의 압박은 리팩터링을 하지 않는 단골 핑계이지만 설득력이 떨어진다. 지금 리팩터링을 하지 않으면 일이 더 진척되었을 때 훨씬 더 많은 시간을 투자해야 한다. 리팩터링을 하는 방법에 대한 조언을 추가한다.
  - 리팩터링과 기능 추가를 동시에 하지 말라.
  - 리팩터링을 시작하기 전 든든한 테스트가 있는지 확인하라. 할 수 있는한 자주 테스트를 돌려보면 무언가 망가졌을 경우 그 사실을 빨리 알 수 있다.
  - 단계를 작게 나누어서 신중히 작업하라. 메서드 하나 쪼개기, 변수명 하나 바꾸기와 같은 작은 단위로 작업해야 한다.
- **`우리들이 기대하는 수준에 못 미치는 코드를 발견하면 고쳐라`**. 고통을 관리하자. 지금은 고통스러울지라도 앞으로 더 고통스러울 것 같으면 고치는게 낫다. 깨진 창문을 그대로 놓아두지 말자.

### 테스트로 코딩하기

- **`테스트는 버그를 찾기 위한 것이 아니다`**.
- 테스트에 대해 생각함으로 코드의 결합도를 낮추고 유연성은 올릴 수 있다. 다른 코드와 긴밀하게 결합된 메서드는 테스트하기 힘들다. 즉 무언가 테스트하기 좋게 만들면 결합도도 낮아진다. 그리고 테스트하려면 이해해야만 한다. 아리송한채로 코드를 작성한 경험이 있을 수 있다. 하지만 경계 조건을 고려하고 오류 조건에 대해 생각해 본다면 함수 구조를 잡는데 도움이 될 것이다.
- 테스트를 이제 막 배운 사람들에게 TDD는 효과가 있다. TDD를 따르면 언제나 테스트에 대해 생각하게 된다. **`하지만 TDD의 노예가 된 사람들도 있다`**. 테스트 커버리지 100%를 달성하기 위해 많은 시간을 쓰고 중복 테스트가 발생한다. TDD를 실천하는 건 좋다. 하지만 테스트에 중독된 나머지 진짜 문제를 해결하는데 도움되지 않는 코드를 한 무더기나 쓰게 되기 쉽다.
- 우리가 작성하는 소프트웨어는 언젠가 테스트 된다. 테스트 코드로 검증하지 않으면 결과적으로 사용자들이 테스트하게 된다. 그러니 SW를 철저하게 테스트할 계획을 세우자. **`약간의 수고로 유지 보수 비용과 전화가 걸려올 횟수를 크게 줄일 수 있다`**.
- 제대로 된 테스트 문화를 가졌다면 모든 테스트가 언제나 통과해야 한다. 실패하는 불량 테스트를 무시하다 보면 모든 테스트를 무시하게 되고 악순환이 반복된다.
- **`테스트 코드를 제품 코드와 마찬가지로 다뤄라`**. 결합도를 낮추고 깨끗하고 견고하게 유지하라. 현재시간과 에러 메시지와 같은 신뢰할 수 없는것에 의존하지 말자. 이런 종류의 것을 테스트하면 테스트가 더 잘 깨지게 된다. 테스트는 프로그래밍의 일부다. 다른 사람에게 떠넘길 수 있는 것이 아니다.

### 이름 짓기

- 프로그래밍에서는 이름이 모든 것이다. **`이름은 매우 중요한데 우리의 의도와 믿음을 잔뜩 드러내기 때문이다`**.
- 이름을 지을때 잠시 멈춰서 내가 이것을 왜 만드는거지? 라고 질문은 던지는 것은 효과적이다. 더 큰 그림을 보도록 하기 때문이다.
- 몇 가지 예제를 살펴보자. 아래 변수명은 user다. 하지만 user에는 아무런 의미가 없다. `customer`이나 `buyer`는 어떨까?

  ```ts
  let user = authenticate(credentials);
  ```

- 주문에 할인을 적용하는 메서드가 있다.

  ```ts
    public void deductPercent(double amount);
  ```

- 다음과 같이 쓰면 메서드 이름에 의도가 명확하게 드러나고 매개 변수의 타입도 더 명확해졌다.

  ```ts
    public void applyDiscount(Percentage discount)
  ```

- 피보나치 수열의 n 번째 숫자를 계산해야 한다. 메서드 명을 fib로 정했다. 괜찮아 보이지만 호출할 때 `Fib.fib(n)`이 되버린다. 함수 이름을 of나 nth(n번째)로 하면 어떨까? `Fib.of(n), Fib.nth(20)`
- 변수명으로 i, j, k 같은 한 글자 변수명을 쓰지 말라고 강조한다. **`사실 이는 프로그래밍 언어나 환경의 문화에 달린 것이다`**. C 프로그래밍 언어에서는 i, j, k가 전통적으로 반복문에서 증가하는 변수로 쓰여왔다. 문화를 존중하라.
- Order는 온라인 서비스를 제공하는 팀에서는 주문이지만 종교 앱을 만드는 팀에게는 교단일 수 있다. 팀의 모든 사람이 각 단어의 뜻을 알고 일관성 있게 사용해야 한다.

## 프로젝트 전에

### 요구사항의 구렁텅이

- **`요구사항이 땅 위에 놓여 있는 경우는 드물다`**. 보통 가정과 오해, 정치의 지층 속 깊숙이 묻혀있다.
- **`우리들의 일은 사람들이 자신이 원하는 바를 깨닫도록 돕는 것이다`**. 이게 우리의 가치가 가장 빛나는 부분일 것이다.
- 신입 개발자들이 자주 하는 실수는 요구사항을 받으면 바로 해결책을 구현하는 것이다. **`우리의 경험상 최초의 요구 사항은 궁극적인 요구 사항이 아니다`**. 의뢰인의 요청 사항은 사실 함께 탐험을 떠나자는 초대장이다. 여기 좋은 개발자의 협상 능력에 대한 예시를 보자.

  ```
  개발자: 5만원 이상인 모든 주문은 배송비가 무료이군요. 여기에 원래 부과하는 배송비도 포함될까요?
  의뢰인: 물론이죠. 고객이 지불하는 금액 전체를 말하는 겁니다.
  개발자: 고객이 이해하기 쉽고 좋네요. 그런데 일부 비양심적인 사람드링 시스템을 이상하게 사용할 것 같아요.
  의뢰인: 어떻게요?
  개발자: 2만원짜리 책이 있고 당일 배송비가 3만원이라면 결제금액이 5만원이 넘음으로 고객은 2만원만 내면 되겠네요.
  의뢰인: 아이고 그건 의도한게 아닌데. 그럼 우린 손해에요. 어떻게 할 수 있을까요?
  ```

- 우리들의 역할은 의뢰인의 말을 해석해서 그로 인한 영향을 다시 알려주는 것이다. 이 탐험은 지적이고 창의적인 과정이다.
- 프로젝트 막바지가 되면 의뢰인이 늘어난다. QA 사람들, 운영팀, 마케팅까지 모두 의뢰인이 된다. **`그러니 프로젝트 전체를 요구사항 수집 과정으로 보아야 한다`**. 그래서 우리는 짧은 주기로 반복하는 것을 선호한다. 반복 주기가 끝날 때마다 직접 의뢰인에게 피드백을 받으면 우리가 궤도에서 크게 벗어나지 않도록 할 수 있다.

### 함께 일하기

- 짝 프로그래밍이나 몹 프로그래밍을 사용하자. 한 사람이 코드를 입력하는 동안 한 명 혹으 여러 명의 팀 동료가 조언하고 고민하며 문제를 푸는 것이다. 이 방법은 함께 일하는 아주 강력한 방법이다. 그저 질문하고 토론하고 메모하는 것이 아니라 실제로 코딩을 한 와중에 질문을 하고 토론을 하는 것이다.
- 짝 프로그래밍은 몇 가지 장점이 있다. 사람들이 모두 다르므로 다른 경험을 가지고 있고, 문제를 푸는 데도 다른 기법과 접근 방법을 사용한다. **`몇 가지 주의 할점은 아래와 같다`**.
  - 우선 코드를 짜는 거지 자아를 쌓는게 아니다. 누가 가장 똑똑한지 겨루는 게임이 아니다.
  - 소규모로 짝 프로그래밍을 몇 번 해 보는 것으로 시작하자.
  - 코드만 비판하고 사람을 비판하지 말자. 틀렸어 보다는 이 부분을 한 번 볼까요? 하고 시작해라.
  - 다른 사람의 관점을 자주 듣고 이해하려고 노력하자. 다른 것은 틀린 것이 아니다.
  - 자주 회고를 하자. 그래서 다음번에 시도할 때 개선할 점을 찾아라.

### 애자일의 핵심

- **`애자일은 기민하다는 뜻의 형용사다`**. 즉 무언가를 하는 방식이다. 우리는 소프트웨어를 개발하고 다른 사람의 개발을 도와주면서 더 나은 개발 방법들을 찾아가고 있다. 이 과정에서 우리는 다음의 가치를 찾아냈다.
  - 공정과 도구보다 개인과 상호작용
  - 포괄적인 문서보다 작동하는 소프트웨어
  - 계약 협상보다 고객과의 협력
  - 계획을 따르기보단 변화에 대응하기
- 왼쪽에 있는것도 가치가 있지만 오른쪽에 있는 것에 더 높은 가치를 둔다.
- 앞에서 우린 좋은 설계의 척도는 결과물을 얼마나 바꾸기 쉬운지라고 주장했다. 좋은 설계는 나쁜 설계보다 바꾸기 쉬운 결과물을 만든다. 바꾼 것이 마음에 들지 않는다면 가능한 한 고치는 일이 쉬어야 한다. 그렇지 않으면 망가진 채로 놔두고 싶은 유혹에 빠질 것이다. 애자일이 전반적으로 작동하게 하려면 좋은 설계를 만들어야 한다. 좋은 설계는 무언가를 바꾸기 쉽게 만들기 때문이다. 바꾸기 쉽다면 모든 층위에서 아무런 주저 없이 문제를 바로잡을 수 있을 것이다. **`이것이 애자일이다`**.

## 실용주의 프로젝트

### 실용주의 팀

- 실용주의 팀은 작다. 아무도 서로를 모르는 팀은 사실 팀이 아니다. 구성원이 대략 10~12명 이하여야 하고 구성원이 추가되거나 빠지는 일은 드물어야 한다. 모두가 서로 잘 알고, 신뢰하며 의존해야 한다.
- 품질은 팀의 문제다. 아무리 부지런한 개발자라고 해도 품질에 무심한 팀에 배치된다면 열정을 계속 유지하긴 어려울 것이다. 팀 전체가 깨진 창문을 용납하지 않아야 한다. 사소한 결점을 고치지 않고 놔두어서는 안 되고, 제품의 품질에 책임을 져야 한다. 품질은 팀원 모두가 제각기 기여할 때만 보장된다.
- 팀은 개인보다 더 삶은 개구리가 되기 쉽다. 누군가 문제를 처리했겠거니 생각하거나, 변경사항을 팀 리더가 동의했다고 여긴다. 이에 맞서야 한다. 모든 사람이 적극적으로 환경 변화를 감시하도록 권장하라. 범위의 확장, 일정 단축, 추가 기능, 새로운 환경 등 무엇이건 간에 애초에 인지하고 있던 것과 다른 것들을 늘 깨어서 의식해야 한다.
- 할 일을 백로그로 관리하든 업무 도구를 사용하던 기능 개발로 몽따 채우지는 말자. 새로운 기능 외에도 해야 할 일들은 아래와 같다.
  - 구형 시스템 유지 보수
  - 프로세스 회고와 개선
  - 새로운 기술 탐험
  - 학습 및 기술 갈고 닦기
