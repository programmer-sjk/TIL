# 개발자 원칙

## 덕업 일치를 넘어서

- 관리자 역할을 하면서 동기부여 방법이 필요하다고 느껴 여러 책을 읽었는데 한 책에서 교훈을 얻음
  - 책은 사람의 동기를 부여할 수 없다고 선언하고 시작한다. 사람은 저마다 자기만의 동기를 가지고 살고 있고
  외부에서 부여하거나 제어할 수 없다는 것이 그 책의 주장이다. 그래서 각 개인의 동기를 이해하고, 동기에 맞게 일을
  주어야 한다고 가르쳤다.
- 어떤 일을 시작할 때, 그 일을 해야 할 개인적인 의미를 찾아 가능한 강한 내적 동기를 가지고 일하려고 의식적으로 노력함
- 피터 드러커의 프로페셔널의 조건이라는 책을 읽고 개인이 스스로 목표를 설정하고, 이 목표를 달성하려면 자신을 경영해야 한다는 가르침을 깊이 받아들임
- 흔히 좋은 팀워크는 좋은 분위기를 의미합니다. 물론 좋은 분위기는 정말 중요합니다. 하지만 팀워크는 그 이상으로
  1+1이 2 이상이 되도록 만드는 것이 팀워크입니다. 팀워크가 좋은 팀은 의미있는 성과를 지속적으로 내며 더 높은 목표에 도전합니다. 공동의 목표를 위해 협력할 줄 알고, 서로 배우고 가르치며, 개인과 팀 모두 성장합니다.
- 여러면에서 SW 개발자는 독특합니다. 그걸 장인 정신이라고 부를지, 전문가라고 부를지 모르겠지만 사회에 미치는 영향력에 준하는 사명감과 전문 역량과 윤리 의식을 겸비한, 그래서 스스로 자랑스럽고 사람들에게 존중받는 개발자의 모습을 찾고 있습니다.
- 추천한 책
  - 드라이브
  - 테크니컬 리더
  - 프로페셔널의 조건
  - 성공하는 사람들의 7가지 습관
  - 만화로 보는 댄 애리얼리 최고의 선택

## 오류를 만날 때가 가장 성장하기 좋을 때다

- 오류를 만날 때 좌절하지 않고 끝내 해결하고 어떻게 더 나은 개발자로 나아갈 수 있었는지 두 가지 원칙을 소개합니다.
  - 첫 번째 원칙은 오류가 발생하면 소스 코드 레벨에서 이해하자 입니다.
    - centos 5.3 에서 Redis가 컴파일 되지 않아 구글링을 했는데 답을 알 수 없어 직접 해결하기로 마음 먹었고 코드를 확인해 버그를 수정했습니다. 이를 계기로 Redis 컨트리뷰터가 될 수 있었고 Redis를 조금 아는 개발자로 성장하게 되었습니다.
    - 서비스를 운영하다 보면 많은 툴을 사용하고, 많은 에러를 마주치게 됩니다. 해당 오류를 스택오버플로에서 검색하면 대부분 해결책을 얻을 수 있습니다. 하지만 이렇게 단순히 끝내버리면 실제로 깊은 지식을 얻기가 어렵습니다. 한 발 더 나아가 소스 코드를 확인하는 것으로 관련 에러가 왜 발생하는지 해결하려면 어떻게 해야 하는지 같은 깊은 지식을 얻을 수 있습니다.
  - 두 번째 원칙은 알아낸 지식을 글로 공개하라는 겁니다.
    - 소스 레벨에서 이해했다면 결과물로 남기는 것이 중요합니다. 사람의 기억력은 믿을 수 없고 이해했다고 생각하지만 제대로 이해하지 못했을 수도 있습니다. 그래서 이해한 내용을 블로그에 정리하거나 오픈 소스에 기여하여 결과물을 남깁니다. 개발자로 성장하는데 좋은 정보를 입력받는 것도 좋지만 제대로 이해하고 있는지 확이받는 것도 중요합니다. 아예 모르는 것보다 잘못 아는 것이 더 위험합니다. 그러므로 가급적이면 결과물을 공개해 다른 사람의 조언을 들을 기회로 삼길 바랍니다.
- 저자의 경험
  - TCP 서버를 수정했는데 데이터가 느리게 전달되는 상황을 발견함. 동료가 네이글 알고리즘을 언급해 줌 -> 코드에서 네이글 알고리즘을 꺼서 문제는 해결 -> 왜 이 기술이 생겨났는지 고민해보고 RFC 문서를 찾아 읽음
  - 자바 7을 쓰고 있다가 자바 8에서 CPU 사용량이 줄어든다는 소식을 들음 -> 확인해보니 맞음 -> 코드를 분석해서 어떻게 동작하는지 이해함
  - 오픈 소스에 관심이 많을 때 알림봇을 만들다가 line-bot-sdk-python 프로젝트에서 간단한 버그를 발견 -> 로직을 수정해서 Line 깃 허브에 제출 -> 타이밍 공격에 취약하기 때문에 문제가 된다는 피드백 받음 -> 타이밍 공격을 공부해 확실이 이해함 -> 타이밍 공격에 대응하는 코드를 작성해 패치에 반영됨

## 소프트웨어 디자인 원칙

- 프로그램을 작성하는 원칙에 대해 들어봤을 겁니다.
  - KISS(Keep It Simple Stupid): 제발 간단하게 클래스나 메서드를 만들라는 법칙
  - DRY(Do not Repeat Yourself): 반복되는 기능이나 객체를 하나로 만들어 관리하는 법칙
  - YAGNI(You Aint Gonna Need It): 코드를 적어나가다 보면 필요한 기능을 적지만 결국 안 쓴다는 법칙
- 위의 간단한 원칙 외에 도움이 될 자료를 찾다가 OOP에서 많이 회자되는 SOLID 원칙을 만나게 됩니다.
  - SRP: 단일 책임 원칙, 각 클래스는 하나의 정보만을 가지게 만들어야 한다.
  - OCP: 확장에는 열려 있으며 변경에는 닫혀 있어야 하는 개방폐쇄 원칙
  - LSP: 인터페이스의 서브타이핑은 인터페이스에 정의된 형태를 최대한 유지해야 한다는 리스코프 치환 원칙
  - ISP: 인터페이스는 최소한으로 유지하라는 인터페이스 분리 원칙
  - DIP: 상위 레벨의 모듈이 서브 클래스나 타이핑에 영향을 받아서는 안 된다는 의존 관계 원칙
- 좋든 싫든 프로그램 단위의 설계에는 DRY, KISS 같은 원칙을, 더 큰 객체 설계에는 SOLID 원칙을 적용한다면 SW 제품 설계에는 어떤 원칙을 적용해야 할까요?
  - 통합적으로 설계하고, 명시적으로 설계하라. 명시적 설계는 아래 4가지 항목으로 구성된다.
    - 기능, 성능, 유지보수, 미적 설계
  - 암묵적 설계는 비지니스나 기획, 개발에서 실제로 그 일을 수행한다. 명시적 설계는 4가지 요소를 고려했으나 암묵적 설계에는 13가지 요소를 고려해야 한다.
    - 서비스 지속성 설계
      - 가용성, 용량, 연속성, 보안
    - 서비스 전환 설계
      - 변환 설계, 릴리즈 설계, 설정 관리 설계
    - 서비스 운영 설계
      - 장애 대비 설계, 요구 수행 설계, 문제 대응 설계
    - 서비스 개선 설계
      - 서비스 리포팅, 서비스 측정, 서비스 레벨
