# 육각형 개발자

- [책 링크](https://product.kyobobook.co.kr/detail/S000203107475)

## 들어가며

### 개발이란

- 사회 초년생일 때는 **`구현 기술을 사용해 코드를 작성하는게`** 개발이라고 생각했다.
- 년차가 쌓이니 **`고객의 요구를 파악하고 원하는 것을 충족하는 기능을 만드는게 개발이었다`**.
  - 어떤 기술을 사용하기 위해 or 특정 개인의 이력 관리를 위해 시작한 프로젝트는 별다른 결과 없이 사라지곤 했다.
- 회사 업무를 하면서 성장한다는 느낌을 받지 못한 이유는 **`개발과 성장을 동일시했기 떄문이다`**.
  - 익숙해진 회사의 개발 업무로는 더 이상 성장할 수 없다고 생각했다.
  - 현재 사용하는 기술에만 멈춰 있으면 뒤처진다고 생각했고 새로운 기술만 쫓게 되었다.

### 개발에 필요한 것

- 이 책에서는 **`아래 역량을`** 이야기 할 것이다.
  - 구현 기술
  - 설계 역량
  - 업무 관리와 요구 분석 & 공유 & 리드/팔로우
- 처음에 구현 기술을 학습하고 이후에 새로운 구현 기술을 익히거나 알고 있는 기술을 발전시키는 노력을 등한시 하는 개발자가 있는데 **`이런 자세로는 좋은 시니어 개발자가 될 수 없다`**.
- 설계는 서비스 경쟁력에 직결되기 때문에 중요하다.
  - 단기간에 늘지 않기 때문에 기본적으로 다양한 경험을 쌓아야 한다.
  - 상황에 따라 알맞은 설계 구조를 선택할 수 있어야 한다. 이렇게 하려면 여러가지 **`설계 기법을 평소에 꾸준히 학습하고 익혀야 한다`**.

## 구현 기술과 학습

### 학습 대상

- 개발자가 익혀야 할 구현 기술이 너무 많다 보니 **`학습할 대상을 잘 선택해야`** 한다.
- 학습하려고 하는 구현 기술을 정할 때 다음 **`2가지 기준을`** 적용하면 좋다.
  - **`현재 사용중인 기술`**
  - **`문제를 해결하기 위한 기술`**
- **`현재 사용하는 기술은 당연히 학습해야 한다`**. 지금 당장 잘 활용하는 것이 중요하기 때문이다.
  - 현재 사용하는 기술이 본인의 취향과 맞지 않더라도 코드를 이해하고 수정할 수 있을 정도의 지식은 있어야 한다.
  - 사용 중인 기술을 학습할 때는 처음부터 완벽하게 익히려고 하지 않아도 된다.
  - 기술의 일부 요소만 사용하므로 필요한 부분만 알고 있으면 일반적인 기능을 개발하는데 문제없을 것이다.
- **`문제를 해결하기 위한 기술에는`** 다음 두 가지가 있다.
  - 당장 해결해야 하는 문제
  - 가까운 미래에 해결해야 하는 문제
- 문제가 눈앞에 닥쳤을 때 즉시 알맞은 구현 기술을 찾는 건 쉽지 않다.
  - 그래서 문제 해결 능력을 향상하기 위해 **`평소에 구현 기술을 찾아 학습해야 한다`**.

### 기술 파기

- **`익혀야 하는 기술은 많고 모든 기술을 깊게 파기는 어려운데`** 어떻게 하면 좋을까?
  - 처음 접하는 기술은 핸즈온이나 동영상 강의, 튜토리얼 문서로 빠르게 감을 잡아야 한다.
  - 핸즈온이나 튜토리얼 문서는 입문자가 기술의 전반을 몰라도 빠르게 기술의 동작을 경험하게 해준다.
  - 일상 업무를 개발할 수준까지 기술을 익혔다면 필요할 때 마다 기술을 조금씩 더 깊게 학습한다.
- 예전에는 내가 사용하는 기술의 내부 동작 원리도 알아야 한다고 생각했지만 지금은 그렇지 않다.
  - 알아야 할 기술이 많기에 내가 사용하는 모든 기술을 처음부터 깊게 알기란 어렵다.
  - **`기술을 깊게 이해해야 하는 순간이 있고`**, 이때 시간을 더 들여 깊은 지식을 학습하고 연습하면 된다.
- **`중요한 건 더 나은 방법을 찾으려고 노력해야 한다는 것이다`**. 기존 방법만 답습하면 기술 역량을 높일 기회는 찾아오지 않는다.

### 학습 전략

- 유행하는 기술의 흐름이 자주 바뀌다 보니 **`전략적으로 구현 기술을 학습할 필요가 있다`**.
- 일단 **`주력 기술을 집중적으로`** 학습해야 한다.
  - 주력 기술이란 당장 또는 가까운 미래에 경제적 이익을 얻는데 필요한 기술을 말한다.
  - 시장 점유율이 높다면 그 기술을 익혀야 유리하다.
  - 현재 대세인 기술을 학습할 필요는 있지만 모든 대세 기술을 알 필요는 없다.
    - 본인의 업무를 수행하는데 필요한 기술을 집중적으로 익혀야 한다.
- 어떤 기술에 흥미가 생겨 열심히 학습할 수는 있다.
  - 하지만 그 기술을 자신의 주력 기술로 삼을지는 고민해야 한다.
  - 개인 프로젝트는 괜찮지만 회사 업무에는 여러 이유로 적용하기 어려울 수 있다.
- 여러 **`기술을 꾸준히 탐색할 필요도 있다`**.
  - 어떤 기술이 주목받고 있는지 조사하고 필요에 따라 핸즈온이나 별도 학습으로 빠르게 경험해야 한다.
  - 왜 주목받는지 이해하려 노력하면 언젠가 그 기술을 적용하려 할때 수월해질 것이다.
  - 또한 이런 노력들이 개발자로서 미래 경쟁력을 유지할 수 있다.
- 좋은 시니어 개발자가 되고 싶다면 **`구현 기술을 주기적으로 탐색하고 학습해야 한다`**.
  - 구현 기술 학습에는 끝이 없다. 계속해서 새로운 기술을 익혀야 함을 잊지 말자.

### 유행에 상관없는 구현 기술

- 저자는 동시성 문제로 뉴스에 나올만큼의 대형사고를 겪은 적이 있다.
- **`유행하는 기술만 좇다보면`** 동시성 처리, 네트워크 문제, SQL 인덱스 같은 **`기초 지식을 놓치기 쉽다`**.
  - 주니어 개발자라면 유행과 상관없는 지식을 1년에 1개 이상 학습하자.
  - HTTP 프로토콜, 네트워크 프로그래밍 기초, 동시성 처리, 사용하는 프로그래밍 언어.
  - 유행에 상관없이 개발의 **`기초 지식을 꾸준히 학습해야 기본기가 튼튼한 개발자로`** 성장할 수 있다.

### 구현 기술 적용

- **`어떤 기술을 도입할때는`** 부수적으로 고민하고 다음 내용을 신경써야 한다.
  - 신뢰 구축
  - 함께할 동료
  - 타당성
  - 점진적 저용
  - 시장 상황
- 본인이 책임자라면 **`입사한지 얼마 안 된 팀원이 제안한 새로운 기술을`** 선뜻 적용할 수 있는가?
  - 다른 구성원의 공감을 얻기 위해서는 자신의 역량을 증명해야 한다.
  - 자기 업무도 제대로 처리 못한 상태에서 어떤 의견을 제시해봤자 불만만 토로하는 사람으로 보인다.
  - 먼저 기존 시스템을 이해하고 주어진 일을 잘 수행해야 동료에게 신뢰를 얻을 수 있다.
  - 어떤 조직도 처음부터 날 믿어주지 않는다. 동료에 신뢰를 얻기까지 보통 3개월 ~ 1년정도 걸린다.
  - 조직에 변화를 주고 싶다면 그만큼 인내도 필요하다.
  - **`신뢰가 쌓여야 내 주장에 힘이 실린다`**. 이 점을 잊지 말자.
- 새로 적용하고자 하는 기술에 대해 논의하고 공감대를 형성할 수 있는 동료가 꼭 필요하다
  - 혼자서는 아무것도 할 수 없다. 아니 하면 안된다.
  - 내가 맞다고 생각하는 의견에 공감해 줄 동료가 없다면 내 제안은 그저 고집일 수도 있다.
  - **`변화는 언제나 힘든 과정이다`**. 1~2개월 내 승부를 보겠다는 마음은 버려야 한다.
    - 계속해서 내가 제안한 변화에 수긍할 수 있도록 인내심을 갖고 소통해야 한다.
- 익숙하지 않은 **`기술을 적용해야 하는 이유가 타당해야 한다`**.
  - 웹플럭스가 유행할 때 유행에 민감한 많은 개발자가 API 구현 기술로 웹플럭스를 검토했다.
  - 도입하려는 이유를 물어보면 성능을 말하지만 어떤 성능을 높이기 위해 도입하는지 물어보면 명확하게 대답해주는 사람은 별로 없었다.
  - 본인이 사용하고 싶은 욕구를 숨기고 기술의 장점만 내세워 기술을 도입해야 한다고 주장하는 사람들을 많이 봤다.
  - **`조직이 처한 상황과 조건이 부합할 때`** 새로운 기술을 적용해야 그 기술의 장점이 빛을 발한다.
- 새로운 기술은 점진적으로 적용하자.
  - **`한번에 다 바꾸겠다는 생각은 위험하다`**.
  - 중요하지 않은 기능과 시스템에 먼저 적용해서 안정섬을 검증해야 한다.
  - ORM 도구를 도입하던 초기에도 ORM을 제대로 이해하지 못하다 보니 성능 문제를 겪는 프로젝트가 많았다.
- 시장 상황을 고려하자.
  - 도입하려는 기술에 능숙한 인력을 원활히 채용할 수 있어야 한다.

### 주의할 점

- 특정 기술을 사용해야 우월하다는 생각을 가진 개발자를 마주칠 떄가 있다.
  - 특정 기술을 사용한다고 우월한 것도 아니고 오래된 기술을 사용한다고 열등하다고 할 수 없다.
  - **`구현 기술은 단지 구현 기술일 뿐. 구현 기술을 맹종하지 말자`**
- 한 명의 개발자가 모든 것을 잘 할 필요는 없다.
  - 모든 기술을 능숙하게 다루겠다는 마음보다는 특정 기술을 잘 사용하자는 의지가 더 낫다.
  - 물론 잘 다루고 싶은 구현 기술은 더 깊게 학습하고 연습하면서 구현 실력을 갈고 닦아야 한다.
- 불나방처럼 이 기술 저 기술 다 잘하겠다고 덤비면 안 된다.
  - 미래 경쟁력을 위한 기술을 탐색하면서 필요할 때 더 깊게 학습하면 된다.

## SW 가치와 비용

### 개발 비용

- 서비스를 출시하고 시간이 흐를수록 개발 비용이 증가하는 문제를 많은 기업이 겪고 있다.
- 제품 경쟁력을 갖추려면 사용자를 만족시키는 기능을 빨리 내놓아야 하는데 개발 시간이 증가하니 경쟁력이 떨어진다.
- 우선 서비스가 출시되면 **`서비스 유지보수에 계속 비용이 들어간다`**.
- 개발자는 흔히 기존 `코드를 바꾸는 것보다 새로 만드는게 빨라요`란 말을 한다.
  - 이는 유지보수 비용과 관련이 있다.
  - 간단한 기능조차도 처음 만드는 것 보다 나중에 만드는게 개발 시간이 몇배에서 수십 배 이상 소요된다.
- SW를 제때 변경하고 싶다면 **`유지보수 비용을 낮출 수 있는 방법을 찾아야 한다`**. 그래야 경쟁력을 높일 수 있다.

### 유지보수 비용을 낮추려면

- 버그를 수정할 때 원인을 찾는 시간이 더 오래 걸릴 때가 많다.
  - 1시간 이상 코드를 분석했는데 실제 수정은 2분만에 끝나는 방식
- 다른 이유가 있을 수 있지만 **`코드와 설계 품질이 코드 수정 시간에 많은 영향을 준다`**.
- 어떤 논문은 **`코드 품질이 나쁠때`** 평균 개발시간이 1.2배 최대 개발시간은 9배 가까이 차이가 났다.
- 유지보수에 들어가는 개발 비용을 낮추려면 품질을 신경써야 한다.
  - 코드 가독성을 높이고 전형적인 패턴 사용, 요구에 알맞은 아키텍처를 적용하면 유지보수 비용을 줄일 수 있다.
- 시니어 개발자로 성장하기 위해서는 유지보수와 비용에 대해 고민해야 한다.
  - 단순히 어떤 기술과 아키텍처가 유행한다고 선택하면 안된다.
  - 선택에 따른 장,단점을 따져 SW 가치를 안정적으로 높일 수 있는 방법을 선택해야 한다.

## 코드 이해

### 코드 변경

- 개발자가 코드를 변경하기 위해 **`코드를 읽는 시간은 얼마나 될까`**?
  - 일반적으로 코드를 이해하는 데 개발 시간의 60%를 사용한다.
  - 버그 수정과 같은 코드를 이해하는데 90% 이상의 시간을 쏟기도 한다.
  - 이처럼 코드를 이해하는 시간이 더 소요되기 때문에 **`코드를 이해하는 작업은 유지보수 하는 데 매우 중요하다`**.
- 코드를 이해하는 시간을 줄이기 위해서는 2가지 역량이 요구된다.
  - 당연하게도 코드를 제대로 이해할 수 있는 역량이다.
  - 이해하기 쉬운 코드를 작성하는 역량이다.
- 품질이 낮은 스파게티 코드를 이해하기 위해서는 품질이 좋은 코드보다 40% 정도 더 많은 시간이 소요된다고 한다.
- 결과적으로 **`이해하기 좋은 코드를 만들면`** 코드를 이해하는데 들어가는 시간을 줄일 수 있고 개발 시간도 줄어든다.

### 이해하기 좋은 코드

- 이해하기 좋은 코드는 코드 분석에 필요한 노력을 줄여준다.
- 이해하기 좋은 코드를 만들 때 **`가장 중요한 것은 가독성이다`**.
- 저자는 이해하기 좋은 코드를 작성하는 방법을 알려주는 책으로 두 권을 뽑았다.
  - `켄트 백의 구현 패턴`
  - `클린 코드`

#### 이해를 돕는 몇 가지 코드 작성법

- **`이름`**
  - 이름은 코드 가독성에 큰 영향을 준다.
  - 이름은 짧을 수록 좋지만 사용 범위가 넓다면 서술적인 이름을 사용해야 한다.
  - 클래스 이름이 맥락을 제공하기 때문에 필드 이름은 짧아도 의미가 잘 전달된다.
    - `ex) Member class에 memberName 대신 name 필드 제공`
- **`중첩 if문 최소화`**
  - if 구조가 복잡할 때 if 조건을 역으로 바꾸면 else가 없다는 사실을 알 수 있다.
  - 기억할 범위도 좁아지고 코드 들여쓰기가 줄어들어 복잡도가 낮아진다.
- **`변수 줄이기`**

  - 변수는 함수 시작 부분에 선언하지 않고, 사용되기 직전에 정의하자
  - 같은 변수가 타입이 같다고 여러 의미로 사용하지 말자.
    - ex) result 변수가 성공, 실패 용도로 사용하다가 처리 개수를 저장하는 식
  - 변수가 재사용되지 않고 값이 명확하다면 변수 자체를 줄여야 한다.
  - 반대로 어떤 의미를 부여할때 변수를 사용하면 도움이 된다.

    ```ts
      // 변수 없는 경우
      checkLimit(thisYear - member.getBirthYear())

      // 변수에 담아 전달
      int age = thisYear - member.getBirthYear();
      checkLimit(age);
    ```

- **`값 변경 최소화하기`**
  - 변수 값이 중간에 계속해서 바뀌면 변수 값을 추적해야 한다는 부담이 생긴다.
  - 변수의 값이 바뀌지 않는다면 쉽게 코드 동작을 유추할 수 있기에 변수 변경은 가능한 최소화해야 한다.
- **`길지 않은 코드와 추상화하기`**

  - 긴 코드보다는 짧은 코드가 분석하기 쉽다. 아래 코드를 보자.

    ```java
    public void save(SaveRequest req) {
      if (!StringUtils.hasText(req.getId()))
        throw new IllegalArgumentException('id 필수');
      if (!StringUtils.hasText(req.getName()))
        throw new IllegalArgumentException('name 필수');
      if (!StringUtils.hasText(req.getEmail()))
        throw new IllegalArgumentException('email 필수');

      Long seq = repository.createSeq();
      Member member = Member.builder()
        .seq(seq)
        .id(req.getId()).name(req.getName()).email(req.getEmail())
        .createdAt(LocalDateTime.now())
        .build();
      repository.save(member);
    }
    ```

  - 위 코드를 아래와 같이 줄여보자

    ```java
    public void save(SaveRequest req) {
      validate(req);
      Member member = create(req);
      repository.save(member);
    }

    private void validate(SaveRequest req) {
      if (!StringUtils.hasText(req.getId()))
        throw new IllegalArgumentException('id 필수');
      if (!StringUtils.hasText(req.getName()))
        throw new IllegalArgumentException('name 필수');
      if (!StringUtils.hasText(req.getEmail()))
        throw new IllegalArgumentException('email 필수');
    }

    private Member create(SaveRequest req) {
      Long seq = repository.createSeq();
      return Member.builder()
        .seq(seq)
        .id(req.getId()).name(req.getName()).email(req.getEmail())
        .createdAt(LocalDateTime.now())
        .build();
    }
    ```

  - `save()` 메서드는 **`코드가 길지 않기 때문에 전반적인 흐름을 빨리 이해할 수 있다`**.
  - `save()` 메서드의 상세한 구현은 알 수 없지만 대략 데이터 검증 후 Member 객체를 생성해 저장하는 것을 알 수 있다.
  - 자세한 구현이 궁금하면 각 메서드로 이동한다.

## 응집도와 결합도

### 응집도

- **응집도**는 관련 요소가 얼마나 **`한 모듈에 모여있는지`** 나타낸다.
  - 작게는 메소드, 함수 수준부터 크게는 프로세스 수준까지 모든 수준에서 응집도를 판단할 수 있다.
  - 관련 **`코드가 한 곳에 모여있으면 응집도가 높다고`** 표현하고 반대로 **`관련 코드가 분산되어 있다면 응집도가 낮다고`** 표현한다.
- 왜 응집도를 높여야 할까?
  - 응집도는 결국 **`수정 비용과 관련이 있다`**.
  - 응집도가 높다면 관련 코드가 한 곳에 모여 있게 되며 자연스럽게 클래스가 분리되고 클래스의 길이가 줄고 가독성이 좋아진다.
  - 응집도가 높다면 기능 변경 시, 수정할 범위도 줄어든다. 여러 클래스를 수정하지 않고 한 클래스만 수정할 수 있다.
- 응집도는 역할 또는 책임과 관련이 있다.
  - 회원 관련 타입이 member 패키지에 있고 회원가입과 회원 승인 기능을 각각 `MemberRegisterer`, `MemberApprover` 클래스로 구현했다고 하자.
  - 회원 가입 로직을 변경하려면 `MemberRegisterer`만 수정하면 된다.
  - 회원 승인 기능을 변경하려면 `MemberApprover`만 수정하면 된다.
  - 이처럼 각 클래스를 수정하려는 이유가 각각 하나씩이다.
- **`단일 책임 원칙은`** 한 클래스는 하나의 책임만 가져야 한다는 원칙이다.
  - 다르게 말하면 클래스를 수정할 이유는 하나여야 한다는 것이다.
  - 응집도를 높이면 역할에 따라 구성 요소를 나눠야 하는데, 각 구성 요소를 수정할 이유가 줄게 된다.
  - 즉 **`응집도가 높아지면 단일 책임 원칙을 따를 가능성이 올라간다`**.

### 결합도

- **결합도**는 **`SW 모듈이 서로 의존하는 정도이다`**.
  - 한 모듈을 수정할 때 다른 모듈도 수정해야 한다면 두 모듈은 결합도가 높다.
  - 반대로 한 모듈을 수정할 때 다른 모듈을 수정하지 않아도 되면 결합도가 낮다.
- 수정할 대상이 많아지면 코드 분석과 수정에 드는 시간이 증가한다.
  - 즉 결합도가 높아지면 유지보수 비용이 증가한다.
  - 따라서 수정 비용을 낮추기 위해 응집도는 높이고 결합도는 낮춰야 한다.
- 응집도가 높다고 해서 반드시 결합도가 낮아지는 것은 아니다.
  - 응집도를 높이기 위해 코드를 역할에 따라 분리하면 분리된 요소간에 의존성이 발생해 결합도가 증가한다.

## 리팩토링

### 수정 공포와 변경 비용

- 레거시는 **`오래 되었지만 여전히 사용되고 있는 코드를`** 말한다.
- 아래 상황에서 코드 수정은 매우 두려운 일이다.
  - 레거시 수정 요청이 들어온다. 기존 코드를 분석해야 하지만 항상 일정상 여유가 없다.
  - 코드를 완벽히 이해하지 못한 상태인데 테스트 코드도 없어서 수정한 코드가 기존 기능에 어떤 영향을 끼칠지 알 수 없다.
- **`우리는 누구나 레거시를 만든다`**. 내가 만든 코드라도 수정하기 두렵다면 그게 바로 레거시다.
- 레거시는 폄하 대상이 아니고 모든 코드에는 나름의 사정이 있다. 그러니 레거시를 만나면 다음처럼 생각해보자.
  - **개선할 거리가 있다. 해보자!**

### 리팩토링

- 리팩토링은 외부로 드러나는 동작이나 기능은 변경하지 않고 **내부 구조를 변경하는 기법**이다.
- 리팩토링에는 다양한 기법이 있는데 많은 기법과 과정이 궁금하면 `마틴 파울러`가 쓴 `리팩터링 2판`을 읽어보자.
- 매직 넘버

  - 값을 갖는 숫자를 **매직 넘버**라고 표현하한.
  - 매직 넘버는 그 값이 무엇을 의미하는지 유추하기 어렵게 만든다.

    ```ts
    if (NumberUtils.anyMatch(boilerType, 19, 20)) return true;

    // 더 이해하기 쉽다.
    if (NumberUtils.anyMatch(boilerType, GAS_BOILER, INDUSTRIAL_BOILER))
      return true;
    ```

- **`이름 변경`**
  - 이름은 짧을수록 좋지만 **`너무 짧아 의미가 생략된다면 차라리 긴 이름이 낫다`**.
- **`메서드 추출`**
  - 메서드 추출을 잘 활용하면 코드 가독성이 높아지고 관련 코드가 한 곳에 모이면서 코드가 더 응집된다.
  - 무조건 메서드 추출을 하면 안되고 가독성이나 응집도가 좋아지는 방향으로 메서드를 추출해야 한다.
- 클래스 추출, 클래스 분리, 메서드 분리
- **`파라미터 값 정리`**
  - 메서드에서 사용하지 않는 파라미터 데이터는 제거해야 한다.
  - 사용하지 않는 파라미터는 코드 분석을 어렵게 만들기 때문이다.
- **`for에서 하는 2가지 일 분리`**

  - 하나의 for문에서 여러 작업을 실행하면 서로 다른 목적을 가진 코드가 섞일 수 있다.
  - 이는 코드 복잡도가 증가하고 코드를 이해하기 어려워진다.
  - for 문이 복잡해지지 않게 방지하는 방법으로는 **`for 루프가 1개의 일만 하도록 수정하는`** 것이다.
  - 아래 코드를 보자

    ```java
      for (InvoiceDto invoice: invoices) {
        ApprovalRes res = payGwApi.approve(...) // 결제시도
        paymentService.saveAfterApproval(res) // 결제 성공 결과 반영
        StoreApiDto dto = // 성공 dto 생성
        dtoList.add(dto)
      }
    ```

  - 위 코드는 결제 시도후 결과 반영 & 외부에 전달 할 dto 객체 생성이란 두 가지 작업을 한다.

    ```java
      // 결제 시도 및 결과 생성, 내부에 for문 있음
      List<InvoiceResult> results = approveInvoices(invoices);

      // 외부 시스템에 결제 결과전송, 내부에 for문 있음
      sendInvoiceResultsToStore(results);
    ```

  - for 문이 하는 일을 논리적인 단위로 분리한 덕분에 코드가 이해하기 쉬워졌다.
  - **루프를 한 번만 돌면 되는데** 여러번 돌게 되면 성능이 느려진다고 걱정하는 개발자도 있다.
    - 하지만 미리 걱정할 필요는 없다. 대부분 성능에 문제가 없고 문제가 될 때만 측정해서 개선하면 된다.
    - **`복잡한 코드보다 이해하기 좋은 코드가 주는 이점이 훨씬 크다`**.

## 테스트

### 자동화 된 테스트 & 회귀 테스트 & 안정감

- 자동으로 실행할 수 있는 테스트 코드가 있다면 수정한 코드가 발생시키는 문제를 빨리 찾을 수 있다.
- 사람이라면 몇 시간 이상 검증해야 할 기능을 기계는 단 몇분이면 할 수 있다.
- 테스트 커버리지가 높을수록 수정한 코드가 문제를 일으키지 않을 거란 확신도 커진다.
- 수정한 기능 외에 **`기존 기능이 영향 없는지 검증하는 테스트를 회귀 테스트라`** 부른다.
  - 자동화된 테스트 자체를 회귀 테스트로 사용할 수 있기 때문에 테스트 효율성을 높일 수 있다.
- 민감한 기능일수록 코드를 수정하는데 부담이 커진다. 이런 부담을 줄일 수 있는 방법의 하나가 테스트 작성이다.

### 테스트 주도 개발과 생산성

- 테스트 코드를 작성하는 일이 생산성이 떨어진다고 느낄 수 있다. 단편만 보면 사실이다.
- **`전체 개발 관점에서 바라보면`** 얘기가 달라진다.
  - 개발자가 코드를 수정하면 로컬이든 개발 서버에서든 테스트를 해야 한다.
  - 테스트하다 오류가 발생하면 이 과정을 반복한다.
  - 로직이 복잡할수록 과정이 반복될 수 있고 결과적으로 개발 시간을 증가시킨다.
- 결국 **`전체 개발 시간을 줄이려면 테스트 코드를 만들어야 한다`**.
- 테스트 코드를 작성하면 처음에는 개발 시간이 늘어나지만 시간이 갈수록 반복되는 테스트 시간을 줄여줘서 오히려 개발 시간이 줄어든다는 것을 알 수 있다.

### 테스트 가능성

- 코드를 만들 때 테스트 가능성을 염두에 두면 **`설계 품질을 올릴 수 있다`**.
- 어떤 함수가 외부 API로 카드 상태를 확인 하고 카드를 저장한다고 가정하자.
- 테스트가 통과하도록 하려면 외부 연동 코드를 별도로 분리해서 주입받아야 한다.
  - mock으로 외부 연동 코드를 주입받아 카드를 저장하는 함수만 테스트가 가능하다.
- 테스트 가능성이 높아지면 **`외부 환경에 대한 의존이 줄어들어 전체가 아닌 일부만 테스트할 수 있게 된다`**.
- 테스트 가능성을 높이는 과정에서 역할에 따라 타입이 분리되며 응집도가 올라가고 전반적으로 설계 품질이 좋아지게 된다.

## 아키텍처 & 패턴

- 주니어와 시니어 개발자를 구분 짓는 요소 중 하나로 **`아키텍처 설계 역량을`** 꼽을 수 있다.

### 아키텍처 고민하기

- 아키텍처를 고민할 때는 크게 2가지를 고민해야 한다.
  - 하나는 `기능 요구 사항`, 다른 하나는 `품질 속성(비 기능 요구사항)`이다.
- **`기능 요구사항은`** SW가 해결하고자 하는 문제와 관련이 있다.
  - 학습 서비스라면 기능 요구 사항으로 수강 관리, 학습 진도 추적, 성취도 평가 등이 해당한다.
- 기능 요구 사항은 **`아키텍처에 영향을 준다`**.
  - 학습 진도를 어디까지 추적할지에 따라 연동 방식이 달라진다.
  - 성취도 평가를 실시간으로 계산할지 일 단위로 계산할지에 따라 구조가 달라진다.
- 일부 `품질 속성`은 명시적으로 요구사항에 드러난다.
  - 대표적으로 **`성능과 확장성이`** 있다.
  - 보통 요구 사항 문서에 최대 사용자 수, 최대 트래픽 같은 형태로 성능과 확장성을 언급한다.
- 품질 속성의 다른 예시는 도메인마다 법이라던지, 요구 사항에 없더라도 가용성, 인증, 인가 등이 해당한다.

### 트레이드 오프

- 품질 속성을 높이면 시스템 복잡도가 증가한다.
  - 응답 속도를 높이기 위해 메모리 캐시를 도입하거나 DB를 수평확장 하면 아키텍처는 복잡해진다.
- 품질 속성 중 가용성을 높이기 위해 이중화하면 비용이 올라간다.
- 품질 속성을 높이면 복잡도와 비용이 증가하기 때문에 **`그때그때 다르다는 아키텍처에도 적용된다`**.
- 감당할 수 있는 복잡도, 인프라 비용, 최소 품질을 고려해서 아키텍처를 결정해야 한다.
  - 모든게 완벽한 아키텍처가 아닌 **`가장 나쁘지 않은 아키텍처를 선택해야 한다`**.

### 아키텍처가 중요한 이유

- 시스템이 커질수록 **`전체 시스템 설계가 개별 구현보다 중요해진다`**.
- 만드려는 시스템에 따라 적합한 아키텍처가 존재한다.
  - 데이터 일관성이 중요한 아키텍처와 채팅 시스템을 위한 아키텍처는 다르다.
  - 마이크로 서비스는 탄력성, 배포 가능성, 장애를 분산할 수 있지만 데이터 무결성을 위한 구조는 복잡해진다.
- 시스템 규모가 작으면 아키텍처의 중요성은 상대적으로 떨어지지만 **`시스템 규모가 크다면 아키텍처를 신중히 결정해야 한다`**.

### 아키텍처 변경

- 스타트업 개발자는 처음 **모놀리식 아키텍처**로 개발을 진행했다.
  - 사용자가 늘면서 트래픽이 늘고 간헐적으로 응답이 느려지거나 DB의 CPU도 70%넘길때가 있었다.
- 모놀리식 시스템은 많은 기능을 갖게 되는데 기능에 따라 일정 수준의 처리량을 제공하거나, 순간적으로 증가하는 트래픽을 대응할 수 있어야 한다.
  - 이런 경우 서비스를 분리해서 수평 확장하거나 동기 연동을 비동기 연동으로 바꿀 수 있다.
- **`아키텍처 변경은 반드시 필요성에 기반해`** 이루어져야 한다.
  - 아키텍처 변경에는 많은 시간과 노력이 따르기 떄문에 신중히 고려해야 한다.

### 패턴 익히기

- 설계하다 보면 이전에 만든 구조가 떠오르는데, **`특정 맥락에서 반복되는 문제 해결법을 패턴이라 부른다`**.
- 아키텍처 패턴, 디자인 패턴, 결함 허용 패턴 등 여러 수준에서 다양한 패턴이 있다.
  - `아키텍처 패턴`: 포트 & 어댑터 아키텍처, 마이크로 서비스 아키텍처, 이벤트 기반 아키텍처
  - `디자인 패턴`: 싱글턴, 팩토리 등등
  - `결함허용 패턴`: 에러 복구, 에러 완화, 하트비트, 서킷 브레이커 등
- 패턴은 설계 시간을 단축해주고 이름만 말해도 원활하게 소통을 도와준다.
- 한 번에 모든 패턴을 학습할 수는 없지만 주기적으로 새로운 패턴을 익혀보자.

## 업무 관리

### 업무 나누기

- 개발 규모가 커졌을 때 흔히 하는 **`실수 하나가 생각나는 대로 개발하는 것이다`**.
- 작은 일은 체계적으로 진행하지 않아도 일을 완료할 수 있다.
- 반면 일의 규모가 커지면 먼저 어떤 일부터 해야 할지 업무를 나눠보자.
  - `설문 조사 시스템` 업무를 진행한다면 아래와 같이 나눌 수 있다.
    - `요구사항 분석 -> 개발 계획 -> 설계 -> 개발 -> QA`
- 예정대로 일이 진행되지 않으니 개발 계획을 짜는데 시간을 들일 필요가 없다고 생각할 수 있다.
  - 하지만 일의 규모가 커지면 개발 계획은 반드시 세워야 한다.
  - 계획이 있어야 진행 상태를 파악하고 변화에 대응하며 조정 할 수 있다.
- 추정은 정확하지 않다. 요구사항을 완벽하게 분석한 상태에서 추정한 것이 아니기 떄문이다.
  - 물론 요구사항을 완벽히 분석한 뒤에 추정해도 정확하지 않다.
  - 그래서 **`추정할 때는`** 빡빡한 추정치를 사용하기 보다는 **`약간의 여유 시간을 포함해서 추정해야 한다`**.
- 개발 뿐만 아니라 다른 일을 할 때도 **`규모가 크면 작은 일로 나눠야 한다`**.

### 완료의 의미

- 신입 때 흔히 잘못 파악하는게 완료의 의미다. `거의 다 했어요`라는 **거짓말은 오해를 만든다**.
- 생각했던 코드를 작성했다고 완료되는 것은 아니다. **`기대한 대로 동작할 때 비로소 완료된다`**.
- 즉 본인이 작성한 코드가 동작하는 결과를 거쳐야 구현이 완료되고 이때 비로서 **`거의 다 했어요`** 라는 표현을 할 수 있다.

### 요구사항은 바뀐다

- 개발자는 요구사항이 바뀌는 것을 싫어한다. **`하지만 요구사항은 바뀌게 되어 있다`**.
- 요구 사항이 바뀐다는 사실을 인정하고 **`요구사항의 변화를 줄이는데 초점을 맞춰야 한다`**.
  - 요구사항의 변화를 줄이려면 **`왜 이런 요구 사항을 원하는지 이해하려는 노력이 필요하다`**.
  - 요구 사항은 주로 비 개발자가 본인이 이해하는 수준에서 요구한다.
- 요구 사항이 현재 시스템의 한계로 구현이 어렵거나 논리적으로 이해가 안 된다면 개발자는 그저 해달라는 대로 해주면 안된다.
  - 왜 그런 요구를 했는지 이유를 들어보고 특정 기능을 요구한 이유를 듣다 보면 더 나은 방식이나 다른 대안이 떠오르기도 한다.
  - 즉 **`정확한 요구사항의 이해는`** 기능을 구현하는 도중 **`요구 사항이 바뀔 수 있는 가능성을 줄여준다`**.
- 결국 우선순위 문제이다.
  - 요구사항을 제시한 **`관계자는 모든 요구사항이 중요하다고 말한다`**.
  - 하지만 **`일정과 비용을 맞닥뜨리면`** 이야기가 달라진다.
  - 관계자가 반드시 넣어야 했던 기능은 꼭 구현하지 않아도 되는 기능으로 바뀌거나 요구 조건의 복잡도가 단순해질 수 있다.
  - 일정과 비용은 개발 범위를 결정할 때 강력한 기준이 될 수 있다.
- 개발자는 SW를 만들어 요구 사항을 해결해 주는 사람이다.
  - 처음부터 일정과 비용을 언급하지는 말고 왜 그런 요구를 하는지 이유를 들어보자.
  - 대안이나 우선 순위에 대해 논의해보고, 그럼에도 요구 사항 협의가 안되면 그때 일정과 비용을 언급하자.

### 일정

- **`언제까지 되나요?`** 는 아마 개발자가 가장 듣고 싶지 않은 질문 중 하나일 것이다.
- 업무 나누기에서 언급했듯이 먼저 작업량이 얼마나 될지 추정하고, 추정치를 바탕으로 개발 기간을 산정해야 한다.
- 작업량을 산정할 때는 **`아래 사항을 주의해야 한다`**.
  - 본인 능력 과신
  - 운영 업무 시간
  - QA 시간
- 작업량을 산정할 때 본인의 능력을 과신하지 말자.
  - 요구사항이 명확하지 않은 상태에서 추정할 때가 많기에 약간의 여유 시간이 더 필요하다.
- 운영하는 시스템의 유지보수에 드는 시간을 잊으면 안 된다.
  - 운영중인 시스템에 문제가 생기면 반나절 이상 문제를 해결하는데 시간을 쓸 수도 있다.
- 목표 일정이 최상위 임원에게 보고되면 일정을 변경하기 어렵게 된다. 완료 날짜가 다가오면 더 그렇다.
  - 그러니 일정 변경이 필요하다면 미리미리 상급자에게 보고해야 한다. 그래야 대안을 준비할 수 있다.

### 안 된다고 말하기 & 대안 제시하기

- 개발자는 **`안 된다`** 라고 말할 수 있어야 한다.
  - 무리한 요구를 하면 `안 된다, 못 한다, 어렵다, 힘들다` 같은 말로 할 수 없다는 점을 분명히 밝혀야 한다.
  - 지키지 못할 약속을 하면 신뢰가 깍일 뿐 아니라 같이 일하는 사람도 힘들어진다.
- **`안 된다고 말할 때는 할 수 없는 이유도 함께 전달해야 한다`**. 자칫 일하기 힘든 개발자로 인식될 수 있다.
  - 어려운 요구가 들어온다면 안 된다고만 하지 말고 대안을 찾아보자.
  - 요구하는 이유를 듣고 고민해보면 해결할 다른 방법이 떠오를 떄가 많다.
- 요구를 있는 그대로만 생각해서 못 한다고 하기보다 요구를 충족할 수 있는 대안을 찾아 제공하는게 더 가치있다.

### 수 작업 줄이기

- 개발자가 매일 코딩만 하는 것은 아니다. 서비스 운영을 병행하는 조직은 구현 외에 다양한 일을 하게 된다.
- 우리가 하는 일은 결국 사람이 수 작업으로 할 일을 시스템화 하는 것이다.
- **`반복해서 발생하는 수 작업이 있다면`** 자동화 기능을 만들어서 업무 생산성을 높이자.

### 이유와 목적 생각하기

- 경력이 쌓이면 단순히 시키는 일만 하면 안 된다.
- 상급자로부터 업무를 받으면 **`어떤 목적으로 그 일을 줬는지 알아내야 한다`**.
- 단지 결과만 만들면 되는게 아니다. 이유와 목적을 모른 채 일만 한다면 엉뚱한 결과를 만들 수 있다.
- 일을 맡길 때도 결과물과 이유와 목적을 함께 알려줘야 한다. 그래야 불필요한 반복 작업을 줄일 수 있다.

## 정리하고 공유하기

### 글로 정리해서 공유하기

- 글은 소통에서 중요한 역할을 담당한다. 그러나 안타깝게도 많은 개발자가 문서 작성을 꺼린다.
- 개발자는 **`내용을 정확하게 전달하는 글을 쓰면 된다`**. 좋은 글을 쓰는 건 어렵지만 연습으로 잘 읽히는 글을 쓸 순 있다.
- 글을 정확하게 전달하기 위해 **`모호한 표현을 줄이도록 노력해야 한다`**. 대표적으로 `부분`이 있다.
  - `ex) 어제 말씀드린 부분과 관련된 건데, 오늘 이야기한 결과 어제 얘기한 부분 중에서 실제 문제가 되는 부분 말고는 그대로 진행하기로 했다.`
- **`글은 마치 코드와 같다`**. 장기적으로 코드를 작성하는 사람보다 코드를 읽는 사람이 더 많다.
  - 글을 읽는 사람이 내용을 이해하는데 드는 시간을 줄여주면 글의 효과가 배가 된다.
- 비 개발자를 대상으로 할 때는 **`개발 용어 사용을 최대한 아끼자`**.
  - 장애 상황을 비 개발자에게 커넥션 풀이 다 차서, 데드락이 걸려서 라고 설명하면 이해하지 못한다.
- **긴 문장보다는 짧은 문장이 좋다**. 모든 내용을 문장으로 전달하기 보다 글머리 기호 목록을 활용하면 좋다.

  ```txt
    // not bad
    국내 기술 동향을 조사한 결과 국내에서 가장 많이 사용하는 백엔드 개발 언어는 자바이며 NodeJS, 파이썬을 사용하는 곳도 증가하고 있다. PHP는 지속해서 점유율을 유지하고 있다.

    // good
    국내 백엔드 개발 언어 기술 동향
    * 자바 - 많이 사용됨
    * NodeJS, 파이썬 - 증가 추세
    * PHP - 지속해서 점유율 유지
  ```

- 표, 그래프, 그림, 문장의 시각화 효과(볼드, 밑줄 긋기, 다른 색으로 표시)를 활용하는 것도 좋다.
- 저자가 추천하는 글 쓰기 책
  - `엔지니어를 위한 문장의 기술, 마케터의 문장, 내 문장이 그렇게 이상한가요?`

### 발표하기

- 사내에 도입하고 싶은 기술, 프로세스가 있다면 팀원과 팀장을 설득하고 내 의견에 동조하게 해야 한다.
- 이럴 땐 자료만 제공하고 끝내서는 안 되고 의견을 정리해서 전달하는 자리를 만들어야 한다.
- 발표를 유창하게 할 필요는 없지만 내용을 전달하는데 필요한 만큼은 해야 한다. 그래서 말하기 연습도 필요하다.
- **`발표 기회를 갖기 위해`** 세미나와 스터디를 활용해 볼 수 있다.
- **`발표의 핵심은 내용 전달이다`**. 내용 초안을 만들고 말로 발표 연습을 충분히 하자.
  - 자료를 포장하느라 말하는 연습을 놓치면 안 된다.
  - 내용이 완성되면 그때 발표 자료에 금칠을 해도 늦지 않다.

## 리더와 팔로워

- 우리 모두는 리더이면서 동시에 팔로워이기에 두 역할을 이해하고 연습해야 한다.

### 리더 연습하기

- 리더십이 반드시 상사와 부하 직원 사이에서만 형성되는게 아니라 주변에 영향을 주고 있다면 그게 바로 리더십이다.
- 리더십을 향상하는데 경험이 중요하지만, 경험만으로는 부족하다. 관련 책이나 강의를 들을 필요가 있다.
  - 제럴드 와인버그가 쓴 테크니컬 리더
- 동기 부여, 조직화, 혁신 & 아이디어 중에서 가장 어려운 것은 단연 동기 부여이다.
  - 같은 방식을 사용해도 사람마다 자극을 받거나 반발하는 경우가 있다.
  - 금전적 보상 같은 외적 동기 부여 방식으로는 직원의 성과를 높이는데 한계가 있다고 한다.
  - 내적 동기 부여를 일으키는 주 요인으로 주도성, 전문성, 목적이 있다.
    - 주도성은 자신의 삶을 결정하고 싶어 하는 욕망
    - 전문성은 의미있는 것을 더 잘하고 싶은 욕망
    - 목적은 자신보다 큰 무언가를 향해 뭔가 하고 싶다는 열망이다.
  - 이 3가지에 집중하면 내적 동기 부여를 높일 수 있다고 한다.
  - 중장기적으로 개발자에게 동기를 부여하고 싶다면 외적 동기 부여와 함께 내적 동기 부여를 끌어올릴 방법을 고민해야 한다.

#### 사람이 아닌 프로세스 & 시스템을 변화시키기

- 사람은 쉽게 바뀌지 않는다. 다른 사람이 변화할 때 내가 촉매제가 될 순 있지만 본인의 의지가 없다면 변화는 일어나지 않는다.
- 그러니 사람을 변화시키려고 애쓰지 말자. 변화가 필요하다면 프로세스와 시스템에 집중하자.
- 프로세스와 시스템을 바꾸고 사람들이 그걸 따르도록 만들자.
- 프로세스와 시스템 변경이 쉽다는게 아니라 사람을 변화시키기는 것보다는 조금 수월하다는 의미다.
- 동료가 변화를 받아들일 때의 장점을 명확하게 느낄 수 있도록 지속해서 노력해야 한다.
  - 만들었으니까 써봐라고 말만 하면 안 된다.
  - 본인 스스로 모범 사례가 되어야 하고 장점을 느낄 수 있도록 옆에서 도와줘야 한다.
  - 그래야 비로소 조금씩 바뀌는 모습을 볼 수 있다.

#### 기술력 상실의 두려움 없애기

- 리더나 관리자가 되면 회의 참석, 일정 조율과 관리로 이전과 같은 기술력을 유지할 수 있을지 두려움이 생기기도 한다.
- 하지만 코딩이 기술력의 전부는 아니다.
  - 넓은 시야와 깊은 수준으로 시스템을 바라보고 아키텍처를 설계하는 역량은 중요한 기술 역량이다.
  - 복잡한 시스템을 알맞게 분해하고 진행 계획을 세우는 역량 역시 시니어 개발자가 가져야 할 중요 역량이다.
  - 동료가 제시한 기술 후보 중에서 현재 상황에 맞는 기술을 선택할 수 있는 기준을 갖추는 것도 중요하다.
- 리더나 관리자 역할을 맡게 될 때 기술력을 상실하게 된다는 두려움을 갖지 말자.
  - 대신 고참 개발자로 성장하는 데 필요한 여러 역량을 높일 기회로 생각하자.

#### 대신하지 않기 & 자율성

- 직원이 어려움을 겪고 있거나 진도가 잘 안나갈 때 내가 하면 빨리할 수 있다는 생각이 들 때가 많다.
- 내가 가진 역량을 발휘해서 직원을 돕게 되면 오히려 직원이 성장할 기회를 훔친 것에 가깝다.
- 직원의 성장을 바란다면 일을 대신하지 말고 마음의 여유를 갖자.
- 돕고 싶다면 구현 안을 함께 검토하거나 짝 코딩을 통해 지식을 전파하는 식의 다른 형태로 지원하자.
- 일을 맡겨 놓고 작은 것 까지 지시하는 마이크로 매니저는 직원의 자율성을 뺏는다.
  - 자율성이 없는 직원은 주도성을 읽고 수동적으로 시킨 일만 하게 된다.
- 직원에게 동기 부여를 하고 주도적으로 참여하도록 유도하고 싶다면 자율성을 최대한 보장해줘야 한다.
  - 간섭할수록 주도성이 떨어지기 때문에 맡겼다면 간섭을 최소화하고 기다리자.

#### 도움 요청하기

- 리더라고 혼자 힘든 일을 떠맡을 필요는 없으며 잘하는 모습만 보이려고 애쓰지 않아도 된다.
- 리더가 가질 책임은 일을 제대로 끝내는 것이다. 도움이 필요하면 상위 직급자나 함께하는 직원에게 도움을 구하자.
- 제때 도움을 구하지 않아 일이 엉망이 되는 것 보다 제때 도움을 구해 일이 제대로 진행되는 것이 낫다.

#### 규모의 비 경제 이해하기

- 프로젝트가 지연되면 개발자를 추가로 투입하는 것을 검토하는 리더가 많다.
- 인력을 더 투입하면 개발이 더 빨리 끝날 것 같은 느낌이 들기 때문이다.
- 하지만 지연된 프로젝트에 개발자를 더 투입하면 일정이 더 늦어진다는 브룩스의 법칙이 존재한다.
  - 이 법칙에 따르면 인력을 추가로 투입하면 소통 비용과 부하가 늘어나 개발 시간이 증가하게 된다.
- 규모의 비 경제를 이겨내는 방법은 대규모 프로젝트를 여러 작은 프로젝트로 나누는 것이다.
  - 나뉜 각 프로젝트에 소규모 팀을 할당하면 개발자 생산성도 높아지고 프로젝트 성공 가능성도 올라간다.

### 팔로워

- 경력이 쌓일수록 업무를 어떻게 처리하고 팀원으로서 어떤 역할을 해야 하는지도 고민해야 한다.
- 팔로워십은 단순히 리더를 따르는 것을 의미하지 않는다.
  - 팔로워십은 리더와 조화를 이루고 능동적으로 일을 수행하면서 리더가 성공할 수 있도록 지원하는 것이다.
  - 팔로워는 리더랑 소통하고 공감하며 문제를 발견하고 의견을 제시하여 리더와 함께 조직의 목표를 달성하는데 기여한다.
- 좋은 팔로워가 되려면 전문성을 키워야 한다.
  - 리더가 제시한 목표에 동의해도 달성할 수 있는 역량이 없다면 리더와 팔로워 둘 다 좋은 성과를 낼 수 없다.

#### 팔로워십과 영향력

- 리더는 전지전능한 존재가 아니다. 리더 역시 사람이고 잘못된 결정을 내릴 수 있다.
- 좋은 팔로워는 리더가 제시하는 방향을 잘 지원하고 따르는 것 뿐 아니라 리더가 잘못된 의사 결정을 내리면 올바른 방향으로 이끌어갈 수 있도록 노력한다.

#### 나쁜 팔로워 되지 않기

- 바버라 켈러먼이 쓴 팔로워십을 보면 나쁜 팔로워에 대해 아래와 같이 정의한다.
  - 아무것도 하지 않기 (전혀 관여하지 않기)
  - 나쁜 리더를 지지하기
  - 좋은 리더를 반대하기
- 나쁜 리더를 막을 만큼 영향력이 없더라도 나쁜 리더의 방향을 지지하지 않을 수는 있다.
- 나쁜 리더가 있다고 해서 나쁜 팔로워가 되지는 말자.

#### 나쁜 리더와의 관계

- 나쁜 리더는 피할 수 있으면 좋겠지만 언젠가는 만나게 된다.
- 나쁜 리더와는 어떻게 지내야 할까? 핵심은 본인의 역량에 달려 있다.
  - 일을 잘하고 조직에 필요한 인력이 되면 나쁜 상사와의 관계도 개선된다는 것이다.
  - 조직에서 중요한 인물이 되면 나쁜 상사라 해도 쉽게 어쩌지 못하고 더 나아가 영향력을 행사할 수도 있다.
- 나쁜 상사를 만나더라도 감정에 흔들리지 말고 침착함을 유지하자. 그리고 차분히 결과를 내는데 집중하자.

#### 이끌거나 따르거나 비켜서라

- 이 말은 CNN 창업자 테드 터너가 한 말이다.
- 리더가 되어 누군가를 이끌거나, 팔로워가 되어 누군가를 따라야 한다. 다 싫다면 그들이 나아갈 수 있게 비켜야 한다.
- 경력이 쌓이면 누구나 팔로워이면서 동시에 리더가 된다. 팀장을 따르면서 경험이 부족한 동료를 이끌어야 한다.
- 좋은 리더가 되려면 먼저 좋은 팔로워가 되어야 한다.
  - 좋은 팔로워는 리더가 의사 결정하는 과정에 참여해 좋은 결정을 내릴 수 있게 함께 고민한다.
  - 이런 경험은 좋은 리더가 되는 씨앗이 된다.

### 겸손, 존중, 신뢰

- 함께 일하고 싶은 리더, 팔로워, 동료가 되려면 겸손이 필요하다.
- 동료의 부족함을 지적할 때는 개인을 비난하지 말고 최대한 정중해야 한다.
- 반대로 동료가 나를 지적할 때도 나를 비난한다고 생각할 필요도 없다.
  - 내 코드의 부족함을 지적당해도 코드에 나를 대입할 필요는 없다.
  - 코드는 코드고 나는 나다.
- 겸손, 존중, 신뢰 중에 가장 가지기 힘든 것이 신뢰다.
  - 태도가 좋아도 역량이 부족하면 신뢰가 생기지 않는다.
  - 반대로 역량이 좋아도 태도가 나쁘면 신뢰하기 어렵다.
- 신뢰를 만들기 위해서는 좋은 태도를 유지하면서 역량을 높이는 노력이 필요하다.
- 한번 맺은 좋은 관계는 오래가며 어려울 때 큰 힘이 될 수 있다. 그러니 관계의 힘을 무시하지 말자.

## 맺음말

- 다양한 역량을 보고 배울 수 있는 리더와 동료가 있다면 운이 좋은 것이다.
- 하지만 운이 좋다고 실력이 늘지는 않는다. 배울 만한 사람이 있다고 해서 내 실력이 절로 늘지는 않는다는 얘기다.
- 테크니컬 리더에 다음과 같은 문장이 나온다.
  - 자신의 교육은 스스로 책임진다.
- 결국 역량 향상은 스스로 책임져야 한다. 노력하지 않으면 역량은 늘지 않는다.
- 책 이름처럼 구현 기술만 편식하지 말고 개발에 필요한 다양한 역량을 섭취해 좋은 개발자로 성장하길 바란다.
