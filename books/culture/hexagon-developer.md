# 육각형 개발자

- [책 링크](https://product.kyobobook.co.kr/detail/S000203107475)

## 들어가며

### 개발이란

- 사회 초년생일 때는 `구현 기술을 사용해 코드를 작성하는게` 개발이라고 생각했다.
- 년차가 쌓이니 **`고객의 요구를 파악하고 원하는 것을 충족하는 기능을 만드는게 개발이었다`**.
  - 어떤 기술을 사용하기 위해 or 특정 개인의 이력 관리를 위해 시작한 프로젝트는 별다른 결과 없이 사라지곤 했다.
- 회사 업무를 하면서 성장한다는 느낌을 받지 못한 이유는 **`개발과 성장을 동일시했기 떄문이다`**.
  - 익숙해진 회사의 개발 업무로는 더 이상 성장할 수 없다고 생각했다.
  - 현재 사용하는 기술에만 멈춰 있으면 뒤처진다고 생각했고 새로운 기술만 쫓게 되었다.

### 개발에 필요한 것

- 이 책에서는 **아래 역량**을 이야기 할 것이다.
  - 구현 기술
  - 설계 역량
  - 업무 관리와 요구 분석 & 공유 & 리드-팔로우
- 처음에 구현 기술을 학습하고 이후에 새로운 구현 기술을 익히거나 알고 있는 기술을 발전시키는 노력을 등한시 하는 개발자가 있는데 **`이런 자세로는 좋은 시니어 개발자가 될 수 없다`**.
- 설계는 서비스 경쟁력에 직결되기 때문에 중요하다.
  - 단기간에 늘지 않기 때문에 기본적으로 다양한 경험을 쌓아야 한다.
  - 상황에 따라 알맞은 설계 구조를 선택할 수 있어야 한다. 이렇게 하려면 여러가지 **`설계 기법을 평소에 꾸준히 학습하고 익혀야 한다`**.

## 구현 기술과 학습

### 학습 대상

- 개발자가 익혀야 할 구현 기술이 너무 많다 보니 **`학습할 대상을 잘 선택해야`** 한다.
- 학습하려고 하는 구현 기술을 정할 때 다음 **`2가지 기준을`** 적용하면 좋다.
  - **`현재 사용중인 기술`**
  - **`문제를 해결하기 위한 기술`**
- 현재 사용하는 기술은 당연히 학습해야 한다. 지금 당장 잘 활용하는 것이 중요하기 때문이다.
  - 현재 사용하는 기술이 본인의 취향과 맞지 않더라도 코드를 이해하고 수정할 수 있을 정도의 지식은 있어야 한다.
  - 사용 중인 기술을 학습할 때는 처음부터 완벽하게 익히려고 하지 않아도 된다.
  - 기술의 일부 요소만 사용하므로 필요한 부분만 알고 있으면 일반적인 기능을 개발하는데 문제없을 것이다.
- 문제를 해결하기 위한 기술에는 다음 두 가지가 있다.
  - 당장 해결해야 하는 문제
  - 가까운 미래에 해결해야 하는 문제
- 문제가 눈앞에 닥쳤을 때 즉시 알맞은 구현 기술을 찾는 건 쉽지 않다.
  - 그래서 문제 해결 능력을 향상하기 위해 **`평소에 구현 기술을 찾아 학습해야 한다`**.

### 기술 파기

- **`익혀야 하는 기술은 많고 모든 기술을 깊게 파기는 어려운데`** 어떻게 하면 좋을까?
  - 처음 접하는 기술은 핸즈온이나 동영상 강의, 튜토리얼 문서로 빠르게 감을 잡아야 한다.
  - 핸즈온이나 튜토리얼 문서는 입문자가 기술의 전반을 몰라도 빠르게 기술의 동작을 경험하게 해준다.
  - 일상 업무를 개발할 수준까지 기술을 익혔다면 필요할 때 마다 기술을 조금씩 더 깊게 학습한다.
- 예전에는 내가 사용하는 기술의 내부 동작 원리도 알아야 한다고 생각했지만 지금은 그렇지 않다.
  - 알아야 할 기술이 많기에 내가 사용하는 모든 기술을 처음부터 깊게 알기란 어렵다.
  - **`기술을 깊게 이해해야 하는 순간이 있고`**, 이때 시간을 더 들여 깊은 지식을 학습하고 연습하면 된다.
- **`중요한 건 더 나은 방법을 찾으려고 노력해야 한다는 것이다`**. 기존 방법만 답습하면 기술 역량을 높일 기회는 찾아오지 않는다.

### 학습 전략

- 유행하는 기술의 흐름이 자주 바뀌다 보니 전략적으로 구현 기술을 학습할 필요가 있다.
- 일단 **`주력 기술을 집중적으로`** 학습해야 한다.
  - 주력 기술이란 당장 또는 가까운 미래에 경제적 이익을 얻는데 필요한 기술을 말한다.
  - 시장 점유율이 높다면 그 기술을 익혀야 유리하다.
  - 현재 대세인 기술을 학습할 필요는 있지만 모든 대세 기술을 알 필요는 없다.
    - 본인의 업무를 수행하는데 필요한 기술을 집중적으로 익혀야 한다.
- 어떤 기술에 흥미가 생겨 열심히 학습할 수는 있다.
  - 하지만 그 기술을 자신의 주력 기술로 삼을지는 고민해야 한다.
  - 개인 프로젝트는 괜찮지만 회사 업무에는 여러 이유로 적용하기 어려울 수 있다.
- 여러 **`기술을 꾸준히 탐색할 필요도 있다`**.
  - 어떤 기술이 주목받고 있는지 조사하고 필요에 따라 핸즈온이나 별도 학습으로 빠르게 경험해야 한다.
  - 왜 주목받는지 이해하려 노력하면 언젠가 그 기술을 적용하려 할때 수월해질 것이다.
  - 또한 이런 노력들이 개발자로서 미래 경쟁력을 유지할 수 있다.
- 좋은 시니어 개발자가 되고 싶다면 **`구현 기술을 주기적으로 탐색하고 학습해야 한다`**.
  - 구현 기술 학습에는 끝이 없다. 계속해서 새로운 기술을 익혀야 함을 잊지 말자.

### 유행에 상관없는 구현 기술

- 저자는 동시성 문제로 뉴스에 나올만큼의 대형사고를 겪은 적이 있다.
- **`유행하는 기술만 좇다보면`** 동시성 처리, 네트워크 문제, SQL 인덱스 같은 **`기초 지식을 놓치기 쉽다`**.
  - 주니어 개발자라면 유행과 상관없는 지식을 1년에 1개 이상 학습하자.
  - HTTP 프로토콜, 네트워크 프로그래밍 기초, 동시성 처리, 사용하는 프로그래밍 언어.
  - 유행에 상관없이 개발의 **`기초 지식을 꾸준히 학습해야 기본기가 튼튼한 개발자로`** 성장할 수 있다.

### 구현 기술 적용

- **`어떤 기술을 도입할때는`** 부수적으로 고민하고 다음 내용을 신경써야 한다.
  - 신뢰 구축
  - 함께할 동료
  - 타당성
  - 점진적 저용
  - 시장 상황
- 본인이 책임자라면 **`입사한지 얼마 안 된 팀원이 제안한 새로운 기술을`** 선뜻 적용할 수 있는가?
  - 다른 구성원의 공감을 얻기 위해서는 자신의 역량을 증명해야 한다.
  - 자기 업무도 제대로 처리 못한 상태에서 어떤 의견을 제시해봤자 불만만 토로하는 사람으로 보인다.
  - 먼저 기존 시스템을 이해하고 주어진 일을 잘 수행해야 동료에게 신뢰를 얻을 수 있다.
  - 어떤 조직도 처음부터 날 믿어주지 않는다. 동료에 신뢰를 얻기까지 보통 3개월 ~ 1년정도 걸린다.
  - 조직에 변화를 주고 싶다면 그만큼 인내도 필요하다.
  - **`신뢰가 쌓여야 내 주장에 힘이 실린다`**. 이 점을 잊지 말자.
- 새로 적용하고자 하는 기술에 대해 논의하고 공감대를 형성할 수 있는 동료가 꼭 필요하다
  - 혼자서는 아무것도 할 수 없다. 아니 하면 안된다.
  - 내가 맞다고 생각하는 의견에 공감해 줄 동료가 없다면 내 제안은 그저 고집일 수도 있다.
  - **`변화는 언제나 힘든 과정이다`**. 1~2개월 내 승부를 보겠다는 마음은 버려야 한다.
    - 계속해서 내가 제안한 변화에 수긍할 수 있도록 인내심을 갖고 소통해야 한다.
- 익숙하지 않은 `기술을 적용해야 하는 이유가 타당해야 한다`.
  - 웹플럭스가 유행할 때 유행에 민감한 많은 개발자가 API 구현 기술로 웹플럭스를 검토했다.
  - 도입하려는 이유를 물어보면 성능을 말하지만 어떤 성능을 높이기 위해 도입하는지 물어보면 명확하게 대답해주는 사람은 별로 없었다.
  - 본인이 사용하고 싶은 욕구를 숨기고 기술의 장점만 내세워 기술을 도입해야 한다고 주장하는 사람들을 많이 봤다.
  - 조직이 처한 상황과 조건이 부합할 떄 새로운 기술을 적용해야 그 기술의 장점이 빛을 발한다.
- 새로운 기술은 점진적으로 적용하자.
  - **`한번에 다 바꾸겠다는 생각은 위험하다`**.
  - 중요하지 않은 기능과 시스템에 먼저 적용해서 안정섬을 검증해야 한다.
  - ORM 도구를 도입하던 초기에도 ORM을 제대로 이해하지 못하다 보니 성능 문제를 겪는 프로젝트가 많았다.
- 시장 상황을 고려하자.
  - 도입하려는 기술에 능숙한 인력을 원활히 채용할 수 있어야 한다.

### 주의할 점

- 특정 기술을 사용해야 우월하다는 생각을 가진 개발자를 마주칠 떄가 있다.
  - 특정 기술을 사용한다고 우월한 것도 아니고 오래된 기술을 사용한다고 열등하다고 할 수 없다.
  - **`구현 기술은 단지 구현 기술일 뿐. 구현 기술을 맹종하지 말자`**
- 한 명의 개발자가 모든 것을 잘 할 필요는 없다.
  - 모든 기술을 능숙하게 다루겠다는 마음보다는 특정 기술을 잘 사용하자는 의지가 더 낫다.
  - 물론 잘 다루고 싶은 구현 기술은 더 깊게 학습하고 연습하면서 구현 실력을 갈고 닦아야 한다.
- 불나방처럼 이 기술 저 기술 다 잘하겠다고 덤비면 안 된다.
  - 미래 경쟁력을 위한 기술을 탐색하면서 필요할 때 더 깊게 학습하면 된다.

## SW 가치와 비용

### 개발 비용

- 서비스를 출시하고 시간이 흐를수록 개발 비용이 증가하는 문제를 많은 기업이 겪고 있다.
- 제품 경쟁력을 갖추려면 사용자를 만족시키는 기능을 빨리 내놓아야 하는데 개발 시간이 증가하니 경쟁력이 떨어진다.
- 우선 서비스가 출시되면 **`서비스 유지보수에 계속 비용이 들어간다`**.
- 개발자는 흔히 기존 `코드를 바꾸는 것보다 새로 만드는게 빨라요`란 말을 한다.
  - 이는 유지보수 비용과 관련이 있다.
  - 간단한 기능조차도 처음 만드는 것 보다 나중에 만드는게 개발 시간이 몇배에서 수십 배 이상 소요된다.
- SW를 제때 변경하고 싶다면 **`유지보수 비용을 낮출 수 있는 방법을 찾아야 한다`**. 그래야 경쟁력을 높일 수 있다.

### 유지보수 비용을 낮추려면

- 버그를 수정할 때 원인을 찾는 시간이 더 오래 걸릴 때가 많다.
  - 1시간 이상 코드를 분석했는데 실제 수정은 2분만에 끝나는 방식
- 다른 이유가 있을 수 있지만 **`코드와 설계 품질이 코드 수정 시간에 많은 영향을 준다`**.
- 어떤 논문은 **`코드 품질이 나쁠때`** 평균 개발시간이 1.2배 최대 개발시간은 9배 가까이 차이가 났다.
- 유지보수에 들어가는 개발 비용을 낮추려면 품질을 신경써야 한다.
  - 코드 가독성을 높이고 전형적인 패턴 사용, 요구에 알맞은 아키텍처를 적용하면 유지보수 비용을 줄일 수 있다.
- 시니어 개발자로 성장하기 위해서는 유지보수와 비용에 대해 고민해야 한다.
  - 단순히 어떤 기술과 아키텍처가 유행한다고 선택하면 안된다.
  - 선택에 따른 장,단점을 따져 SW 가치를 안정적으로 높일 수 있는 방법을 선택해야 한다.

## 코드 이해

### 코드 변경

- 개발자가 코드를 변경하기 위해 **`코드를 읽는 시간은 얼마나 될까`**?
  - 일반적으로 코드를 이해하는 데 개발 시간의 60%를 사용한다.
  - 버그 수정과 같은 코드를 이해하는데 90% 이상의 시간을 쏟기도 한다.
  - 이처럼 코드를 이해하는 시간이 더 소요되기 때문에 **`코드를 이해하는 작업은 유지보수 하는 데 매우 중요하다`**.
- 코드를 이해하는 시간을 줄이기 위해서는 2가지 역량이 요구된다.
  - 당연하게도 코드를 제대로 이해할 수 있는 역량이다.
  - 이해하기 쉬운 코드를 작성하는 역량이다.
- 품질이 낮은 스파게티 코드를 이해하기 위해서는 품질이 좋은 코드보다 40% 정도 더 많은 시간이 소요된다고 한다.
- 결과적으로 **`이해하기 좋은 코드를 만들면`** 코드를 이해하는데 들어가는 시간을 줄일 수 있고 개발 시간도 줄어든다.

### 이해하기 좋은 코드

- 이해하기 좋은 코드는 코드 분석에 필요한 노력을 줄여준다.
- 이해하기 좋은 코드를 만들 때 **`가장 중요한 것은 가독성이다`**.
- 저자는 이해하기 좋은 코드를 작성하는 방법을 알려주는 책으로 두 권을 뽑았다.
  - `켄트 백의 구현 패턴`
  - `클린 코드`

#### 이해를 돕는 몇 가지 코드 작성법

- **`이름`**
  - 이름은 코드 가독성에 큰 영향을 준다.
  - 이름은 짧을 수록 좋지만 사용 범위가 넓다면 서술적인 이름을 사용해야 한다.
  - 클래스 이름이 맥락을 제공하기 때문에 필드 이름은 짧아도 의미가 잘 전달된다.
    - `ex) Member class에 memberName 대신 name 필드 제공`
- **`중첩 if문 최소화`**
  - if 구조가 복잡할 때 if 조건을 역으로 바꾸면 else가 없다는 사실을 알 수 있다.
  - 기억할 범위도 좁아지고 코드 들여쓰기가 줄어들어 복잡도가 낮아진다.
- **`변수 줄이기`**

  - 변수는 함수 시작 부분에 선언하지 않고, 사용되기 직전에 정의하자
  - 같은 변수가 타입이 같다고 여러 의미로 사용하지 말자.
    - ex) result 변수가 성공, 실패 용도로 사용하다가 처리 개수를 저장하는 식
  - 변수가 재사용되지 않고 값이 명확하다면 변수 자체를 줄여야 한다.
  - 반대로 어떤 의미를 부여할때 변수를 사용하면 도움이 된다.

    ```ts
      // 변수 없는 경우
      checkLimit(thisYear - member.getBirthYear())

      // 변수에 담아 전달
      int age = thisYear - member.getBirthYear();
      checkLimit(age);
    ```

- **`값 변경 최소화하기`**
  - 변수 값이 중간에 계속해서 바뀌면 변수 값을 추적해야 한다는 부담이 생긴다.
  - 변수의 값이 바뀌지 않는다면 쉽게 코드 동작을 유추할 수 있기에 변수 변경은 가능한 최소화해야 한다.
- **`길지 않은 코드와 추상화하기`**

  - 긴 코드보다는 짧은 코드가 분석하기 쉽다. 아래 코드를 보자.

    ```java
    public void save(SaveRequest req) {
      if (!StringUtils.hasText(req.getId()))
        throw new IllegalArgumentException('id 필수');
      if (!StringUtils.hasText(req.getName()))
        throw new IllegalArgumentException('name 필수');
      if (!StringUtils.hasText(req.getEmail()))
        throw new IllegalArgumentException('email 필수');

      Long seq = repository.createSeq();
      Member member = Member.builder()
        .seq(seq)
        .id(req.getId()).name(req.getName()).email(req.getEmail())
        .createdAt(LocalDateTime.now())
        .build();
      repository.save(member);
    }
    ```

  - 위 코드를 아래와 같이 줄여보자

    ```java
    public void save(SaveRequest req) {
      validate(req);
      Member member = create(req);
      repository.save(member);
    }

    private void validate(SaveRequest req) {
      if (!StringUtils.hasText(req.getId()))
        throw new IllegalArgumentException('id 필수');
      if (!StringUtils.hasText(req.getName()))
        throw new IllegalArgumentException('name 필수');
      if (!StringUtils.hasText(req.getEmail()))
        throw new IllegalArgumentException('email 필수');
    }

    private Member create(SaveRequest req) {
      Long seq = repository.createSeq();
      return Member.builder()
        .seq(seq)
        .id(req.getId()).name(req.getName()).email(req.getEmail())
        .createdAt(LocalDateTime.now())
        .build();
    }
    ```

  - `save()` 메서드는 **`코드가 길지 않기 때문에 전반적인 흐름을 빨리 이해할 수 있다`**.
  - `save()` 메서드의 상세한 구현은 알 수 없지만 대략 데이터 검증 후 Member 객체를 생성해 저장하는 것을 알 수 있다.
  - 자세한 구현이 궁금하면 각 메서드로 이동한다.

## 응집도와 결합도

### 응집도

- **응집도**는 관련 요소가 얼마나 **`한 모듈에 모여있는지`** 나타낸다.
  - 작게는 메소드, 함수 수준부터 크게는 프로세스 수준까지 모든 수준에서 응집도를 판단할 수 있다.
  - 관련 **`코드가 한 곳에 모여있으면 응집도가 높다고`** 표현하고 반대로 **`관련 코드가 분산되어 있다면 응집도가 낮다고`** 표현한다.
- 왜 응집도를 높여야 할까?
  - 응집도는 결국 **`수정 비용과 관련이 있다`**.
  - 응집도가 높다면 관련 코드가 한 곳에 모여 있게 되며 자연스럽게 클래스가 분리되고 클래스의 길이가 줄고 가독성이 좋아진다.
  - 응집도가 높다면 기능 변경 시, 수정할 범위도 줄어든다. 여러 클래스를 수정하지 않고 한 클래스만 수정할 수 있다.
- 응집도는 역할 또는 책임과 관련이 있다.
  - 회원 관련 타입이 member 패키지에 있고 회원가입과 회원 승인 기능을 각각 `MemberRegisterer`, `MemberApprover` 클래스로 구현했다고 하자.
  - 회원 가입 로직을 변경하려면 `MemberRegisterer`만 수정하면 된다.
  - 회원 승인 기능을 변경하려면 `MemberApprover`만 수정하면 된다.
  - 이처럼 각 클래스를 수정하려는 이유가 각각 하나씩이다.
- **`단일 책임 원칙은`** 한 클래스는 하나의 책임만 가져야 한다는 원칙이다.
  - 다르게 말하면 클래스를 수정할 이유는 하나여야 한다는 것이다.
  - 응집도를 높이면 역할에 따라 구성 요소를 나눠야 하는데, 각 구성 요소를 수정할 이유가 줄게 된다.
  - 즉 **`응집도가 높아지면 단일 책임 원칙을 따를 가능성이 올라간다`**.

### 결합도

- **결합도**는 **`SW 모듈이 서로 의존하는 정도이다`**.
  - 한 모듈을 수정할 때 다른 모듈도 수정해야 한다면 두 모듈은 결합도가 높다.
  - 반대로 한 모듈을 수정할 때 다른 모듈을 수정하지 않아도 되면 결합도가 낮다.
- 수정할 대상이 많아지면 코드 분석과 수정에 드는 시간이 증가한다.
  - 즉 결합도가 높아지면 유지보수 비용이 증가한다.
  - 따라서 수정 비용을 낮추기 위해 응집도는 높이고 결합도는 낮춰야 한다.
- 응집도가 높다고 해서 반드시 결합도가 낮아지는 것은 아니다.
  - 응집도를 높이기 위해 코드를 역할에 따라 분리하면 분리된 요소간에 의존성이 발생해 결합도가 증가한다.

## 리팩토링

### 수정 공포와 변경 비용

- 레거시는 **`오래 되었지만 여전히 사용되고 있는 코드를`** 말한다.
- 아래 상황에서 코드 수정은 매우 두려운 일이다.
  - 레거시 수정 요청이 들어온다. 기존 코드를 분석해야 하지만 항상 일정상 여유가 없다.
  - 코드를 완벽히 이해하지 못한 상태인데 테스트 코드도 없어서 수정한 코드가 기존 기능에 어떤 영향을 끼칠지 알 수 없다.
- **`우리는 누구나 레거시를 만든다`**. 내가 만든 코드라도 수정하기 두렵다면 그게 바로 레거시다.
- 레거시는 폄하 대상이 아니고 모든 코드에는 나름의 사정이 있다. 그러니 레거시를 만나면 다음처럼 생각해보자.
  - **개선할 거리가 있다. 해보자!**

### 리팩토링

- 리팩토링은 외부로 드러나는 동작이나 기능은 변경하지 않고 **내부 구조를 변경하는 기법**이다.
- 리팩토링에는 다양한 기법이 있는데 많은 기법과 과정이 궁금하면 `마틴 파울러`가 쓴 `리팩터링 2판`을 읽어보자.
- 매직 넘버

  - 값을 갖는 숫자를 **매직 넘버**라고 표현하한.
  - 매직 넘버는 그 값이 무엇을 의미하는지 유추하기 어렵게 만든다.

    ```ts
    if (NumberUtils.anyMatch(boilerType, 19, 20)) return true;

    // 더 이해하기 쉽다.
    if (NumberUtils.anyMatch(boilerType, GAS_BOILER, INDUSTRIAL_BOILER))
      return true;
    ```

- **`이름 변경`**
  - 이름은 짧을수록 좋지만 **`너무 짧아 의미가 생략된다면 차라리 긴 이름이 낫다`**.
- **`메서드 추출`**
  - 메서드 추출을 잘 활용하면 코드 가독성이 높아지고 관련 코드가 한 곳에 모이면서 코드가 더 응집된다.
  - 무조건 메서드 추출을 하면 안되고 가독성이나 응집도가 좋아지는 방향으로 메서드를 추출해야 한다.
- 클래스 추출, 클래스 분리, 메서드 분리
- **`파라미터 값 정리`**
  - 메서드에서 사용하지 않는 파라미터 데이터는 제거해야 한다.
  - 사용하지 않는 파라미터는 코드 분석을 어렵게 만들기 때문이다.
- **`for에서 하는 2가지 일 분리`**

  - 하나의 for문에서 여러 작업을 실행하면 서로 다른 목적을 가진 코드가 섞일 수 있다.
  - 이는 코드 복잡도가 증가하고 코드를 이해하기 어려워진다.
  - for 문이 복잡해지지 않게 방지하는 방법으로는 **`for 루프가 1개의 일만 하도록 수정하는`** 것이다.
  - 아래 코드를 보자

    ```java
      for (InvoiceDto invoice: invoices) {
        ApprovalRes res = payGwApi.approve(...) // 결제시도
        paymentService.saveAfterApproval(res) // 결제 성공 결과 반영
        StoreApiDto dto = // 성공 dto 생성
        dtoList.add(dto)
      }
    ```

  - 위 코드는 결제 시도후 결과 반영 & 외부에 전달 할 dto 객체 생성이란 두 가지 작업을 한다.

    ```java
      // 결제 시도 및 결과 생성, 내부에 for문 있음
      List<InvoiceResult> results = approveInvoices(invoices);

      // 외부 시스템에 결제 결과전송, 내부에 for문 있음
      sendInvoiceResultsToStore(results);
    ```

  - for 문이 하는 일을 논리적인 단위로 분리한 덕분에 코드가 이해하기 쉬워졌다.
  - **루프를 한 번만 돌면 되는데** 여러번 돌게 되면 성능이 느려진다고 걱정하는 개발자도 있다.
    - 하지만 미리 걱정할 필요는 없다. 대부분 성능에 문제가 없고 문제가 될 때만 측정해서 개선하면 된다.
    - **`복잡한 코드보다 이해하기 좋은 코드가 주는 이점이 훨씬 크다`**.

## 테스트

### 자동화 된 테스트 & 회귀 테스트 & 안정감

- 자동으로 실행할 수 있는 테스트 코드가 있다면 수정한 코드가 발생시키는 문제를 빨리 찾을 수 있다.
- 사람이라면 몇 시간 이상 검증해야 할 기능을 기계는 단 몇분이면 할 수 있다.
- 테스트 커버리지가 높을수록 수정한 코드가 문제를 일으키지 않을 거란 확신도 커진다.
- 수정한 기능 외에 **`기존 기능이 영향 없는지 검증하는 테스트를 회귀 테스트라`** 부른다.
  - 자동화된 테스트 자체를 회귀 테스트로 사용할 수 있기 때문에 테스트 효율성을 높일 수 있다.
- 민감한 기능일수록 코드를 수정하는데 부담이 커진다. 이런 부담을 줄일 수 있는 방법의 하나가 테스트 작성이다.

### 테스트 주도 개발과 생산성

- 테스트 코드를 작성하는 일이 생산성이 떨어진다고 느낄 수 있다. 단편만 보면 사실이다.
- **`전체 개발 관점에서 바라보면`** 얘기가 달라진다.
  - 개발자가 코드를 수정하면 로컬이든 개발 서버에서든 테스트를 해야 한다.
  - 테스트하다 오류가 발생하면 이 과정을 반복한다.
  - 로직이 복잡할수록 과정이 반복될 수 있고 결과적으로 개발 시간을 증가시킨다.
- 결국 **`전체 개발 시간을 줄이려면 테스트 코드를 만들어야 한다`**.
- 테스트 코드를 작성하면 처음에는 개발 시간이 늘어나지만 시간이 갈수록 반복되는 테스트 시간을 줄여줘서 오히려 개발 시간이 줄어든다는 것을 알 수 있다.

### 테스트 가능성

- 코드를 만들 때 테스트 가능성을 염두에 두면 **`설계 품질을 올릴 수 있다`**.
- 어떤 함수가 외부 API로 카드 상태를 확인 하고 카드를 저장한다고 가정하자.
- 테스트가 통과하도록 하려면 외부 연동 코드를 별도로 분리해서 주입받아야 한다.
  - mock으로 외부 연동 코드를 주입받아 카드를 저장하는 함수만 테스트가 가능하다.
- 테스트 가능성이 높아지면 **`외부 환경에 대한 의존이 줄어들어 전체가 아닌 일부만 테스트할 수 있게 된다`**.
- 테스트 가능성을 높이는 과정에서 역할에 따라 타입이 분리되며 응집도가 올라가고 전반적으로 설계 품질이 좋아지게 된다.

## 아키텍처 & 패턴

- 주니어와 시니어 개발자를 구분 짓는 요소 중 하나로 아키텍처 설계 역량을 꼽을 수 있다.

### 아키텍처 고민하기

- 아키텍처를 고민할 때는 크게 2가지를 고민해야 한다.
  - 하나는 기능 요구 사항, 다른 하나는 품질 속성(비 기능 요구사항)이다.
- 기능 요구사항은 SW가 해결하고자 하는 문제와 관련이 있다.
  - 학습 서비스라면 기능 요구 사항으로 수강 관리, 학습 진도 추적, 성취도 평가 등이 해당한다.
- 기능 요구 사항은 아키텍처에 영향을 준다.
  - 학습 진도를 어디까지 추적할지에 따라 연동 방식이 달라진다.
  - 성취도 평가를 실시간으로 계산할지 일 단위로 계산할지에 따라 구조가 달라진다.
- 일부 품질 속성은 명시적으로 요구사항에 드러난다.
  - 대표적으로 성능과 확장성이 있다.
  - 보통 요구 사항 문서에 최대 사용자 수, 최대 트래픽 같은 형태로 성능과 확장성을 언급한다.
- 품질 속성의 다른 예시는 도메인마다 법이라던지, 요구 사항에 없더라도 가용성, 인증, 인가 등이 해당한다.

### 트레이드 오프

- 품질 속성을 높이면 시스템 복잡도가 증가한다.
  - 응답 속도를 높이기 위해 메모리 캐시를 도입하거나 DB를 수평확장 하면 아키텍처는 복잡해진다.
- 품질 속성 중 가용성을 높이기 위해 이중화하면 비용이 올라간다.
- 품질 속성을 높이면 복잡도와 비용이 증가하기 때문에 그때그때 다르다는 아키텍처에도 적용된다.
- 감당할 수 있는 복잡도, 인프라 비용, 최소 품질을 고려해서 아키텍처를 결정해야 한다.
  - 모든게 완벽한 아키텍처가 아닌 가장 나쁘지 않은 아키텍처를 선택해야 한다.

### 아키텍처가 중요한 이유

- 시스템이 커질수록 전체 시스템 설계가 개별 구현보다 중요해진다.
- 만드려는 시스템에 따라 적합한 아키텍처가 존재한다.
  - 데이터 일관성이 중요한 아키텍처와 채팅 시스템을 위한 아키텍처는 다르다.
  - 마이크로 서비스는 탄력성, 배포 가능성, 장애를 분산할 수 있지만 데이터 무결성을 위한 구조는 복잡해진다.
- 시스템 규모가 작으면 아키텍처의 중요성은 상대적으로 떨어지지만 시스템 규모가 크다면 아키텍처를 신중히 결정해야 한다.

### 아키텍처 변경

- 스타트업 개발자는 처음 모놀리식 아키텍처로 개발을 진행했다.
  - 사용자가 늘면서 트래픽이 늘고 간헐적으로 응답이 느려지거나 DB의 CPU도 70%넘길때가 있었다.
- 모놀리식 시스템은 많은 기능을 갖게 되는데 기능에 따라 일정 수준의 처리량을 제공하거나, 순간적으로 증가하는 트래픽을 대응할 수 있어야 한다.
- 이런 경우 서비스를 분리해서 수평 확장하거나 동기 연동을 비동기 연동으로 바꿀 수 있다.
- 아키텍처 변경은 반드시 필요성에 기반해 이루어져야 한다.
  - 아키텍처 변경에는 많은 시간과 노력이 따르기 떄문에 신중히 고려해야 한다.

### 패턴 익히기

- 설계하다 보면 이전에 만든 구조가 떠오르는데, 특정 맥락에서 반복되는 문제 해결법을 패턴이라 부른다.
- 아키텍처 패턴, 디자인 패턴, 결함 허용 패턴 등 여러 수준에서 다양한 패턴이 있다.
  - 아키텍처 패턴: 포트 & 어댑터 아키텍처, 마이크로 서비스 아키텍처, 이벤트 기반 아키텍처
  - 디자인 패턴: 싱글턴, 팩토리 등등
  - 결함허용 패턴: 에러 복구, 에러 완화, 하트비트, 서킷 브레이커 등
- 패턴은 설계 시간을 단축해주고 이름만 말해도 원활하게 소통을 도와준다.
- 한 번에 모든 패턴을 학습할 수는 없지만 주기적으로 새로운 패턴을 익혀보자.
