# 육각형 개발자

- [책 링크](https://product.kyobobook.co.kr/detail/S000203107475)

## 들어가며

### 개발이란

- 사회 초년생일 때는 `구현 기술을 사용해 코드를 작성하는게` 개발이라고 생각했다.
- 년차가 쌓이니 **`고객의 요구를 파악하고 원하는 것을 충족하는 기능을 만드는게 개발이었다`**.
  - 어떤 기술을 사용하기 위해 or 특정 개인의 이력 관리를 위해 시작한 프로젝트는 별다른 결과 없이 사라지곤 했다.
- 회사 업무를 하면서 성장한다는 느낌을 받지 못한 이유는 **`개발과 성장을 동일시했기 떄문이다`**.
  - 익숙해진 회사의 개발 업무로는 더 이상 성장할 수 없다고 생각했다.
  - 현재 사용하는 기술에만 멈춰 있으면 뒤처진다고 생각했고 새로운 기술만 쫓게 되었다.

### 개발에 필요한 것

- 이 책에서는 **아래 역량**을 이야기 할 것이다.
  - 구현 기술
  - 설계 역량
  - 업무 관리와 요구 분석 & 공유 & 리드-팔로우
- 처음에 구현 기술을 학습하고 이후에 새로운 구현 기술을 익히거나 알고 있는 기술을 발전시키는 노력을 등한시 하는 개발자가 있는데 **`이런 자세로는 좋은 시니어 개발자가 될 수 없다`**.
- 설계는 서비스 경쟁력에 직결되기 때문에 중요하다.
  - 단기간에 늘지 않기 때문에 기본적으로 다양한 경험을 쌓아야 한다.
  - 상황에 따라 알맞은 설계 구조를 선택할 수 있어야 한다. 이렇게 하려면 여러가지 **`설계 기법을 평소에 꾸준히 학습하고 익혀야 한다`**.

## 구현 기술과 학습

### 학습 대상

- 개발자가 익혀야 할 구현 기술이 너무 많다 보니 **`학습할 대상을 잘 선택해야`** 한다.
- 학습하려고 하는 구현 기술을 정할 때 다음 **`2가지 기준을`** 적용하면 좋다.
  - **`현재 사용중인 기술`**
  - **`문제를 해결하기 위한 기술`**
- 현재 사용하는 기술은 당연히 학습해야 한다. 지금 당장 잘 활용하는 것이 중요하기 때문이다.
  - 현재 사용하는 기술이 본인의 취향과 맞지 않더라도 코드를 이해하고 수정할 수 있을 정도의 지식은 있어야 한다.
  - 사용 중인 기술을 학습할 때는 처음부터 완벽하게 익히려고 하지 않아도 된다.
  - 기술의 일부 요소만 사용하므로 필요한 부분만 알고 있으면 일반적인 기능을 개발하는데 문제없을 것이다.
- 문제를 해결하기 위한 기술에는 다음 두 가지가 있다.
  - 당장 해결해야 하는 문제
  - 가까운 미래에 해결해야 하는 문제
- 문제가 눈앞에 닥쳤을 때 즉시 알맞은 구현 기술을 찾는 건 쉽지 않다.
  - 그래서 문제 해결 능력을 향상하기 위해 **`평소에 구현 기술을 찾아 학습해야 한다`**.

### 기술 파기

- **`익혀야 하는 기술은 많고 모든 기술을 깊게 파기는 어려운데`** 어떻게 하면 좋을까?
  - 처음 접하는 기술은 핸즈온이나 동영상 강의, 튜토리얼 문서로 빠르게 감을 잡아야 한다.
  - 핸즈온이나 튜토리얼 문서는 입문자가 기술의 전반을 몰라도 빠르게 기술의 동작을 경험하게 해준다.
  - 일상 업무를 개발할 수준까지 기술을 익혔다면 필요할 때 마다 기술을 조금씩 더 깊게 학습한다.
- 예전에는 내가 사용하는 기술의 내부 동작 원리도 알아야 한다고 생각했지만 지금은 그렇지 않다.
  - 알아야 할 기술이 많기에 내가 사용하는 모든 기술을 처음부터 깊게 알기란 어렵다.
  - **`기술을 깊게 이해해야 하는 순간이 있고`**, 이때 시간을 더 들여 깊은 지식을 학습하고 연습하면 된다.
- **`중요한 건 더 나은 방법을 찾으려고 노력해야 한다는 것이다`**. 기존 방법만 답습하면 기술 역량을 높일 기회는 찾아오지 않는다.

### 학습 전략

- 유행하는 기술의 흐름이 자주 바뀌다 보니 전략적으로 구현 기술을 학습할 필요가 있다.
- 일단 **`주력 기술을 집중적으로`** 학습해야 한다.
  - 주력 기술이란 당장 또는 가까운 미래에 경제적 이익을 얻는데 필요한 기술을 말한다.
  - 시장 점유율이 높다면 그 기술을 익혀야 유리하다.
  - 현재 대세인 기술을 학습할 필요는 있지만 모든 대세 기술을 알 필요는 없다.
    - 본인의 업무를 수행하는데 필요한 기술을 집중적으로 익혀야 한다.
- 어떤 기술에 흥미가 생겨 열심히 학습할 수는 있다.
  - 하지만 그 기술을 자신의 주력 기술로 삼을지는 고민해야 한다.
  - 개인 프로젝트는 괜찮지만 회사 업무에는 여러 이유로 적용하기 어려울 수 있다.
- 여러 **`기술을 꾸준히 탐색할 필요도 있다`**.
  - 어떤 기술이 주목받고 있는지 조사하고 필요에 따라 핸즈온이나 별도 학습으로 빠르게 경험해야 한다.
  - 왜 주목받는지 이해하려 노력하면 언젠가 그 기술을 적용하려 할때 수월해질 것이다.
  - 또한 이런 노력들이 개발자로서 미래 경쟁력을 유지할 수 있다.
- 좋은 시니어 개발자가 되고 싶다면 **`구현 기술을 주기적으로 탐색하고 학습해야 한다`**.
  - 구현 기술 학습에는 끝이 없다. 계속해서 새로운 기술을 익혀야 함을 잊지 말자.

### 유행에 상관없는 구현 기술

- 저자는 동시성 문제로 뉴스에 나올만큼의 대형사고를 겪은 적이 있다.
- **`유행하는 기술만 좇다보면`** 동시성 처리, 네트워크 문제, SQL 인덱스 같은 **`기초 지식을 놓치기 쉽다`**.
  - 주니어 개발자라면 유행과 상관없는 지식을 1년에 1개 이상 학습하자.
  - HTTP 프로토콜, 네트워크 프로그래밍 기초, 동시성 처리, 사용하는 프로그래밍 언어.
  - 유행에 상관없이 개발의 **`기초 지식을 꾸준히 학습해야 기본기가 튼튼한 개발자로`** 성장할 수 있다.

### 구현 기술 적용

- **`어떤 기술을 도입할때는`** 부수적으로 고민하고 다음 내용을 신경써야 한다.
  - 신뢰 구축
  - 함께할 동료
  - 타당성
  - 점진적 저용
  - 시장 상황
- 본인이 책임자라면 **`입사한지 얼마 안 된 팀원이 제안한 새로운 기술을`** 선뜻 적용할 수 있는가?
  - 다른 구성원의 공감을 얻기 위해서는 자신의 역량을 증명해야 한다.
  - 자기 업무도 제대로 처리 못한 상태에서 어떤 의견을 제시해봤자 불만만 토로하는 사람으로 보인다.
  - 먼저 기존 시스템을 이해하고 주어진 일을 잘 수행해야 동료에게 신뢰를 얻을 수 있다.
  - 어떤 조직도 처음부터 날 믿어주지 않는다. 동료에 신뢰를 얻기까지 보통 3개월 ~ 1년정도 걸린다.
  - 조직에 변화를 주고 싶다면 그만큼 인내도 필요하다.
  - **`신뢰가 쌓여야 내 주장에 힘이 실린다`**. 이 점을 잊지 말자.
- 새로 적용하고자 하는 기술에 대해 논의하고 공감대를 형성할 수 있는 동료가 꼭 필요하다
  - 혼자서는 아무것도 할 수 없다. 아니 하면 안된다.
  - 내가 맞다고 생각하는 의견에 공감해 줄 동료가 없다면 내 제안은 그저 고집일 수도 있다.
  - **`변화는 언제나 힘든 과정이다`**. 1~2개월 내 승부를 보겠다는 마음은 버려야 한다.
    - 계속해서 내가 제안한 변화에 수긍할 수 있도록 인내심을 갖고 소통해야 한다.
- 익숙하지 않은 `기술을 적용해야 하는 이유가 타당해야 한다`.
  - 웹플럭스가 유행할 때 유행에 민감한 많은 개발자가 API 구현 기술로 웹플럭스를 검토했다.
  - 도입하려는 이유를 물어보면 성능을 말하지만 어떤 성능을 높이기 위해 도입하는지 물어보면 명확하게 대답해주는 사람은 별로 없었다.
  - 본인이 사용하고 싶은 욕구를 숨기고 기술의 장점만 내세워 기술을 도입해야 한다고 주장하는 사람들을 많이 봤다.
  - 조직이 처한 상황과 조건이 부합할 떄 새로운 기술을 적용해야 그 기술의 장점이 빛을 발한다.
- 새로운 기술은 점진적으로 적용하자.
  - **`한번에 다 바꾸겠다는 생각은 위험하다`**.
  - 중요하지 않은 기능과 시스템에 먼저 적용해서 안정섬을 검증해야 한다.
  - ORM 도구를 도입하던 초기에도 ORM을 제대로 이해하지 못하다 보니 성능 문제를 겪는 프로젝트가 많았다.
- 시장 상황을 고려하자.
  - 도입하려는 기술에 능숙한 인력을 원활히 채용할 수 있어야 한다.

### 주의할 점

- 특정 기술을 사용해야 우월하다는 생각을 가진 개발자를 마주칠 떄가 있다.
  - 특정 기술을 사용한다고 우월한 것도 아니고 오래된 기술을 사용한다고 열등하다고 할 수 없다.
  - **`구현 기술은 단지 구현 기술일 뿐. 구현 기술을 맹종하지 말자`**
- 한 명의 개발자가 모든 것을 잘 할 필요는 없다.
  - 모든 기술을 능숙하게 다루겠다는 마음보다는 특정 기술을 잘 사용하자는 의지가 더 낫다.
  - 물론 잘 다루고 싶은 구현 기술은 더 깊게 학습하고 연습하면서 구현 실력을 갈고 닦아야 한다.
- 불나방처럼 이 기술 저 기술 다 잘하겠다고 덤비면 안 된다.
  - 미래 경쟁력을 위한 기술을 탐색하면서 필요할 때 더 깊게 학습하면 된다.

## SW 가치와 비용

### 개발 비용

- 서비스를 출시하고 시간이 흐를수록 개발 비용이 증가하는 문제를 많은 기업이 겪고 있다.
- 제품 경쟁력을 갖추려면 사용자를 만족시키는 기능을 빨리 내놓아야 하는데 개발 시간이 증가하니 경쟁력이 떨어진다.
- 우선 서비스가 출시되면 **`서비스 유지보수에 계속 비용이 들어간다`**.
- 개발자는 흔히 기존 `코드를 바꾸는 것보다 새로 만드는게 빨라요`란 말을 한다.
  - 이는 유지보수 비용과 관련이 있다.
  - 간단한 기능조차도 처음 만드는 것 보다 나중에 만드는게 개발 시간이 몇배에서 수십 배 이상 소요된다.
- SW를 제때 변경하고 싶다면 **`유지보수 비용을 낮출 수 있는 방법을 찾아야 한다`**. 그래야 경쟁력을 높일 수 있다.

### 유지보수 비용을 낮추려면

- 버그를 수정할 때 원인을 찾는 시간이 더 오래 걸릴 때가 많다.
  - 1시간 이상 코드를 분석했는데 실제 수정은 2분만에 끝나는 방식
- 다른 이유가 있을 수 있지만 **`코드와 설계 품질이 코드 수정 시간에 많은 영향을 준다`**.
- 어떤 논문은 **`코드 품질이 나쁠때`** 평균 개발시간이 1.2배 최대 개발시간은 9배 가까이 차이가 났다.
- 유지보수에 들어가는 개발 비용을 낮추려면 품질을 신경써야 한다.
  - 코드 가독성을 높이고 전형적인 패턴 사용, 요구에 알맞은 아키텍처를 적용하면 유지보수 비용을 줄일 수 있다.
- 시니어 개발자로 성장하기 위해서는 유지보수와 비용에 대해 고민해야 한다.
  - 단순히 어떤 기술과 아키텍처가 유행한다고 선택하면 안된다.
  - 선택에 따른 장,단점을 따져 SW 가치를 안정적으로 높일 수 있는 방법을 선택해야 한다.

## 코드 이해

### 코드 변경

- 개발자가 코드를 변경하기 위해 **`코드를 읽는 시간은 얼마나 될까`**?
  - 일반적으로 코드를 이해하는 데 개발 시간의 60%를 사용한다.
  - 버그 수정과 같은 코드를 이해하는데 90% 이상의 시간을 쏟기도 한다.
  - 이처럼 코드를 이해하는 시간이 더 소요되기 때문에 **`코드를 이해하는 작업은 유지보수 하는 데 매우 중요하다`**.
- 코드를 이해하는 시간을 줄이기 위해서는 2가지 역량이 요구된다.
  - 당연하게도 코드를 제대로 이해할 수 있는 역량이다.
  - 이해하기 쉬운 코드를 작성하는 역량이다.
- 품질이 낮은 스파게티 코드를 이해하기 위해서는 품질이 좋은 코드보다 40% 정도 더 많은 시간이 소요된다고 한다.
- 결과적으로 **`이해하기 좋은 코드를 만들면`** 코드를 이해하는데 들어가는 시간을 줄일 수 있고 개발 시간도 줄어든다.

### 이해하기 좋은 코드

- 이해하기 좋은 코드는 코드 분석에 필요한 노력을 줄여준다.
- 이해하기 좋은 코드를 만들 때 **`가장 중요한 것은 가독성이다`**.
- 저자는 이해하기 좋은 코드를 작성하는 방법을 알려주는 책으로 두 권을 뽑았다.
  - `켄트 백의 구현 패턴`
  - `클린 코드`

#### 이해를 돕는 몇 가지 코드 작성법

- **`이름`**
  - 이름은 코드 가독성에 큰 영향을 준다.
  - 이름은 짧을 수록 좋지만 사용 범위가 넓다면 서술적인 이름을 사용해야 한다.
  - 클래스 이름이 맥락을 제공하기 때문에 필드 이름은 짧아도 의미가 잘 전달된다.
    - `ex) Member class에 memberName 대신 name 필드 제공`
- **`중첩 if문 최소화`**
  - if 구조가 복잡할 때 if 조건을 역으로 바꾸면 else가 없다는 사실을 알 수 있다.
  - 기억할 범위도 좁아지고 코드 들여쓰기가 줄어들어 복잡도가 낮아진다.
- **`변수 줄이기`**

  - 변수는 함수 시작 부분에 선언하지 않고, 사용되기 직전에 정의하자
  - 같은 변수가 타입이 같다고 여러 의미로 사용하지 말자.
    - ex) result 변수가 성공, 실패 용도로 사용하다가 처리 개수를 저장하는 식
  - 변수가 재사용되지 않고 값이 명확하다면 변수 자체를 줄여야 한다.
  - 반대로 어떤 의미를 부여할때 변수를 사용하면 도움이 된다.

    ```ts
      // 변수 없는 경우
      checkLimit(thisYear - member.getBirthYear())

      // 변수에 담아 전달
      int age = thisYear - member.getBirthYear();
      checkLimit(age);
    ```

- **`값 변경 최소화하기`**
  - 변수 값이 중간에 계속해서 바뀌면 변수 값을 추적해야 한다는 부담이 생긴다.
  - 변수의 값이 바뀌지 않는다면 쉽게 코드 동작을 유추할 수 있기에 변수 변경은 가능한 최소화해야 한다.
- **`길지 않은 코드와 추상화하기`**

  - 긴 코드보다는 짧은 코드가 분석하기 쉽다. 아래 코드를 보자.

    ```java
    public void save(SaveRequest req) {
      if (!StringUtils.hasText(req.getId()))
        throw new IllegalArgumentException('id 필수');
      if (!StringUtils.hasText(req.getName()))
        throw new IllegalArgumentException('name 필수');
      if (!StringUtils.hasText(req.getEmail()))
        throw new IllegalArgumentException('email 필수');

      Long seq = repository.createSeq();
      Member member = Member.builder()
        .seq(seq)
        .id(req.getId()).name(req.getName()).email(req.getEmail())
        .createdAt(LocalDateTime.now())
        .build();
      repository.save(member);
    }
    ```

  - 위 코드를 아래와 같이 줄여보자

    ```java
    public void save(SaveRequest req) {
      validate(req);
      Member member = create(req);
      repository.save(member);
    }

    private void validate(SaveRequest req) {
      if (!StringUtils.hasText(req.getId()))
        throw new IllegalArgumentException('id 필수');
      if (!StringUtils.hasText(req.getName()))
        throw new IllegalArgumentException('name 필수');
      if (!StringUtils.hasText(req.getEmail()))
        throw new IllegalArgumentException('email 필수');
    }

    private Member create(SaveRequest req) {
      Long seq = repository.createSeq();
      return Member.builder()
        .seq(seq)
        .id(req.getId()).name(req.getName()).email(req.getEmail())
        .createdAt(LocalDateTime.now())
        .build();
    }
    ```

  - `save()` 메서드는 **`코드가 길지 않기 때문에 전반적인 흐름을 빨리 이해할 수 있다`**.
  - `save()` 메서드의 상세한 구현은 알 수 없지만 대략 데이터 검증 후 Member 객체를 생성해 저장하는 것을 알 수 있다.
  - 자세한 구현이 궁금하면 각 메서드로 이동한다.

## 응집도와 결합도

### 응집도

- 응집도는 관련 요소가 얼마나 한 모듈에 모여있는지 나타낸다.
  - 작게는 메소드, 함수 수준부터 크게는 프로세스 수준까지 모든 수준에서 응집도를 판단할 수 있다.
  - 관련 코드가 한 곳에 모여있으면 응집도가 높다고 표현하고 반대로 관련 코드가 분산되어 있다면 응집도가 낮다고 표현한다.
- 왜 응집도를 높여야 할까?
  - 응집도는 결국 수정 비용과 관련이 있다.
  - 응집도가 높다면 관련 코드가 한 곳에 모여 있게 되며 자연스럽게 클래스가 분리되고 클래스의 길이가 줄고 가독성이 좋아진다.
  - 응집도가 높다면 기능 변경 시, 수정할 범위도 줄어든다. 여러 클래스를 수정하지 않고 한 클래스만 수정할 수 있다.
- 응집도는 역할 또는 책임과 관련이 있다.
  - 회원 관련 타입이 member 패키지에 있고 회원가입과 회원 승인 기능을 각각 MemberRegisterer, MemberApprover 클래스로 구현했다고 하자.
  - 회원 가입 로직을 변경하려면 MemberRegisterer만 수정하면 된다.
  - 회원 승인 기능을 변경하려면 MemberApprover만 수정하면 된다.
  - 이처럼 각 클래스를 수정하려는 이유가 각각 하나씩이다.
- 단일 책임 원칙은 한 클래스는 하나의 책임만 가져야 한다는 원칙이다.
  - 다르게 말하면 클래스를 수정할 이유는 하나여야 한다는 것이다.
  - 응집도를 높이면 역할에 따라 구성 요소를 나눠야 하는데, 각 구성 요소를 수정할 이유가 줄게 된다.
  - 즉 응집도가 높아지면 단일 책임 원칙을 따를 가능성이 올라간다.

### 결합도

- 결합도는 SW 모듈이 서로 의존하는 정도이다.
  - 한 모듈을 수정할 때 다른 모듈도 수정해야 한다면 두 모듈은 결합도가 높다.
  - 반대로 한 모듈을 수정할 때 다른 모듈을 수정하지 않아도 되면 결합도가 낮다.
- 수정할 대상이 많아지면 코드 분석과 수정에 드는 시간이 증가한다.
  - 즉 결합도가 높아지면 유지보수 비용이 증가한다.
  - 따라서 수정 비용을 낮추기 위해 응집도는 높이고 결합도는 낮춰야 한다.
- 응집도가 높다고 해서 반드시 결합도가 낮아지는 것은 아니다.
  - 응집도를 높이기 위해 코드를 역할에 따라 분리하면 분리된 요소간에 의존성이 발생해 결합도가 증가한다.
