# 운영체제

## 하드웨어 구조

- 메인보드는 다른 하드웨어를 연결하는 장치로 모든 데이터는 메인보드의 버스를 통해 전송된다.
- cpu와 메모리 역시 메인보드에 꽃히며 마우스나 키보드 같은 하드웨어 역시 메인보드에 꽃힌다.

### CPU

- CPU(Central Processing Unit)은 중앙 처리 장치로 아래 3가지로 구성된다.
  - 실제 데이터 연산을 담당하는 산술논리 연산 장치
  - 모든 장치의 동작을 지시하고 제어하는 제어 장치
  - CPU 내에서 계산을 하기 위해 데이터를 임시로 보관하는 레지스터

### 메모리

- RAM(Random Access Memory)은 랜덤으로 데이터를 읽어도 저장된 위치와 상관없이 읽는 속도가 같다.
  - RAM은 전력이 끊기면 데이터가 사라지며 메인 메모리로 사용된다.
- ROM(Read Only Memory)은 전력이 끊겨도 데이터는 보관되지만 한 번 쓰이면 수정이 불가능하다.
  - ROM은 컴퓨터 부팅과 관련된 바이오스를 저장하는데 주로 쓰인다.

## 인터럽트

- CPU가 입출력 장치에 데이터를 읽거나 쓴다고 가정해보자.
- CPU가 폴링 방식으로 주기적으로 입출력 관리자에게 입출력을 확인하면 성능이 좋지 않다.
- 인터럽트는 폴링 방식의 단점을 해결한 방식으로 CPU가 입출력 관리자에게 입출력 명령을 내리고 다른 작업을 한다.
- 입출력 관리자는 입출력이 완료되면 CPU에게 신호를 주고 CPU는 신호를 받아 인터럽트 루틴을 실행시키고 작업을 완료한다.
- 인터럽트 루틴은 특정 인터럽트가 들어오면 그 인터럽트를 처리하는 함수이다.

## 프로그램, 프로세스, 쓰레드

- 프로그램은 저장장치(HDD, SSD)에 저장된 명령어의 집합체
- 프로세스는 메모리에 올라가 실행중인 프로그램을 의미

### 멀티 프로그래밍과 멀티 프로세싱

- 멀티 프로그래밍은 메모리에 여러 프로세스가 올라온 것을 말한다.
- 멀티 프로세싱은 CPU가 여러 프로세스를 처리한 것을 말한다.
- 오늘 날의 OS는 멀티 프로그래밍과 멀티 프로세싱이 같이 적용된다.
  - 메모리에는 여러 프로세스가 올라가 있고, CPU는 짧은 시간 동안 여러 프로세스를 처리하게 된다.
- OS는 컨텍스트 스위칭할 때 PCB(Process Control Block)에 실행하던 프로세스의 정보를 저장한다.
  - 다시 컨텍스트 스위칭으로 해당 프로세스를 이어서 실행하면 PCB로 부터 필요한 데이터를 받아 진행한다.
  - 모든 프로세스마다 자신만의 PCB를 가진다.

### 쓰레드

- OS가 작업을 처리하는 단위는 프로세스 내부의 쓰레드다.
  - 프로세스는 생성되면 stack, heap, code, data, PCB를 위한 메모리가 필요하다.
  - 프로세스가 많으면 많을 수록 메모리를 많이 차지하게 된다.
- 하나의 프로세스 안에 여러 개 존재할 수 있는 쓰레드는, 쓰레드 간 PCB, 데이터, 힙 영역을 공유한다.
  - stack은 공유되지 않고 쓰레드마다 하나씩 가지고 있다.
- 쓰레드마다 TCB(Thread Control Block)라는 메모리가 할당되어 OS가 쓰레드를 구분이 가능

## CPU 스케줄링

- OS는 돌아가면서 프로세스에게 CPU를 할당해야 하는데 이를 CPU 스케줄링이라 부른다.
- CPU 스케줄링에서 OS가 고려해야 할 사항은 두 가지이다.
  - 어떤 프로세스에게 CPU를 할당할 것인가?
  - 프로세스를 얼마의 시간만큼 CPU를 할당할 것인가?

### 스케줄링 기법

- Queue에 프로세스의 PCB를 넣고 하나씩 꺼내어 처리한다.
  - FIFO나 SJF(Shortest Job First)는 단점이 있어 현대의 OS에서는 채택하지 않는다.
  - RR(Round Robin)은 특정 시간을 프로세스에게 할당하고, 시간이 종료되면 Queue에 마지막에 넣는 방식
    - RR에서는 프로세스마다 CPU 할당 시간이 중요한데, 사용자가 느끼기에 버벅거리지 않고 자연스럽게 실행되는 시간을 선택
    - Windows에서는 20ms, Unix는 100ms로 굉장히 짧다.
- MLFQ(Multi Level Feedback Queue)
  - 근래의 OS가 가장 많이 사용하는 방식
  - 우선 순위를 가진 Queue를 여러 개 준비해 둔다.
  - 우선 순위가 높을 수록 타임 슬라이스가 작고, 우선 순위가 낮을 수록 타임 슬라이스가 크다.
  - 우선 순위가 높은 Queue에 있던 프로세스가 CPU를 강제로 뺏기게 되면 우선 순위가 낮은 Queue로 이동한다.
  - CPU를 강제로 뺏기는 횟수가 많아질수록 우선 순위가 낮은 Queue로 내려가면서 타임 슬라이스가 크기 때문에 CPU 할당 시간을 길게 받을 수 있다.
