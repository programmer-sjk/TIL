# 운영체제

## 하드웨어 구조

- **`메인보드는`** 다른 하드웨어를 연결하는 장치로 **`모든 데이터는 메인보드의 버스를 통해`** 전송된다.
- cpu와 메모리 역시 메인보드에 꽃히며 마우스나 키보드 같은 하드웨어 역시 메인보드에 꽃힌다.

### CPU

- **`CPU(Central Processing Unit)은`** 중앙 처리 장치로 아래 3가지로 구성된다.
  - 실제 데이터 연산을 담당하는 `산술논리 연산 장치`
  - 모든 장치의 동작을 지시하고 제어하는 `제어 장치`
  - CPU 내에서 계산을 하기 위해 데이터를 임시로 보관하는 `레지스터`

### 메모리

- **`RAM(Random Access Memory)은`** 랜덤으로 데이터를 읽어도 저장된 위치와 상관없이 읽는 속도가 같다.
  - RAM은 전력이 끊기면 데이터가 사라지며 메인 메모리로 사용된다.
- **`ROM(Read Only Memory)은`** 전력이 끊겨도 데이터는 보관되지만 한 번 쓰이면 수정이 불가능하다.
  - ROM은 컴퓨터 부팅과 관련된 바이오스를 저장하는데 주로 쓰인다.

## 인터럽트

- CPU가 입출력 장치에 데이터를 읽거나 쓴다고 가정해보자.
- CPU가 폴링 방식으로 주기적으로 입출력 관리자에게 입출력을 확인하면 성능이 좋지 않다.
- **`인터럽트는 폴링 방식의 단점을 해결한 방식으로`** CPU가 입출력 관리자에게 입출력 명령을 내리고 다른 작업을 한다.
- 입출력 관리자는 입출력이 완료되면 CPU에게 신호를 주고 CPU는 신호를 받아 인터럽트 루틴을 실행시키고 작업을 완료한다.
- 인터럽트 루틴은 특정 인터럽트가 들어오면 그 인터럽트를 처리하는 함수이다.

## 프로그램, 프로세스, 쓰레드

- 프로그램은 저장장치(HDD, SSD)에 저장된 명령어의 집합체
- 프로세스는 메모리에 올라가 실행중인 프로그램을 의미

### 멀티 프로그래밍과 멀티 프로세싱

- **`멀티 프로그래밍은`** 메모리에 여러 프로세스가 올라온 것을 말한다.
- **`멀티 프로세싱은`** CPU가 여러 프로세스를 처리한 것을 말한다.
- 오늘 날의 OS는 멀티 프로그래밍과 멀티 프로세싱이 같이 적용된다.
  - 메모리에는 여러 프로세스가 올라가 있고, CPU는 짧은 시간 동안 여러 프로세스를 처리하게 된다.
- OS는 컨텍스트 스위칭할 때 **`PCB(Process Control Block)에`** 실행하던 프로세스의 정보를 저장한다.
  - 다시 컨텍스트 스위칭으로 해당 프로세스를 이어서 실행하면 PCB로 부터 필요한 데이터를 받아 진행한다.
  - 모든 프로세스마다 자신만의 PCB를 가진다.

### 쓰레드

- **`OS가 작업을 처리하는 단위는`** 프로세스 내부의 **쓰레드**다.
  - 프로세스는 생성되면 stack, heap, code, data, PCB를 위한 메모리가 필요하다.
  - 프로세스가 많으면 많을 수록 메모리를 많이 차지하게 된다.
- 하나의 프로세스 안에 여러 개 존재할 수 있는 쓰레드는, 쓰레드 간 PCB, 데이터, 힙 영역을 공유한다.
  - stack은 공유되지 않고 쓰레드마다 하나씩 가지고 있다.
- 쓰레드마다 **`TCB(Thread Control Block)라는`** 메모리가 할당되어 OS가 쓰레드를 구분이 가능

## CPU 스케줄링

- OS는 돌아가면서 프로세스에게 CPU를 할당해야 하는데 이를 **`CPU 스케줄링이라`** 부른다.
- CPU 스케줄링에서 OS가 고려해야 할 사항은 두 가지이다.
  - 어떤 프로세스에게 CPU를 할당할 것인가?
  - 프로세스를 얼마의 시간만큼 CPU를 할당할 것인가?

### 스케줄링 기법

- Queue에 프로세스의 PCB를 넣고 하나씩 꺼내어 처리한다.
  - FIFO나 SJF(Shortest Job First)는 단점이 있어 현대의 OS에서는 채택하지 않는다.
  - RR(Round Robin)은 특정 시간을 프로세스에게 할당하고, 시간이 종료되면 Queue에 마지막에 넣는 방식
    - RR에서는 프로세스마다 CPU 할당 시간이 중요한데, 사용자가 느끼기에 버벅거리지 않고 자연스럽게 실행되는 시간을 선택
    - Windows에서는 20ms, Unix는 100ms로 굉장히 짧다.
- MLFQ(Multi Level Feedback Queue)
  - 근래의 OS가 가장 많이 사용하는 방식
  - 우선 순위를 가진 Queue를 여러 개 준비해 둔다.
  - 우선 순위가 높을 수록 타임 슬라이스가 작고, 우선 순위가 낮을 수록 타임 슬라이스가 크다.
  - 우선 순위가 높은 Queue에 있던 프로세스가 CPU를 강제로 뺏기게 되면 우선 순위가 낮은 Queue로 이동한다.
  - CPU를 강제로 뺏기는 횟수가 많아질수록 우선 순위가 낮은 Queue로 내려가면서 타임 슬라이스가 크기 때문에 CPU 할당 시간을 길게 받을 수 있다.

## 프로세스 동기화

- 프로세스들이 실행하면서 같이 쓰는 변수나 파일들이 있는데 이를 **`공유 자원이라`** 부른다.
- 공유 자원은 여러 프로세스들이 공유하기 때문에 프로세스의 접근 순서에 따라 결과가 달라질 수 있다.
  - OS가 프로세스의 실행 순서를 결정하기 때문에 프로세스 입장에서는 공유자원 실행 순서에 대한 예측이 힘들다.
  - 공유 자원에 대한 **`프로세스 실행 순서에 따라 동기화 문제가 발생할 수 있다`**.
- 동기화 문제가 발생하는, 여러 프로세스가 동시에 사용하면 안 되는 영역을 임계 구역이라고 부른다.
- 동기화 문제를 해결하기 위해 뮤텍스나 세마포어, 프로그램 언어 레벨에서 제공하는 방법을 사용할 수 있다.

## 메모리

- CPU는 계산할 때 메인 메모리에 있는 값 -> 레지스터로 가져와 계산 -> 다시 메인 메모리에 저장
- 레지스터는 굉장히 빠른 반면, 메모리는 상대적으로 굉장히 느림
  - 메인 메모리에 있는 데이터를 레지스터로 옮기려면 한참 걸리기 때문에 필요할 것 같은 데이터를 미리 캐시에 저장

### 메모리 주소와 할당 방식

- 메모리에 여러 프로그램들이 실행되기 때문에 OS는 메모리를 1바이트로 나누고 숫자를 매긴다. 이 숫자를 주소라고 부른다.
- 메모리는 물리적인 주소와 사용자가 보는 논리적인 주소가 존재
  - 사용자는 물리적인 주소를 몰라도 논리적인 주소로 물리 주소에 접근이 가능
- 메모리에 여러 프로세스를 할당 할 때 아래 두 가지 방법을 고려 할 수 있음
  - **가변 분할 방식 (세그멘테이션)**: 프로세스 크기에 따라 메모리를 나누는 방식
  - **고정 분할 방식 (페이징)**: 프로세스 크기와 상관없이 메모리를 정해진 크기로 나눈다.
- 오늘날의 메모리 할당은 가변 분할과 고정 분할의 장점을 섞어서 적용
  - 2의 승수로 메모리를 연속적인 여러 크기로 분할 (1024, 512, 256, 256 바이트)
  - 500 Byte 프로세스가 메모리 할당이 필요하면 512 공간에 할당
  - 사용이 완료되고 더 큰 프로세스 할당이 필요하면, 2의 승수로 연속적인 메모리 공간이기 때문에 쉽게 확보가 가능

## 가상 메모리

- 컴퓨터의 메모리가 4GB이고, 실행에 메모리 4GB가 필요한 프로세스가 5개가 동작한다면 어떻게 메모리를 사용할까?
- 컴퓨터의 메모리 관리자는 **`실제 메모리와 하드 디스크의 스왑 영역을 사용해서 할당한다`**.
  - 메모리 일부를 스왑 영역이 있는 하드 디스크로 옮기고 처리가 필요할 때 물리 메모리에서 가져온다.
  - 가상 메모리의 크기는 물리 메모리 + 스왑 영역을 합친 것
- 메모리 관리자는 메모리와 스왑 영역을 합쳐서 프로세스의 가상 주소를 물리 주소로 변환하는데 이를 **`동적 주소 변환 (Dynamic Address Translation)이라`** 부른다.
- 메모리 관리자는 메모리를 배치할 때 고정 + 가변 분할 방식을 사용하는데 이를 세그멘테이션-페이징 기법이라 부른다.

### 세그멘테이션

- 프로세스가 가진 논리 주소를 메모리 관리자가 물리 주소로 변환해 준다.
- 메모리 관리자는 세그멘테이션 테이블을 가지고 있어, Base Address, Bound Address가 저장되어 있고 이를 이용해 물리 메모리 주소를 계산한다.

### 페이징

- 프로세스가 보는 논리적인 메모리를 **`정해진 크기의 페이지로 나누는 기법을`** **페이징**이라고 한다.
- 물리적인 주소도 페이지 크기와 동일하게 나뉘는데 이를 프레임이라고 부른다.
- 메모리 관리자는 페이지 테이블을 가지고 있어 논리 주소에 대한 페이지와 오프셋을 이용해 물리 주소로 변환한다.
- 페이징과 세그멘테이션은 굉장히 비슷해 보이는데 차이점 중 하나로는 분할된 메모리의 크기이다.
  - 세그먼테이션은 프로세스마다 크기가 달라 Bound Address를 갖는다.
  - 페이징은 모든 페이지의 크기가 동일해서 크기를 표현하는 Bound Address가 필요없다.

### 디맨딩 페이징

- 프로세스의 코드, 데이터, 힙, 스택 영역은 전체가 아닌 필요한 모듈만 올라와서 실행된다.
- **`지역성 이론`**
  - 공간의 지역성: 현재 위치와 가까운 데이터에 접근할 확률이 높음
  - 시간의 지역성: 최근 접근했던 데이터가 오래 전에 접근한 데이터보다 사용할 확률이 높음
- 디맨딩 페이징은 필요할 것 같은 데이터를 메모리로 가져오고 사용하지 않을 것 같은 데이터는 스왑 영역으로 이동시키는 정책
- 결론적으로 프로세스가 실행될 때 모든 모듈이 메모리에 올라와 있는 것은 아니다.

### 페이지 교체 정책

- 프로세스는 데이터를 접근하기 위해 메모리를 참조하는데, 데이터가 메모리에 없으면 **Page Fault**가 발생
- 메모리가 꽉 차서 공간이 없을 때 Page Fault가 발생하면 메모리에 있는 페이지를 Swap 영역으로 옮겨야 한다.
- 이때 어떤 페이지를 Swap 영역으로 옮길지 결정하는 정책을 페이지 교체 정책이라 부름
  - 여기도 FIFO, LRU(Least Recently Used) 같은 정책들이 존재
