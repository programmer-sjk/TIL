# 정규 표현식 (Regular Expression)

- 일반 문자열 찾기
  - `/Hello/.exec("Hello, World")`
  - `/Hello/.exec("hello, World")` -> 대소문자 구별하므로 찾는 값이 없다
- 정규 표현식에 사용되는 문자열을 검색할 때
  - **백슬래쉬로** 패턴이 아닌 문자로 인식
    - `/\$/.exec("$$abc123$$")`

## 앵커(^, $)란 무엇인가

- **`시작 앵커(^), 마지막 앵커($)가`** 존재
- 앞에서 시작하는 패턴(`^`)
  - `/^Hello/.test("Hello, World")`
- 뒤에서 시작하는 패턴(`$`)
  - `/Hello$/.test("World, Hello")`
- `$`로 시작하는 문자열
  - `/^\$/.exec("$$abc123$$")`
- `$`로 끝나는 문자열
  - `/\$$/.exec("$$abc123$$")`

## 모든 문자를 의미하는 닷 (.)

- 하나의 어떤 문자를 찾는 패턴
  - `/./.exec("a")`
- 6글자의 어떤 문자를 찾는 패턴
  - `/....../.exec("abcdef")`
- 문자열에서 .을 찾는 패턴
  - `/\./.exec("O.K.")`
- 문자열에서 `.X.`(X는 어떤 문자열이든 가능) 찾는 패턴
  - `/\..\./.exec("O.K.")`

## 문자의 집합 패턴 []

- 주어진 문자열 `삼성카드(1234) 승인 서*국 5,000원`
- `삼성카드 or 우리카드` 문자열을 찾는 패턴
  - `/[삼우][성리]카드/.exec("삼성카드(1234) 승인 서*국 5,000원")`
- `일성카드 or 이성카드 or 삼성카드` 문자열을 찾는 패턴
  - `/[일이삼]성카드/.exec("삼성카드(1234) 승인 서*국 5,000원")`
- 삼성카드가 아닌 문자열을 찾는 패턴
  - `/[^삼]성카드/.exec("삼성카드(1234) 승인 서*국 5,000원")`
- 일성카드와 삼성카드가 아닌 문자열을 찾는 패턴
  - `/[^일삼]성카드/.exec("삼성카드(1234) 승인 서*국 5,000원")`

## 범위 패턴 [-]

- A와 Z 사이에 있는 문자를 포함하는 패턴
  - `/[A-Z]/.exec("ABCDEFGHIJKLMNOPQR")`
- 알파벳을 포함하는 패턴
  - `/[A-Za-z]/.exec("ABCDEFGHIJKLabsdijz")`
- 숫자 0, 9사이에 있는 문자를 포함하는 패턴
  - `/[0-9]/.exec("29")`
- C와 K, a와 d, 2에서 6까지 문자를 포함하는 패턴
  - `/[C-Ka-d2-6]/.exec("29")`
- 모든 한글 범위를 지정하는 패턴
  - `/[가-힣]/`
- `^`이 범위패턴에 있을 경우 not을 의미
  - A,B,4,5가 아닌 문자가 있는 문자열
    - `/[^AB45]/.exec("CDEF123")`
  - A에서 K까지 포함되지 않은 문자열
    - `/[^A-K]/.exec("WYZ")`

## 그룹핑 & 캡처링

### 그룹핑

- `()`로 문자를 감싸면 그게 하나의 문자로 그룹핑 하는 개념
- `/(Hello){2}/.test('HelloHello')`
- Monday나 TuesDay나 Friday를 가진 문자열
  - `/(Monday|Tuesday|Friday)/.exec("Monday Tuesday Friday")`
- 위랑 동일한 결과를 나타내는 다른 패턴
  - `/(Mon|Tues|Fri)day/.exec("Monday Tuesday Friday")`
  - `/..(n|es|i)day/.exec("Monday Tuesday Friday")`
- google에 접속 가능한 모든 도메인을 찾는 패턴
  - `/(https?:\/\/)?google\.com/`

### 캡처링

- 그룹핑한 문자를 저장했다가 꺼내는 개념
- `(Hi)\1`
  - `\1`은 첫 번째 매칭결과로 저장해둔 Hi를 꺼낸다.
- 반복되는 문자를 찾는 패턴
  - `/([a-z])\1/.test('abcabcdde')`

## 수량자 (어떤 패턴이 얼마나 등장하는가)

- `*`: \* 앞에 오는 문자가 0 ~ 여러개
  - `<p></p> or <p>123abc하하</p>` 처럼 태그 사이에 문자가 없거나 있는 패턴
    - `<p>.*<\/p>`
  - 모든 텍스트를 선택
    - `/.*/.exec("abcdef123213123ABCDE#*@$&*%*@#&$%@$#")`
- `+`: + 앞에 오는 문자가 1 ~ 여러개
  - `api.test.com` 같은 도메인 패턴
    - `\w+\.\w+\.\w+`
  - `*`가 1개 이상
    - `/\*+/.exec("-@@@-***--'*'--***-@@@-")`
  - 공백이 아닌 문자가 하나 이상
    - `/[^ ]+/.exec("-@@@-***--'*'--***-@@@-")`
- `?`: ? 앞에 오는 문자가 없거나 1개인 경우
  - 핸드폰 번호 검증 (-가 있을 수도 없을 수도)
    - `\d{3}-?\d{4}-?\d{4}`
      - `010-1111-2222 or 01011112222` 모두 검증 가능
- `{}` 패턴
  - 어떤 문자든 5개 패턴
    - `/.{5}/.exec("안녕하세요")`
  - 문자 e,l,s가 1개 이상 3개 이하
    - `/[els]{1,3}/.exec("he is really handsome")`
  - 문자 a~z까지 3개 이상
    - `/[a-z]{3,}/.exec("he is really handsome")`
- 수량자의 동일한 패턴 예시
  - `AB*A` = `AB{0,}A`
  - `AB+A` = `AB{1,}A`
  - `AB?A` = `AB{0,1}A`
- 수량자 뒤에 `?`가 나오는 경우
  - `*, +, ?` 뒤에 `?`가 나오면 각 수량자의 최소 값을 의미
  - `*?` 의 경우 0, `+?`의 경우 1, `??`의 경우 0
    - r 로만 시작하는 문자
      - `/r.*?/.exec("ring ding dong")`
    - r 다음 아무 문자로 시작하는 문자
      - `/r.+?/.exec("ring ding dong")`

## d,w,s 캐릭터 클래스

- `\d, \w, \s` 는 각각 모든 숫자, 모든 영어 & 숫자, 모든 공백을 의미
- `\D, \W, \S` 는 각각 모든 숫자가 아닌 것, 모든 영어 & 숫자가 아닌 것, 모든 공백이 아닌 것을 의미
- 단어 `(\w)` 패턴은 `[A-z0-9_]` 패턴과 동일
  - 알파벳, 숫자, `_`가 포함된 문자 탐색
    - `/\w/.exec("A1 B2 c3 d_4 e:5 ffGG77--___--")`
  - a~z 사이의 문자가 오고 단어가 포함된 탐색
    - `/[a-z]\w*/.exec("A1 B2 c3 d_4 e:5 ffGG77--___--")`
  - 문자 5개
    - `/\w{5}/.exec("A1 B2 c3 d_4 e:5 ffGG77--___--")`
  - 단어가 아닌 것은 대문자 W (`\W`) -> 공백과 특수문자를 찾음
    - `/\W/.exec("A1 B2 c3 d_4 e:5 ffGG77--___--")`
- 바운더리
  - 단어의 시작이나 끝의 바운더리를 지정 `\b`
  - `cat concat` 문자열이 있을 떄 `\bcat`은 앞의 문자 cat을 `cat\b`는 뒤에 concat의 cat을 지정

## 탐색

- 전방 탐색
  - `(?=)` 패턴은 전방 탐색으로 찾을때는 문자를 포함하지만 반환할 때 대입된 문자는 포함시키지 않는다.
  - `test@gmail.com".match(/.+(?=@)/)` -> `@` 앞에 있는 1개 이상의 문자열 찾음 (결과: test)
  - `\w+(?=X)` -> X앞에 문자가 1개 이상 포함된 문자열을 찾지만 반환할 때 X는 제외된다.
- 후방 탐색
  - `(?<=)` 패턴은 후방 탐색으로 특정 문자 이후에 나오는 문자열을 찾는다.
  - `"test@gmail.com".match(/(?<=@).+/)` -> `@` 뒤에 나오는 1개 이상의 문자열 찾음 (결과: gmail.com)

## 플래그 (i, g, m)

- 정규식이 어떻게 작동할지 결정하는 옵션
- `i 옵션`
  - 영어 대/소문자를 구분하지 않겠다
  - `/[a-z]{3}/i.test('ABC')`
- `g 옵션`
  - 모든 문자열에서 매칭되는 부분을 탐색
  - `/[a-z]/g.test('a b c')`
- `m 옵션`
  - **multiline**을 의미하며 여러 줄로 된 문자열을 매칭
  - [로그]로 시작하고 에러로 끝나는 전체 문자열
    - `/^\[로그\]\s.+에러$/gm`

## String vs Regex

- JavaScript에서 정규 표현식을 사용할 때 각 메서드에 알아보자.
- String 메서드

  - match
    - ex) `"This is a cat. The cat is cute".match(/cat/)`
    - 정규 표현식에 g 옵션이 없다면 처음 매칭된 결과를 리턴하고 g 옵션이 있다면 전체 매칭된 결과를 리턴
  - matchAll
    - ex) `"This is a cat. The cat is cute".matchAll(/cat/g)`
    - match에 g 옵션을 준 것과 동일하며 matchAll에 사용되는 정규 표현식에 g 옵션이 없으면 타입 에러가 발생
    - match의 경우 g 옵션이 있으면 index나 원문 정보는 반환되지 않는데, matchAll은 index나 원문 정보를 반환

- Regex 메서드
  - exec
    - ex) `/cat/.exec("This is a cat. The cat is cute")`
    - 정규 표현식에 g 옵션을 줘도 처음 매치한 결과만 반환한다.
  - test
    - 정규 표현식에 매칭되는 결과를 boolean으로 반환한다.
  - Literal vs 생성자
    - Regex는 아래와 같이 2 가지 방식으로 생성할 수 있다.
      - `/cat/.exec("This cat") vs new RegExp("cat").exec("This cat")`
      - 차이점은 Literal은 한 번 생성되고 재 사용이 가능하지만 new RegExp는 매번 정규 표현식 객체를 재 생성한다.
- 사용법 정리
  - 단순히 일치 여부가 필요하다면 test 메서드를 사용하자.
  - 한 번 매칭된 결과가 필요하다면 match or exec 메서드를 사용할 수 있는데 exec가 조금 더 빠르다. (거의 차이는 없음)
    - [벤치 마크](https://www.measurethat.net/Benchmarks/Show/11160/0/regexexec-vs-stringmatch)
  - 매칭되는 전체 결과가 필요하다면 match나 matchAll 메서드를 사용하자.
  - 정규 표현식이 달라지지 않는다면 Literal이 매 번 객체를 생성하지 않기 때문에 조금 더 빠르다.

## 자주 사용되는 정규 표현식

- 핸드폰
  - `/^\d{3}-\d{3,4}-\d{4}$/`
- 패스워드 (최소 8자 이상, 소문자/대문자/번호 최소 1개 포함, 특수문자 포함)
  - `/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/`
- 이메일
  - `/^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/`

## 정규식 연습 사이트

- [RegExr](https://regexr.com/): UI가 훨씬 깔끔. 작성한 정규식의 설명이나 다른 사람들의 패턴 확인 가능
- [Regex101](https://regex101.com/): 정규식과 내용을 통해 바로 확인 가능
