# 구글 엔지니어는 이렇게 일한다.

## 1. 소프트웨어 엔지니어링이란?

- 프로그래밍과 SW 엔지니어링의 가장 큰 차이는 `시간, 확장, 실전`에서 트레이드 오프라 생각한다.
- 구글에선 가끔 SW 엔지니어링은 흐르는 시간 위에서 순간순간의 프로그래밍을 모두 합산한 것이라고 말한다.

### 1.1 시간과 변경

- 변경에 대응할 수는 있어야 한다. 시스템 관리자는 상황이 닥쳤을 때 복구를 정확히 어떻게 수행하는지와
그 비용까지 알고 있어야 한다. 연습하여 숙달시켜야만 효율과 안정성을 높일 수 있다는 걸 명심해라

### 1.2 규모 확장과 효율성

- SW 조직에서 가장 중요한 자산인 코드베이스 자체도 확장가능해야 한다.
  - 빌드, 버전 관리 시스템이 점점 느려지면 전체 빌드에 걸리는 시간, 리포지터리 전체를 새로 내려받는 시간 같은 지표는 천천히 악화된다. 따라서 이런 문제들은 조직 차원에서 챙기며 확장 가능성에 신경써야 한다.

### 1.3 트레이드오프와 비용

- 구글에서는 `내가 시켰으니까` 방식을 아주 싫어한다. 물론 한 명의 결정권자를 두고 잘못된 결정이라 판단될 때
찾아가야 할 사람들도 명확히 정의해야 하지만, 그 목적은 독재가 아니라 합의를 도출하는데 있다.

### 1.4 소프트웨어 엔지니어링 VS 프로그래밍

- 소프트웨어 엔지니어링이 프로그래밍보다 우수하다는게 아니다. 가치와 모범사례가 서로 다르다는 것이다. 며칠만 활용할 프로젝트라면 통합테스트나 지속적 배포(CD)에 목맬 필요가 없다. 그 대신 과업을 쉽게 해결하기 위해 활용할 수 이는 방법을 찾아라.
- 소프트웨어 엔지니어링과 프로그래밍의 차이는 `시간 흐름에 따른 코드관리, 시간 흐름에 따른 규모확장의 영향`, 이런 관점에서의 의사결정 방식에 있다.
- **프로그래밍**은 코드를 생산하는 즉각적인 행위이고 **소프트웨어 엔지니어링**은 오랫동안 코드를 유용하게 관리하고 팀 간 협업을 가능케 하는 정책, 관례, 도구 모두를 아우르는 종합적인 개념이다.

## 2. 팀워크 이끌어내기

- 엔지니어링 팀이 성공하려면 겸손, 존중, 신뢰라는 원칙에 맞게 자신의 행동을 바로잡아야 한다.

### 2.1 내 코드를 숨기고 싶어요.

- 사람들은 자신이 진행중인 작업물을 다른 사람이 보고 판단하는 걸 두려워한다. 어쩌면 이런 두려움은 인간의 본성에 속할 것이다. 누구라도 비난받고 싶어 하지 않으며 작업물이 완성되기 전이라면 더욱 그렇다.

### 2.2 천재 신화

- SW 엔지니어들에게 리누스 토발스, 귀도 반 로섬, 빌 게이츠 같은 사람들은 영웅적인 업적으로 세상을 바꾼 아이돌일 것이다. 하지만 실제는 초기 버전만 발표하고 수 많은 천재들과 함께 결과를 일구어냈다.
- 천재 신화는 결국 우리 내면의 불안을 드러내는 또 다른 사례일 뿐이다.

### 2.3 숨기는 건 해롭다.

- 자신이 혼자 일한다면 실패할 위험성을 키우고 자신의 성장 잠재력을 속이는 것이다. 무엇보다 자신이 올바른 길을 걷고 있음을 어떻게 확신할 수 있나?
- **조기 감지**
  - 초기 설계에는 근본적인 실수가 있기 쉽다. 따라서 빨리 피드백을 받는게 중요하다. 일찍 실패하고, 빨리 실패하고 자주 실패하라.
- **버스 지수** (몇 명의 팀원이 버스에 치어서 일을 할 수 없게 될 때 프로젝트가 망하게 되는지를 나타내는 지수)
  - 현재 코드를 이해하는게 나뿐이라면 내가 해고될 일은 없지만 내가 버스에 치이면 프로젝트는 망하게 된다.
  - 내 지식을 동료 한 명과 공유한다면 버스 지수는 2배가 된다. 팀원 한 명이 사라져도 프로젝트는잘 굴러갈 것이다.
- **진척 속도**
  - 프로그래머는 긴밀하게 피드백을 받을 때 가장 효율적으로 일한다. 동굴에 갇혀버리면 원래의 비전을 완성하는 동안 세상이 바뀌어 있을 것이다.
- 결론은 숨기지 말자.

### 2.4 모든 건 팀에 달렸다.

- 좋은 팀은 슈퍼스타를 잘 활용하지만 전체가 항상 개인의 합보다 크다.
- 사회적 상호작용의 세 기둥
  - 좋은 SW를 만드는 최선의 길이 팀워크라면 어떻게 팀을 만들어야 할까?
    - 사회적 스킬의 세 기둥인 **겸손, 존중, 신뢰**를 익혀야 한다.
    - 곰곰히 생각해보자. 모든 사람이 만족할 만큼 겸손한가? 다른 이들을 존중하는가? 서로 신뢰하나?
- **겸손, 존중, 신뢰 실천하기**
  - **자존심 버리기**
    - 자신감은 좋지만 모든걸 다 아는듯 행동하지 말아라.
    - 팀의 성취와 단체의 자부심을 높이려 노력하라.
  - **비평하고 비평받는 법 배우기**
    - 누군가에 대한 건설적인 비평과 다른이의 성향에 대한 공격은 차이가 있다.
      - 건설적 비판은 상대방을 진심으로 생각하고 상대방의 업무가 개선되길 바라야 한다는 것이다.
    - **비평을 잘 수용하자.**
      - 상대방이 나를 어리석다고 생각하는게 아님을 믿어야 한다.
      - **나는 내 코드가 아니다**라고 반복해서 되뇌어라. 여러분 자신과 여러분이 만든 것을 구분지어라.
    - 누군가에게 잘못했다. 라고 해서는 안 된다. 무엇을 고치라고 요구해서도 안 된다.
  - **빠르게 실패하고 반복하기**
    - 구글에서 저자가 제일 좋아하는 좌우명은 실패는 선택이다. 라는말이다. 실패는 배우고 다음 단계로 넘어갈 수 있는 절호의 기회라고 생각하는 것이다.
- **비난 없는 포스트모템 문화**
  - 실패한 원인을 분석해서 문서로 남기는 것이 실수로부터 배우는 핵심인데 이를 **포스트모템**이라고 한다.
  - 포스트모템 문서가 쓸모없는 사죄, 변명, 지적으로 채워지지 않도록 주의하자.
  - 실패를 기록해두면 다른이들도 무슨 일이 있었는지 알 수 있고 똑같은 실수를 반복하는 일을 피할 수 있다. 여러분이 걸어간 발자취를 지우지 말고 활주로처럼 빛을 밝혀 후임들이 올바른 길을 빠르게 찾을 수 있도록 도와야한다.
  - **좋은 포스트 모템**은 아래의 내용이 담겨야 한다.
    - 사건의 개요
    - 사건을 인지하고 해결에 이르기까지 타임라인
    - 사건의 원인
    - 영향과 피해 평가
    - 문제를 즉시 해결하기 위한 조치 항목
    - 재발 방지를 위한 항목
    - 해당 경험에서 얻은 교훈

### 2.5 마치며

- 소프트웨어 조직이 오래 지속되려면 겸손과 신뢰, 팀을 중심으로 존중에 뿌리를 둔 건강한 문화를 갖춰야 한다.
- 소프트웨어 개발은 창의적인 일이므로 위험을 감수할 줄 알아야 하고, 때로는 실패할 줄도 알아야 한다.

## 3. 지식 공유

### 3.1 배움을 가로막는 장애물

- 구글은 회사 규모가 커지면서 **다음의 문제**들을 겪었다.
  - **심리적 안전 부족**: 불이익이 두려워 위험감수나 실수를 드러내기 꺼리는 환경
  - **정보 섬**: 소통의 부재로 지식의 파편화
  - **단일 장애점**: 중요한 정보를 한 사람이 독점하면 병목이 생김
  - **전부/전무 전문성**: 모든것을 아는 사람과 아무것도 모르는 초심자로 나뉘는 현상
  - **앵무새처럼 흉내내기**: 이해하지 못한 상태로 흉내만 냄
  - **유령의 묘지**: 잘못될 게 두려워서 아무도 손대지 않는 코드

### 3.2 철학

- 문서화된 지식은 **팀을 넘어 조직 전체로** 퍼뜨릴 수 있다. 전문가는 기록되지 않은 지식을 문서로 정리해
관리한다면 전문가에게 직접 도움을 청할 수 있는 사람들은 물론 해당 문서를 찾아 읽을 수 있는 사람 모두에게
지식을 전파할 수 있다.

### 3.3 판 깔아주기: 심리적 안전

- 자신이 이해하지 못한게 있음을 인정해야 무엇을 배울 수 있다. 그러니 **타인의 무지를 탓하지 말고 그 솔직함을 반겨야 한다.**
- 무언가를 시도하다가 실패해도 안전하다는 인식이 엄청나게 중요하다. 건강한 환경에서 사람들은 질문을 던지고 틀리고 새로운 지식을 얻는걸 편안하게 생각한다.
- 멘토 제도
  - 공식 멘토를 정해주면 신규 입사자는 편히 궁금한 걸 질문할 수 있다.
- 큰 그룹에서 심리적 안전
  - 대부분의 사람들은 바로 **옆 동료에게 도움을 청하는 걸 더 편하게** 생각한다.
  - 신규 입사자는 부담 없이 질문할 수 있도록 큰 그룹에서는 심리적 안전이 더욱 중요해진다.

### 3.4 내 지식 키우기

- 질문하기
  - **초심자가 저지르는 가장 큰 실수**는 무언가 막혔을 때 **질문하지 않는 것**이다.
  - 구글에서 몇 년을 일한 엔지니어도 어떻게 할지 모르는 영역이 존재하며 전혀 문제 될 일이 아니다. **질문하는 걸 두려워하지 말아라.** 모르는 분야가 나오면 두려워하지 말고 성장하는 기회로 받아들여라.
  - 팀의 리더든 새로운 멤버든 항상 무언가 배울게 있는 환경에 있어야 한다. 그렇지 않으면 새로운 환경을 찾아 떠날 것이다.

### 3.6 지식 확장하기: 누구나 가르칠 게 있다.

- 오피스 아워: 때로는 혼자 고민하던 게 사람들과 이야기를 하면서 쉽게 풀릴 수 있다.
- 문서자료
  - 무언가를 **막 배운 순간이 기존 문서에서 개선점을 찾기에 가장 좋은 때**이다. 시스템이 익숙해지면 어떤 내용이 어려웠는지 혹은 문서에서 누락된 내용을 잊어버리기 쉽다. 처음 문서를 보고 배우는 단계에서 실수나 빠진 부분을 발견한다면 바로 고쳐라.
  - 작업하는 내용을 문서화하고 기존 문서들을 갱신하라. 그 후에 다른 사람들에게 공유하여 내가 걸어간 길을 쉽게 따라오도록 하고, 다른 사람들이 문서를 찾기 쉽게 하자. 발견할 수 없고 검색되지 않는 문서자료는 존재하지 않는 것과 다를바가 없다.

### 3.7 조직의 지식 확장하기

- 존중
  - 몇 개인의 나쁜 행동으로 팀 문화가 안 좋은 방향으로 가지 않도록 해야한다.
  - 지식을 공유할 때 상냥함과 존중을 담아야만 한다.
  - 좋은 리더는 주변 사람들을 성장시키고, 팀의 심리적 안전, 긴장을 해소하고 더 활기차고 신나는 일터로 바꿔야 한다.
- 보상과 인정
  - 좋은 문화는 적극적으로 육성하고, 지식 공유 문화를 장려하면 인정과 보상 제도가 뒷받침되어야 한다.
  - 사람들은 진부한 칭찬보다는 확실한 보상에서 동기를 얻는다.

## 4. 공정 사회를 위한 엔지니어링

- 다양한 계층의 사용자를 위한 제품을 설계할 때 엔지니어가 짊어져야 하는 책임에 관해 이야기한다.
- 다양한 사용자 층을 포용하려면 조직 구성 측면에서도 다양성을 갖춰야 한다.
- 제품 개발속도는 모든 사용자에게 진정 유용해야 한다는 관점에서 평가되어야 한다. 만약 일부 사용자에게 해를
끼칠 수 있는 제품이라면 출시를 늦추는게 낫다.
- (내 생각) 구글이 글로벌 서비스다 보니 다양한 계층의 사람들을 위한 서비스를 만들기 위해 고려할 것을 담은 내용.

## 5. 팀 이끌기

- 구글에서는 리더 역할을 두 가지로 분류하는데 사람을 이끄는 **관리자와 기술에 대한 책임을 지는 테크 리더**다.

### 5.1 관리자와 테크 리드

- 관리자와 테크 리드는 엔지니어링 팀의 성장과 생산성에 많은 영향을 주지만, **관리자에게는 대인 관계 측면의 기술이 더 요구**된다.
- 테크 리드는 개인이 개발하기도 해서 떄로는 직접 나서서 빠르게 일을 처리할지, 아니면 속도는 더디더라도 다른 팀원에게 위임할지를 판단해야 한다. **팀의 규모와 역량이 커질수록 위임하는 편이 낫다.**

### 5.2 개인 기여자에서 리더로

- 경력이 쌓이면 원치 않더라도 리더의 위치에 올라간 자신을 볼 수 있다.
- 코드를 정말 잘 짜지만 팀을 이끌 마음이 없는 사람을 관리자 역할을 맡기면 **형편없는 관리자를 얻는 대신 뛰어난 엔지니어를 잃게 된다.** 회사의 승진 체계만으로 직원을 억지로 관리자에 올리면 안 된다.
- 리더로서 해야 할 **가장 중요한 일은 팀을 떠받는 것**이다. 팀을 섬기는 리더로서 `겸손, 존중, 신뢰`의 분위기를 조성해야 한다. 예를 들어 팀원 혼자서는 제거할 수 없는 장애물을 치워주고, 팀이 합의에 이르도록 도와주고, 누군가 야근할 때 저녁을 사주는 일도 될 수 있다.

### 5.3 엔지니어링 관리자

- 전통적인 관리자는 일을 어떻게 처리할지 고민하는 반면, 훌륭한 관리자는 무슨 일을 처리할지 고민한다. (어떻게는 팀에게 믿고 맡긴다.)
- 실패는 선택이다.
  - 사람들은 대부분 위험을 정확하게 평가하지 못하며, 회사는 대부분 위험을 회피하려 한다. 그래서 보통은 작은 성공에 집중하는 보수적인 전략을 택한다.
  - 구글에서는 `불가능한 목표에 도전해 실패하면, 성공이 확실한 일을 이뤄낸 것 보다 더 큰 것을 얻을 수 있다.` 라고 생각한다. 그러니 실패해도 괜찮다라는 사실을 분명하게 공표해라.
  - 개인이 이룬 성취는 팀이 보는 앞에서 칭찬하고, 실패한 개인에게는 개인적으로 따로 불러서 건설적인 비판을 해야 한다. 어떤 경우든 배울 기회로 삼고 `겸손, 존중, 신뢰`라는 원칙하에 행동해라.


### 5.4 안티패턴

- 성공적인 테크 리드와 관리자로 만들어주는 패턴들을 준비했는데, 우선 하면 안되는 안티패턴부터 살펴보자.
- 만만한 사람 고용하기
  - 여러분보다 똑똑하고 여러분을 대체할 역량을 갖춘 사람들을 적극적으로 뽑아라.
- 저성과자 방치하기
  - 저성과자와 직접 대면하여 중요하고 필요한 변화를 촉진시켜라.
- 사람 문제 무시하기
  - 관리자는 사회적 문제와 기술적 문제에 신경써야 한다. 사람의 문제를 소홀히 하지 말아라.
- 만인의 친구되기
  - 팀과의 친밀한 우정 없이도 or 독불장군이 되지 않고도 팀을 이끌고 합의를 이끌어 낼 수 있음을 기억해라.
  - 추천하는 방법으로는 팀과 점심을 함께 먹으며 업무 외적인 대화를 나누는게 사회적 유대를 유지하는데 효과가 크다.
- 채용 기준 타협하기
  - 스티븐 잡스는 A급 인재는 A급 인재를 뽑고, B급 인재는 C급 인재를 뽑는다고 말했다.
  - 사람을 급하게 채용할 때 채용 기준에 미달하더라도 지원자 중 제일 나은 사람을 채용하게 된다.
  - **적합한 사람을 찾는데 드는 비용은, 애초에 뽑지 말아야할 사람이 들어와서 관리하는 비용**에 비하면 아무것도 아니다.
- 팀을 어린이처럼 대하기
  - **특정 팀원을 믿지 못해서 마이크로매니징** 할 수 밖에 없는 상황이 고착화된다면 여러분의 **채용을 잘못**한 것이다.


### 5.5 올바른 패턴

- **자존심 버리기**
  - 팀을 믿고, 팀원들의 능력과 기존에 이룬 성과들을 존중해야 한다는 뜻이다. 새로 합류한 팀원도 마찬가지다.
  - 리더도 모든 것을 알지 못하고, 잘못된 결정을 내릴 수 있다. 그럼에도 스스로 완벽한 듯 행동한다면 팀원들의 존경을 빠르게 잃어갈 것이다.
  - 누군가가 내가 내린 결정에 질문한다면 감사해야 한다. 질문자의 의도는 나를 더 잘 이해하려는 것임을 잊지 말아라. **훌륭하고 건설적인 비판을 해줄 사람을 찾기란 매우 어렵다.** 피드백을 수용하고 비판에 마음을 열어라.
- 촉매자 되기
  - 팀이 건설적인 방향으로 상호작용이 일어나도록 한다. 가장 일반적인 예시는 합의를 이끌어 내는 것이다.
- 선생이자 멘토 되기
  - 훌륭한 멘토라면 성장하는 팀에 발맞춰 멘티가 배우는데 쓰는 시간과 제품 개발에 기여하는 시간의 균형을 잘 잡아줘야 한다.
- 명확한 목표 세우기
  - 팀의 한 방향으로 빠르게 전진하기를 원한다면, 리더가 설정한 방향을 모든 팀원이 이해하고 동의해야 한다.
  - 팀이 방향과 목표를 정했다면 한 걸음 물러서서 더 많은 자율권을 준 뒤 **모두가 올바르게 가고 있는지 주기적으로 확인해라.**
- 정직하기
  - 팀 or 팀원이 듣고 싶어 하지 않는걸 말해야 할 때가 있다.
- 행복한지 확인하기
  - 리더는 팀의 생산성을 장기적으로 끌어올리기 위해 팀원들이 행복해하는지도 시간을 써야 한다.
  - 수시로 팀원들의 복지를 챙기고, 그들이 하는 일을 인정해주고, 일에 만족하는지 확인하라.

### 5.6 예상못한 질문

- 리더라면 회사 밖에서도 팀의 행복에 신경 써주는 게 좋다. 팀원들의 사생활까지 파고 들라는 이야기가 아니라
어떤 상황에 처해 있는지를 인지는 하고 있어야 왜 특정 팀원이 특정 기간에 생산성이 떨어지는지 혹은 더 열심히 일하는지가 눈에 들어온다.
- 경력과 경험을 챙겨주는 것도 팀원 행복에 큰 비중을 차지한다. **승진, 새로운 것 배우기, 의미있는 제품/서비스 런칭, 똑똑한 사람들과 일하기** 등. 좋은 리더는 팀원들이 이 모든걸 성취하게 할 방법을 고민하고, 이런 고민을 하고 있음을 팀원들이 알게 해야 한다.

### 5.7 그외 조언과 요령

- **위임하되, 곤란한 일은 직접 처리하자.**
  - 아무도 하려 들지 않는 지저분한 일을 종종 떠맡는게 팀원들의 존경을 이끌어내고 팀의 업무 속도를 높일 수 있다.
- **나를 대신할 사람을 찾아라**
  - 평생 지금과 똑같이 일하고 싶은게 아니라면 당신보다 똑똑한 사람을 채용해야 한다.
  - 적합한 팀원을 구했다면 그 사람에게 더 많은 책임을 질 기회를, 팀을 이끌어볼 기회를 줘야 한다.
- 팀에 엄호를 해주자
  - 회사 위쪽에서 무슨 일이 벌어지고 있는지 팀이 알게 해주는 것도 중요하지만 수 많은 불확실성과 팀 외부의 시시콜콜한 요구를 막아주는 일 또한 중요하다.
- 팀이 잘하고 있으면 칭찬하자
  - 누군가 일을 잘못 처리했을 때 알려주는 것처럼 잘 처리할 때도 알려주자. 기대 이상으로 잘했다면 팀 전체에 알려주자.
- 실패해도 쉽게 되돌릴 수 있는 일에는 `해보세요` 라고 말하자

### 5.8 사람은 식물과 같다

- 정체되어 있는 팀원에게는 동기를 부여하고, 산만하거나 무얼 해야 할지 몰라하는 팀원에게는 더 강하게 지시해야 한다.
- 동기 부여는 금전적인 보상처럼 바깥에서 기안하는 **외적동기와 내적동기**가 있다.
  - 어떤 책의 저자는 내적 동기부여 방법으로 **자율성, 숙련, 목적**을 이야기 했다.
  - 자율성은 다른 사람의 마이크로매니징 없이 스스로 행동할 수 있는 것을 말하며 이게 동기부여가 잘 되는 이유는 아래와 같다.
    - 제품과의 관계가 더 끈끈해진다.
    - 제품에 대한 주인 의식이 커진다.
  - 숙련은 현재 기술 수준을 높이고 새로운 것을 배울 기회를 제공한다. 숙련에 필요한 기회를 충분히 제공받은 사람들은 동기가 커지고 때론 야근도 불사한다. 구글은 칼날을 항상 예리하게 하기 위해 엔지니어들에게 새로운 것을 배우고 실력을 갈고닦을 기회를 제공한다.
  - 자신이 하는 일의 목적을 인식하게 도와주면 훨씬 적극적이고 생산적으로 바뀔 수 있다.

### 5.9 마치며

- 팀을 이끈다는 것은 소프트웨어 엔지니어가 되는 것과는 다른 일이다. 그래서 훌륭한 소프트웨어 엔지니어라고 해서 좋은 관리자가 되는 건 아니다. 좋은 관리자는 팀이 일을 스스로 잘하도록 돕고, 올바른 목표에 집중하게 하고, 조직 외부의 방해요소를 차단해준다. 겸손, 존중, 신뢰를 담아서 말이다.

## 6. 성장하는 조직 이끌기

### 6.1 늘 결정하라

- 팀을 관리한다는 사실은 더 많은걸 결정해야 한다는 뜻이다. 높은 수준에서 보면 리더의 역할은 사람들을 움직여서 어렵고 모호한 문제들을 풀게 이끄는 것이다.
- 어떤 트레이드 오프가 있는지 이해하면 이번 달에 수행할 최선의 결정을 내릴 수 있게 된다.

### 6.2 늘 떠나라

- 리더는 모호한 문제를 풀어줄 뿐만 아니라 맡은 조직에 **내가 없어도 스스로 문제를 풀 수 있게 유도**해야 한다.
- 리더 스스로가 `단일 장애점(SPOF)`이 되지 않도록 다른 사람들이 성장할 기회를 마련해줘야 한다.

### 6.3 늘 확장하라

- 리더에게 주어진 가장 **값진 자원(제한된 시간, 집중력, 에너지)**을 잘 관리하자.

## 7. 엔지니어링 생산성 측정하기

- 구글은 엔지니어링 생산성 전문가로 구성된 팀을 두는 것이 다양한 측면에서 유용하다는 점을 알았다.
- 개별 팀들은 자신만의 방식으로 생산성에 힘쓰는 대신, 하나의 팀이 복잡한 문제들의 해법에 대해 여러 방면으로 집중적으로 연구하는 것이다.
- 생상선 측정에 앞서 결과가 어떻든 실행가능한 조치로 이어지는지 확인해야 한다. 결과를 보고도 취할 수 있는 조치가 없다면 측정할 가치가 없다.

## 8. 스타일 가이드와 규칙

### 8.1 규칙이 필요한 이유

- 확립된 규칙과 지침은 조직이 커지더라도 일관되게 통용되는 공통의 코딩 어휘가 되준다.
- 어휘가 통일되면 엔지니어들은 **코드를 표현하는 형식보다 코드에 담을 내용에 집중**할 수 있다.

### 8.2 규칙 만들기

- **규칙의 양을 최소화한다.**
  - 모든걸 다 스타일 가이드에 넣어서는 안된다. 조직 내 모든 엔지니어들이 새로운 규칙을 익히고 적응하는데 비용이 들기 때문이다. 규칙이 너무 많다면 엔지니어들이 다 기억하지도 못할 것이고 새로 합류한 엔지니어도 적응하기 어렵다.
- 읽는 사람에게 맞춘다.
- 일관되어야 한다
  - 코드가 일관되게 작성되어 있다면 엔지니어들이 익숙하지 않은 부분을 볼일이 생겨도 빠르게 작업을 이어나갈 수 있다.

### 8.3 규칙 수정하기

- 구글의 스타일 가이드는 고정불변이 아니다. 시간이 흐르고 여건이 달라지면 과거에는 옳았던 결정이 현재는 최선이 아니게 될 수도 있다.
- 상황이 변하면 규칙도 달라져야 하니, 규칙이 만들어진 근거 데이터를 알고 있어야 한다.

### 8.6 마치며

- 모든 조직에는, 특히 구글처럼 큰 조직이라면 코드베이스의 복잡성을 관리하여 감당할 수 있는 수준으로 유지하는데, 규칙이 큰 도움이 된다.

## 9. 코드리뷰

### 9.3 코드 리뷰의 이점

- 잘 설계된 코드 리뷰 프로세스와 문화가 주는 이점은 아래와 같다.
  - 코드가 정확한지 확인해준다.
    - 정확성 평가가 주관적으로 흘러가지 않기 위해 일반적으로 변경자가 선택한 방식을 존중해준다.
    - 리뷰어는 **자신이 선호한다는 이유로 다른 안을 주장해서는 안 된다.** 물론 리뷰어가 대안을 제시하는 건 가능하지만 **이해하기 쉽거나 기능을 개선하는 대안**일 경우에만 제안한다.
    - 구글은 새로운 코드가 완벽하다고 합의될 때까지 기다리지 않고, 코드베이스를 개선한다고 인정되면 변경을 승인하도록 안내한다. 코드 리뷰의 속도를 높이는 수단 중 하나이다.
  - 변경된 코드를 다른 엔지니어도 잘 이해한다.
    - 리뷰어는 작성자가 선택한 설계를 존중해야 하지만 코드가 잘 이해되지 않으면 고객은 항상 옳다는 관점에서 질문하는 것은 좋다.
  - 코드 베이스가 일관되게 관리된다.
  - 팀이 소유권을 더 강하게 느낀다.
  - 지식이 공유된다.
    - 리뷰를 통해 리뷰어가 리뷰를 요청한 사람에게 도메인 지식을 전파하도록 이끌어준다.
    - 코드 리뷰에서 양방향 정보 교환이 이루어져 작성자는 물론 리뷰어도 새로운 기술이나 패턴을 배울 수 있다.

### 9.4 코드 리뷰 모범 사례

- 공손하고 전문가답게
  - 리뷰어들은 작성자가 선택한 방식을 존중하고 오직 그 방식에 결함이 있을 때만 대안을 제시해야 한다. 작성자가 다른 대안 중 특별히 더 우수한게 없음을 설명할 수 있다면 리뷰어들은 작성자의 취향을 받아들어여 한다.
  - 리뷰어는 작성자의 방식에 성급히 결론짓지 말아야 한다. 그 방식이 잘못되었다고 가정하기 전에 그렇게 처리하게 된 이유가 무엇인지 물어보는게 좋다.
  - 리뷰어는 신속하게 피드백해야 한다. 구글에서는 피드백이 24시간 내에 올 거라 기대한다.
- 작게 변경하기
  - 변경이 크면 리뷰하는 데도 그만큼 시간이 걸리는 반면, 작은 변경은 리뷰어의 부담을 줄여준다.
- 변경 설명 잘쓰기
  - 변경 설명에 단순히 버그 수정이라고 적으면 리뷰어와 관련 사람들에게 아무런 도움을 주지 못한다. 구체적으로 적고, 만약 수정이 여러개라면 그 모두를 간략하게 열거하라.
- **리뷰어는 최소한으로**
  - 구글에서 대부분의 코드 리뷰는 정확히 한 명의 리뷰어만으로 진행된다.
  - 변경 승인에 필요한 세가지 역할(LGTM, 소유자 승인, 가독성 승인)을 단 한 사람이 수행할 수 있게 허용하여 코드 리뷰 프로세스가 구글 규모에서도 잘 동작하도록 확장할 수 있었다.
  - 구글의 코드 리뷰는 엔지니어들이 일을 올바르게 처리할 것이라는 신뢰를 바탕으로 최적화 되어있다. **때에 따라서는 여럿이 검토**하는게 나을수도 있다.
- 가능한 자동화하기
  - 리뷰 프로세스 중 자동화 할 수 있는 요소는 자동화해라.
  - 리뷰 전에 테스트, 린터등의 문제가 검출되면 변경을 거부하고, 리뷰 요청이 리뷰어에게 전달되지 않게 차단하고, 작성자에게 코드 수정 후 다시 제출하라고 알려준다.

## 10. 문서자료

### 10.1 문서 자료란?

- 엔지니어가 작업을 끝마치기 위해 작성해야 하는 모든 부수적인 텍스트를 의미

### 10.2 문서자료가 필요한 이유

- 수동으로 해야하는 일은 절차가 잘 기술되어 있어야 쉬워지고, 새로운 인력이 팀이나 코드베이스에 적응하는데 드는 시간 역시 훨씬 줄어든다.
- 문서자료는 **단 한번만 작성한다면 수백 번, 수천 번 읽히게 된다.**

### 10.3 문서자료는 코드와 같다

- 코드처럼 문서도 소유자가 있다. 소유자가 없는 문서는 점점 낡아져서 유지보수 하기 어려워진다.

### 10.4 독자를 알자

- 엔지니어들이 종종 범하는 실수는 문서를 자신만을 위해 쓴다는 것이다. 하지만 그 문서가 사내의 모든 엔지니어와 외부 개발자까지 상당히 다양할 수 있기에 문서를 작성하기 전에 독자가 누구인지 생각해보는 일이 필요하다.

### 10.10 핵심 정리

- 문서자료는 시간이 흐르고 조직 규모가 커질수록 더 중요해진다.
- 문서자료 변경도 개발자 워크플로에 통합되어야 한다.
- 하나의 문서는 하나의 목적에 집중해야 한다.
- 문서는 자신이 아닌 독자를 위해 써야 한다.

## 11. 테스트 개요

- 버그를 잡는 것 뿐 아니라 SW가 변화할 수 있도록 지원하는 역할 역시 중요하다. 새로운 기능을 추가하거나 코드가 건실해지도록 리팩토링 하거나, 대규모 재설계를 진행하는 상황에서 테스트는 실수를 빠르게 잡아주므로 안심하고 변경할 수 있게 된다.

### 11.1 테스트를 작성하는 이유

- 테스트는 **엔지니어에게 신뢰를 줄 때만 가치가 있다.** 테스트가 생산성을 떨어뜨리고 결과를 믿을 수 없다면 엔지니어들은 더 이상 테스트를 신뢰하지 않게 된다.
- 테스트는 좋은 제품을 빠르게 만들 수 있게 해줄 뿐 아니라 서비스의 안전을 보장하는데도 점점 핵심적인 역할을 하고 있다.
- SW는 계속 커지고 복잡해진다. 따라서 QA팀으로 모든 행위를 수동으로 검증할 수 있는 한계를 아득히 넘어섰다. 그래서 테스트의 해법은 단 하나. 자동화뿐이다.
- 테스트를 작성했다면 테스트를 실행해야 한다. 자동 테스트의 핵심은 같은 동작을 끊임없이 반복하는데 있다. 실패하는 테스트가 해결되지 못하고 빠르게 쌓여간다면 테스트에 투자한 노력이 허사가 되니 그렇게 되지 않도록 하는게 중요하다.
- 건실한 자동 테스트 문화에서는 모두가 테스트를 작성하고 정기적으로 실행해야 한다. **가장 중요한 것은 테스트가 실패하면 바로 조치하도록 권장해야 테스트 프로세스를 신뢰**하고 계속 이어나갈 수 있다.
- 테스트 코드가 주는 혜택
  - 디버깅 감소
  - 안정감있는 리팩토링
  - 더 나은 문서자료
  - 더 단순한 리뷰
    - 정확성, 극단 상황, 오류 상황이 다 테스트로 준비되어 있다면 리뷰어 입장에서 제대로 작동하는지 검증하는 시간을 크게 줄여준다.
  - 더 나은 설계
    - 테스트하기 어려운 코드는 너무 역할이 많거나 의존성을 관리하기에 어렵게 짜여졌을 가능성이 크다.
  - 빠른 배포
    - 테스트 커버리지가 높을 경우, 새로운 버전을 배포하여 불안에 떨지 않아도 된다.

### 11.2 테스트 스위트 설계하기

- 테스트 크기
  - 구글에서는 모든 테스트를 크기 기준으로 분류하며, 엔지니어들에게 기능을 검사하는 가능한 작은 테스트를 작성하라고 독려한다.
  - 작은 테스트: 하나의 프로세스에서 실행되는 테스트
  - 중간 크기 테스트: 여러 프로세스에서 실행 할 수 있고 블로킹 호출도 이용할 수 있지만 외부 통신은 불허한다.
  - 큰 테스트: 테스트와 대상 시스템이 여러 기기를 활용할 수 있다.
  - 테스트 크기와 무관한 공통 특성
    - 모든 테스트는 밀폐되어 있어야 하며, 셋업 / 실행 / 테어다운 하는데 필요한 모든 정보를 담고 있어야 한다.
    - 테스트는 검증하기 위해 필요한 정보만을 포함해야 한다. 테스트가 깔끔하고 간결하면 리뷰어의 어깨를 가볍게 해준다.
    - 테스트는 무엇을 검사하는지가 명확해야 한다.
    - 테스트는 오직 실패했을 때만 들여다 본다는 사실을 기억해라. 코드는 읽히는 횟수가 훨씬 많다. 누군가 테스트 코드를 읽었을 때 부끄럽지 않도록 작성해라.
- 테스트 범위
  - 유닛 테스트(작은 범위)는 독립된 클래스나 메소드 같이 작은 일부 로직을 검증한다.
  - 통합 테스트(중간 범위)는 적은 수의 컴포넌트들 사이의 상호 작용을 검증한다. 가령 서버와 DB의 작용을 검증한다.
  - e2e 테스트(넓은 범위)는 시스템의 서로 다른 부분들의 상호작용을 검증한다.
  - 구글에서는 실행할 수 없는 상황이 아니라면 **모의 객체(mock) 보다는 실제 의존성을 끊지 않는 편을 선호**한다.
  - 구글은 되도록 작은 테스트를 추구하며 유닛 테스트가 80%, 통합 테스트가 15%, e2e 테스트가 5%가 되도록 한다.
  - 엔지니어들이 e2e 테스트를 많이 작성하고 통합/유닛 테스트를 적게 작성할 경우, 일반적으로 느리고 신뢰할 수 없게 된다.
- 코드 커버리지
  - 코드 커버리지는 어떤 테스트가 기능 코드의 어느 라인을 실행하는지 측정하는 수단이다.
  - 100 라인 코드가 있고 테스트가 90라인을 실행했다면 코드 커버리지는 90%이다.
  - 코드 커버리지는 테스트 되지 않은 코드가 어디있는지 알려줄 수는 있지만, 얼마나 제대로 테스트 되었느냐를 판가름하는 지표로는 적합하지 않다.

### 11.3 구글 규모의 테스트

- 구글은 모노리포에서 20억 라인이 넘는 코드를 관리한다. 코드베이스가 커지다 보면 기존 코드를 변경하는 일도 많이 발생하게 된다. 이때 자동 테스트가 엉망으로 작성되어 있다면 코드를 변경하기 어려워진다.
- 깨지기 쉬운 테스트, **예상 결과를 너무 세세하게 표현하는 테스트와 모의 객체를 오용하는 경우 꺠지기 쉬운 테스트를 만드는 주범**이 된다. 또한 테스트가 늘어날수록 수행시간이 길어진다는 점도 문제이다.
- 거대한 테스트를 잘 관리하는 비결은 테스트를 존중하는 문화이다. 느리거나 중요하지 않은 테스트들은 리팩토링 해야한다.

### 11.4 구글의 테스트 역사

- 구글 엔지니어들도 처음엔 자동 테스트의 가치를 받아들이지 못했다. 자동 테스트를 전사적으로 뿌리내리게 한 원동력은 세 가지 였다. `오리엔테이션 수업, 테스트 인증 프로그램, 화장실에서도 테스트`가 주인공이다.
- 오리엔테이션 수업
  - 신규 입사자 온보딩 과정에 한 시간짜리 자동 테스트의 가치를 이야기하는 수업을 추가했다.
  - 좋은 테스트를 작성하는 방법을 마치 구글 표준 관행인 것처럼 교육하자 신규 엔지니어들은 팀에 배정되어 배운대로 테스트를 작성하기 시작했다.
- 테스트 인증
  - 각 팀의 테스트 수준을 알게하고 더 성숙한 테스트를 작성하도록 테스트 인증 프로그램을 도입했다.
  - 가령 레벨 1은 지속적 빌드, 코드 커버리지 추적, 실행할 수 있는 테스트 마련이라면 레벨 5는 모든 테스트 자동화, 모든 커밋전에 빠른 테스트가 수행되도록 하고, 모든 행위를 테스트해야 했다.
  - 사내 대시보드의 모든 팀의 현재 레벨을 보여주면서 분위기를 부추기자 경쟁하기 시작했다.
- 화장실에서도 테스트
  - 테스트 문화 개선을 위해 화장실 앞에 테스트 개선법을 알려주는 짧은 글을 화장실 칸마다 붙게 되었다.
  - 처음에는 불만도 있었지만 결과적으로 가장 오래 시행되고 영향력도 컸다.

## 12. 단위 테스트

- 테스트의 **가장 중요한 목적은 버그 예방**이다. 그 다음으로 중요한 것은 **생산성 개선**이다. 단위 테스트는 생산성을 끌어올리는 훌륭한 수단이 될 수 있는 특성을 많이 가지고 있다.
- 구글의 테스트 크기 정의에 따라 단위 테스트는 대체로 작은 테스트에 속한다. 빠르게 작성할 수 있으므로 테스트 커버리지를 높이기 좋고, **커버리지가 높다면 엔지니어들은 안정감을 가지고 코드를 변경**할 수 있다.
- 단위 테스트는 비중이 크기 때문에 구글은 **테스트 유지보수성을 상당히 중시**한다. 즉 한 번 작성해두면 실패하지 않는 한 엔지니어가 신경쓸 필요가 없고 혹 **실패한다면 원인을 바로 알 수 있는 진짜 버그를 찾았다는 뜻**이다. 이번 장은 유지보수성이 무엇인지와 높은 유지보수성을 달성하는 기법들에 많은 분량을 할애할 것이다.

### 12.1 유지보수하기 쉬워야 한다.

- 시나리오

```
A는 간단한 기능을 순식간에 구현했는데 자동 테스트가 잔뜩 실패했다. 헌데 테스트가 진짜로 버그를 찾은 것은 아니었다.
그럼에도 실패한 이유는 테스트들의 내부 구조가 특정한 형태일 것이라고 가정했기 때문이다. 결국 테스트를 수정해야 했는데
그 중 많은 수는 무엇을 검증하려는지 눈에 들어오지 않았다. 결국 금방 끝나야 하는 작업이 오래 걸렸고 A의 생산성과 사기가 크게 떨어졌다.
```

- 위에서 문제는 두 가지로 추릴 수 있다.
  - 버그도 없고 자신의 검증 대상과 관련없는 변경 때문에 실패하는 깨지기 쉬운 테스트들이 도사리고 있었다.
  - 무엇이 잘못되어 실패했는지 어떻게 고쳐야 하는지 파악하기 어려운 불명확한 테스트들이 많다.

### 12.2 깨지기 쉬운 테스트 예방하기

- 꺠지기 쉬운 테스트란 실제로는 버그가 없거나, 검증 대상 코드와 관련없는 변경 때문에 실패하는 테스트를 의미한다.

#### 12.2.1 변하지 않는 테스트로 만들기 위해 노력하자

- 먼저 이 질문에 답해야 한다. 테스트를 처음 작성한 후 얼마나 자주 변경할 거라 예상하는가? 기존 테스트를 갱신하느라
허비한 시간은 모두 더 가치있는 작업에 쏟을 수 있던 시간이다. 따라서 이상적인 테스트는 변하지 않아야 한다. 즉 요구사항이 바뀌지 않는 한 절대로 수정할 일이 없어야 한다.
- 순수 리팩토링
  - 외부 인터페이스는 놔두고 내부만 리팩터링 한다면 테스트는 변경되지 않아야 한다.
  - 성능 최적화, 코드 가독성 개선 등이 여기 속한다. 테스트의 역할은 리팩터링 후에도 시스템의 행위가 달라지지 않았음을 보장하는 것이다.
  - 리팩터링 과정에서 테스트를 변경해야 한다면 기능이 달라졌다는 뜻이다. 혹은 테스트가 세부 구현에 지나치게 의존하고 있다는 이야기이다.
- 새로운 기능 추가
  - 새로운 기능을 추가했는데 기존 테스트가 깨진다면 테스트에 문제가 있다는 뜻이다.
- 버그 수정
  - 버그가 존재한 다는 것은 테스트 케이스에 빠진 경우가 있다는 것이다. 따라서 버그 수정과 동시에 누락된 테스트를 추가해야 한다.

#### 12.2.2 공개 API(public 메소드)를 이용해 테스트하자

- 시스템 내부의 private API를 테스트할 경우 메서드의 이름을 바꾸거나 리팩터링 할 때마다 테스트가 실패하게 된다.
- 구글의 경험에서 공개 API를 호출하는 테스트가 내부 구현을 직접 테스트하는 것보다 좋다는 사실을 이해하지 못하는 엔지니어도 있어서 설득해야 했다. 그럼에도 이 방법을 장려하지 않으면 나중에 유지보수를 많이 해야해서 투자할 가치는 충분하다. 시스템에 변경이 있을 때만 테스트가 실패하도록 만드는 방법 중 가장 효과적인 수단이다.

#### 12.2.3 상호작용이 아니라 상태를 테스트하자

- 시스템이 기대한 대로 동작하는지 검증하는 방법은 상태테스트와 상호작용 테스트가 있다.
- 상태 테스트는 메서드 호출후 상태를 검증하는 반면, 상호작용 테스트는 호출 후에 다른 모듈들과 협력하여 기대한
일련의 동작을 수행하는지를 확인한다.
- 대체로 상호작용 테스트는 깨지기 쉽다. 이유는 공개 메서드 테스트보다 비공개 메서드 테스트가 깨지기 쉬운 이유와 같다. 우리가 원하는 것은 무엇이지만 상호작용 테스트는 결과에 도달하기 까지 어떻게 작동하냐를 확인하려 든다.

### 12.3 명확한 테스트 작성하기

- 테스트 실패는 엔지니어에게 언제나 유용한 신호를 준다. 테스트가 실패하는 이유는 아래와 같다.
  - 기능이 변경되었다.
  - 기능에 문제가 있다. 즉, 구현한 기능이 정상적으로 동작하지 않는다.
  - 테스트 자체에 결함이 있다. 기능에 문제가 없다면 꺠지기 쉬운 테스트를 작성했다는 뜻이다.
- 테스트가 실패하면 문제를 파악해야 하는데, 얼마나 빠르게 마치느냐는 테스트의 명확성에 달렸다.
- 명확한 테스트는 시스템의 문서자료 역할을 해주고 새로운 테스트를 작성하기 쉽게 도와주는 토대가 된다.

#### 12.3.1 완전하고 간결하게 만들자

- 완전한 테스트란 결과에 도달하기까지의 논리를 읽는이가 이해하는데 필요한 모든 정보를 본문에 담고 있는 테스트를 말한다. 간결한 테스트란 관련없는 정보는 포함하지 않는 테스트이다.
- 테스트를 명확하게 만들 수 있다면 DRY 원칙을 거스르는게 나을 때도 많으며 테스트 본문에는 테스트를 이해하는데
필요한 정보를 모두 담아야 하며, 관련없는 정보는 담지 말아야 한다.

#### 12.3.2 메서드가 아니라 행위를 테스트하자

- 많은 엔지니어가 메서드 하나에 테스트도 하나를 두는 방법을 생각한다. 아래 코드를 보자

```java
  public void displayTransactionResults(User user) {
    ui.displayMessage("물품을 구입하셨습니다.");
    if (user.getBalance() < LOW_BALANCE_THRESHOLD) {
      ui.displayMessage("잔고가 부족합니다.")
    }
  }
```

- 하나의 테스트 코드로 해당 기능을 검증한다면 아래와 같은 형태가 된다.

```java
@Test
public void testDisplayTransactionResults() {
  // given ~ when
  assertThat().contains("물품을 구입하셨습니다.");
  assertThat().contains("잔고가 부족합니다.");
}
```

- 이 확장은 나쁜 선례가 된다. 메서드가 더 복잡해지고 많은 기능을 구현한다면 테스트 역시 계속 복잡해지게 된다.
- 따라서 테스트를 메서드 별로 작성하지 말고, 행위별로 작성해야 한다.

```java
@Test
public void testDisplayTransactionResults() {
  // given ~ when
  assertThat().contains("물품을 구입하셨습니다.");
}

@Test
public void testDisplayTransactionResults() {
  // given ~ when
  assertThat().contains("잔고가 부족합니다.");
}
```

- 테스트를 쪼개느라 코드가 늘어났지만 각 테스트가 명확하게 되었으니 그 이상의 값어치가 있다.
- **테스트의 구조는 행위가 부각되도록 작성하자**
  - 행위와 연결해 테스트를 하면 구조 역시 달라진다. 모든 행위는 given, when, then 세 요소로 구성이 된다.
  - given은 시스템의 설정을 정의하고 when은 시스템이 수행할 작업, then은 결과를 검증한다.

  ```java
  @Test
  public void testName() {
    // Given: 두 개의 계좌, 각각의 잔고는 150, 20
    Account account1 = newAccountWithBalance(use(150));
    Account account2 = newAccountWithBalance(use(20));

    // When: 첫 번째 계좌에서 두 번째 계좌로 $100 이체
    bank.transferFunds(account1, account2, usd(100));

    // Then: 각 계좌 잔고에 이체 결과가 반영됨
    assertThat(account1.getBalance()).isEqualTo(usd(50));
    assertThat(account2.getBalance()).isEqualTo(usd(120));
  }
  ```

  - 간단한 테스트라면 위 처럼 상세하게 설명할 필요는 없다. 대부분의 경우 주석 대신 각 요소 사이를 빈 줄로 구분해주는 것으로 충분하다. 만약 테스트가 복잡하다면 주석을 달아주는게 이해하기 좋다.
- 테스트 이름은 검사하는 행위에 어울리게 짓자
  - 테스트의 이름은 매우 중요하다. 테스트의 이름은 검사하려는 행위를 요약해 보여줘야 한다. 시스템이 수행하는 동작과 예상결과를 모두 담아야 좋은 이름이다. 때로는 시스템의 상태나 사전 조건같은 추가 정보를 담기도 한다.

#### 12.3.3 테스트에 논리를 넣지 말자

```java
@Test
public void testName() {
  String baseUrl = 'http://photos.google.com/';
  Navigator nav = new Navigator(baseUrl);
  nav.goToAlbumPage();
  assertThat(nav.getUrl()).isEqualTo(baseUrl + '/album')
}
```

- 위 코드에 논리는 마지막 줄에서 문자열을 연골하고 있는 코드이다. 이 작은 논리를 없애면 버그가 나타난다.

```java
@Test
public void testName() {
  String baseUrl = 'http://photos.google.com/';
  Navigator nav = new Navigator(baseUrl);
  nav.goToAlbumPage();
  assertThat(nav.getUrl()).isEqualTo('http://photos.google.com//album')
}
```

- 전체 문자열을 적자 URL에 슬래시를 두 번 썼음이 바로 드러난다. 테스트 코드에서는 스마트한 로직보다
직설적인 코드를 고집해야 한다.

### 12.4 테스트와 코드 공유: DRY가 아니라 DAMP

- 대부분의 SW는 반복하지 말라는 DRY 원칙을 숭배한다. DRY는 코드 중복을 최소로 줄이면 유지보수 하기 쉽다고 이야기 한다. 보통 제품의 코드에는 장점으로 작용하지만 테스트 코드에서는 사정이 조금 다르다.
- 좋은 테스트는 안정적이고 시스템 행위가 변경되면 실패하도록 설계된다. 테스트는 복잡해질수록 손해가 막심하여 DRY 보다는 DAMP가 되도록 노력해야 한다.
- DAMP는 서술적이고 의미있는 문구를 뜻한다. 단순 명료하게 만들어준다면 테스트에서 다소의 중복은 허용된다.
- 아래 예시를 보자
  ```java
  // DRY에 집착한 테스트
  @Test
  public void testName() {
    List<User> users = createUsers(false, false);
    Forum forum = createForumAndRegisterUsers(users);
    validateForumAndUsers(forum, users);
  }

  // DAMP를 따른 테스트
  @Test
  public void testName() {
    User user1 = newUser().build();
    User user2 = newUser().build();

    Forum forum = new Forum();
    forum.register(user1);
    forum.register(user2);

    assertThat(forum.hasRegisteredUser(user1)).isTrue();
    assertThat(forum.hasRegisteredUser(user2)).isTrue();
  }
  ```

- 중복된 코드도 있고 본문은 길어졌지만 테스트 각각이 의미있어졌고 테스트 본문만 봐도 전체를 이해할 수 있게 되었다.
- DAMP는 DRY를 대체하는게 아니라 보완하는 개념이다. 핵심은 테스트에서 리팩터링은 반복을 줄이는게 아니라 더 서술적이고 의미있게 하는 방향으로 이루어져야 한다는 점이다.

#### 12.4.1 공유 값

- 공유 값으로 테스트에서 다양하게 활용하면 간결하게 만들 수 있지만 그보다 좋은 방법은 도우미 메서드를 활용하는 것이다.

```java
// 도우미 메서드 (매개변수에 기본값을 정의하여 생성자를 래핑함)
private static Contact.Builder newContact() {
  return Contact.newBuilder()
    .setFirstName('서')
    .setLastName('서')
    .setPhoneNumber('01048921123');
}

// 호출부에는 필요한 매개변수만 덮어쓰고 나머지는 기본값으로 리턴된 값을 얻는다.
@Test
public void testName() {
  Contact contact = newContact().setFirstName('하').build();
}
```

#### 12.4.2 공유 셋업

- 셋업 메서드(Before, BeforeEach..)를 이용한 특정 값에 의존하는 테스트가 생겨나기 시작하면 악몽이 시작될 수 있다. 아래 테스트는 도널드 커누스라는 문자열이 어디서 왔는지 찾아내야 하므로 완벽하지 않다.

```java
private UserStore userStore;

@Before
public void setUp() {
  nameService = new NameService();
  nameService.set('user1', '도널드 커누스');
  userStore = new UserStore(nameService);
}

@Test
public void shouldReturnName() {
  UserDetail user = userStore.get('user1');
  assertThat(user.getName()).isEqualTo('도널드 커누스');
}
```

- 위처럼 특정 값을 요구하는 테스트라면 그 값을 직접 기술해줘야 한다.

### 12.6 핵심 정리

- 변하지 않는 테스트를 만들기 위해 노력하라
- 공개 API를 통해 테스트해라
- 상호작용이 아닌, 상태를 테스트해라
- 테스트 이름은 검사하는 행위가 잘 드러나게 지어라.

## 13. 테스트 대역

- 테스트 대역은 실제 구현 대신 사용할 수 있는 객체나 함수를 말한다.

### 13.1 테스트 대역이 SW 개발에 미치는 영향

- 테스트 용이성
  - 테스트 대역을 사용하려면 코드베이스가 테스트하기 쉽도록 설계되어 있어야 한다.
  - 만약 DB를 호출하는 코드라면 실제 DB 대신 테스트 대역을 사용해도 괜찮을 만큼 유연해야 한다.
- 적용 가능성
  - 테스트 대역을 잘 활용하면 엔지니어링 속도가 크게 개선되겠지만 잘못 사용하면 깨지기 쉽고 효율도 나쁜 테스트로 전락한다.
  - 실제로 테스트 대역을 활용하기엔 적절하지 않은 경우가 많아 되도록 실제 구현을 이용하길 권한다.
- 충실성
  - 충실성은 테스트 대역이 실제 구현의 행위와 얼마나 유사하냐를 말한다.
  - 테스트 대역이 실제 구현과 전혀 다르게 동작한다면 테스트들은 별다른 가치를 만들어내지 못한다.

### 13.2 테스트 대역 @ 구굴

- 구글이 깨우친 교훈 하나는 테스트 대역을 쉽게 만드는 모의 객체를 과용하면 위험하다는 것이다.
  - 처음 모의 객체 프레임워크를 도입했을 때는 의존하는 모듈에 신경쓰지 않고 원하는 코드 조각에 집중하는 테스트를 쉽게 만들 수 있었다. 이렇게 테스트를 만들며 몇 년이 지나자 커다란 대가를 치르게 되었다.
  - 테스트를 작성하긴 쉬웠지만 버그를 잘 찾아내지 못했고 끊임없이 보수해야 했다. 오늘날의 많은 엔지니어가 모의객체 프레임워크를 피하고 실제에 더 가까운 테스트를 작성한다.

### 13.3 기본 개념

- 모의객체 프레임워크
  - 테스트 대역을 쉽게 만들어주는 라이브러리. 모의 객체 프레임워크를 사용하면 테스트 대역이 필요할 때마다 새로운 클래스를 정의하지 않아도 되므로 자질구레한 보일러 플레이트 코드를 줄일 수 있다.

### 13.4 테스트 대역 활용 기법

- 대표적인 테스트 대역 활용 기법은 3가지이다. 각 기법의 차이를 알고 있어야 테스트 대역이 필요할 때 가장 적합한 하나를 선택해 활용할 수 있다.

#### 13.4.1 속이기

- 가짜 객체(fake object)는 제품 코드로는 적합하지 않지만 실제 구현과 비슷하게 동작하도록 가볍게 구현한 대역이다. 인메모리 데이터베이스가 좋은 예이다.

#### 1.3.2 뭉개기 (스텁)

- 스텁은 원래 없던 행위를 부여하는 과정을 말한다. 예를 들어 함수가 반환할 값을 지정한다고 하면 반환 값을 스텁한다고 표현한다.
- 아래는 스텁 과정을 보여주는 예로 loopUpUser 메서드가 어떻게 동작해야 하는지를 정해주고 있다.

```java
// 모의 객체 프레임워크로 생성한 테스트 대역을 전달
AccessManager accessManager = new AccessManager(mockAuthorizationService);

// USER_ID에 해당하는 사용자를 찾지 못하면 접근을 불허
when(mockAuthorizationService.lookUpuser(USER_ID)).thenReturn(null);

assertThat(accessManager.userHasAccess(USER_ID)).isFalse();
```

#### 13.4.3 상호작용 테스트

- 상호작용 테스트는 함수를 실제로 호출하지 않고도 그 함수가 어떻게 호출되었는지 검증하는 기법이다.
- 스텁과 비슷하게 모의 객체 프레임워크를 활용하며, 상호작용 테스트가 유용한 상황도 있지만 과용하면 테스트들이 깨지기 쉽게 변할 수 있으니 되도록 사용하지 않는게 좋다.

### 13.5 실제 구현

- 테스트 대역은 값진 테스트 도구지만 구글은 가능하다면 대상 시스템이 의존하는 실제 구현을 사용한다.
- 실제 구현을 선호하는 테스트 방식을 고저전적 테스트, 반대로 모의객체 프레임워크를 선호하는 테스트 방식을 모의 객체 중심주의 테스트라고 표현한다.

#### 13.5.1 격리보다 현실성을 우선하자

- 의존하는 실제 구현을 이용하면 테스트 대상이 실제와 가까워진다.
- 실제 구현을 이용한 테스트는 실제 구현에 버그가 있다면 실패할 것이다. 좋은 일이다. 코드가 실제 환경에서 실패한다는 신호이니 누구라도 이런 상황에선 실패하길 바랄 것이다.

#### 13.5.2 실제 구현을 사용할지 결정하기

- 실행시간
  - 속도는 단위 테스트에서 중요한 특징 중 하나이다. 단위 테스트는 빈번하게 실행되면서 코드에 문제가 생기면 빠르게 알려주는게 목적이다. 그래서 실제 구현의 수행시간이 오래 걸릴 때는 테스트 대역이 유용할 수 있다.
  - 실제 구현을 사용하다가 너무 느려졌다고 판단되면 테스트 대역을 투입하면 된다. 테스트 병렬화도 시간을 줄이는데 효과적이다. 구글은 테스트들을 여러 서버에서 병렬로 실행하기 쉽게 해주는 인프라를 갖추고 있다.
- 결정성
  - 같은 버전의 시스템을 실행하면 언제나 똑같은 결과를 내어주는 테스트를 결정적 테스트라고 부른다.
  - 실제 구현을 사용해도 결과가 동일하다면 그대로 유지하면 된다. 반대로 실제 구현에서 에러가 발생할 수 있다면 (예를 들면 외부 API 호출시) 테스트 대역이 테스트 충실성을 높여줄 수 있다.
  - 밀폐되지 않은, 테스트가 통제할 수 없는 외부 서비스에 의존하는 코드는 비결정성의 주범으로 뽑힌다.
- 의존성 생성
  - 실제 구현을 이용하려면 의존 대상들도 모두 생성해야 한다. 예로 객체를 하나 생성하려면 의존성에 필요한 모든 객체가 필요하다. 처음 객체가 의존하는 모든 객체가 필요하고, 그 객체들 각각이 의존하는 모든 객체가 필요한 방법이다.
  - 테스트 대역은 간결하게 생성할 수 있지만, 보통은 실제 구현을 이용할 떄의 장점이 훨씬 크다.

### 13.6 속이기 (가짜 객체)

- 실제 구현을 이용할 수 없을 때는 가짜 객체가 최선일 경우가 많다. 가짜 객체는 실제 구현과 비슷하게 동작하기 때문에 다른 테스트 대역보다 우선적으로 활용된다.

```java
// FileSystem 인터페이스를 구현하는 가짜 객체이다. 실제 구현도 같은 인터페이스를 이용한다.
public class FakeFileSystem implements FileSystem {
  private Map<String, String> files = new HanhMap<>();
  @Override
  public void writeFile(String fileName, String contents) {
    files.add(fileName, contents)
  }
  @Override
  public String readFile(String fileName) {
    String contents = files.get(fileName);
    // 실제 구현이 파일을 찾을 수 없을 때 예외를 던지기 때문이 가짜 객체도 같은 에외를 던진다.
    if (contents == null) {
      throw new FileNotFoundException(fileName);
    }
    return contents;
  }
}
```

#### 13.6.1 가짜 객체가 중요한 이유

- 가짜 객체는 테스트를 도와주는 강력한 도구이다. 빠르고 실제 객체를 사용할 떄의 단점을 제거한 채 테스트를 효과적으로 수행할 수 있다.

#### 13.6.2 가짜 객체를 작성해야 할 때

- 가짜 객체는 실제 구현과 비슷하게 동작하기 때문에 만들려면 노력도 더 들고 도메인 지식도 필요하다.
- 유지보수 할 가짜 객체 수를 줄이려면 테스트에서 진짜 객체를 사용하지 못하는 원인을 찾는다.
  - 예를 들어 테스트에서 DB를 사용할 수 없다면 DB API를 호출하는 클래스 각각이 아니라, DB API 자체만 가짜 객체로 만드는 방식이다.

#### 13.6.3 가짜 객체의 충실성

- 가짜 객체를 활용하는 이유는 충실성에 있다. 충실성이란 가짜 객체라 실제 구현의 행위를 얼마나 비슷하게 흉내를 내느냐를 말한다.
- 실제 구현과 다르게 동작한다면 가짜 객체는 필요없어진다. 100% 충실하게 만들기는 어렵다. 실제 구현으로 테스트하기에는 무리가 있었기 때문에 가짜 객체를 활용했을 것이다.

#### 13.6.5 가짜 객체를 이용할 수 없다면

- 최적화 관점에서 가짜 객체를 이용할 때도 있다. 실제 구현을 사용하는 테스트들 때문에 전체적으로 너무 느려졌다면 가짜 객체를 투입하여 더 빠르게 만드는 것이다. 하지만 속도 향상으로 얻는 혜택이 가짜 객체를 관리하는 비용보다 크지 않다면 실제 구현을 계속 사용하는게 더 낫다.

### 13.7 뭉개기 (스텁)

- 스텁은 원래는 없는 행위를 테스트가 함수에 덧씌우는 방법이다.

#### 13.7.1 스텁 과용의 위험성

- 스텁을 과용하면 테스트를 유지보수 할 일이 늘어나서 오히려 생산성을 갉아먹는다.
- 불명확해진다.
  - 스텁을 이용하면 함수에 행위를 덧씌우는 코드를 추가로 작성해야 한다. 이 추가코드는 읽는 이의 눈을 어지럽혀서
  테스트의 의도를 파악하기 어렵게 한다.
- 깨지기 쉬워진다.
  - 스텁을 사용하면 대상 시스템의 내부 구현 방식이 테스트에 드러난다. 제품의 내부가 다르게 구현되면 테스트 코드도 함께 수정해야 한다. 좋은 테스트라면 공개 API가 아닌 한 내부가 어떻게 달라지든 영향받지 않아야 한다.
- 테스트 효과가 감소한다
  - 스텁으로 행위를 뭉개버리면 함수가 실제 구현과 똑같이 동작하는지 보장할 방법이 사라진다.
- 스텁을 과용한 예
  ```java
    @Test
    public void creditCardIsCharged() {
      // 모의객체 프레임워크로 생성한 테스트 대역을 건넨다.
      paymentProcessor = new PaymentProcessor(
        mockCreditCardServer, mockTransactionProcessor
      );

      // 테스트 대역들이 함수를 스텁하여 뭉갠다.
      when(mockCreditCardServer.isServerAvailable()).thenReturn(true);
      when(mockTransactionProcessor.beginTransaction()).thenReturn(transaction);
      when(mockCreditCardServer.initTransaction(transaction)).thenReturn(true);
      when(mockCreditCardServer.pay(transaction, creditCard, 500)).thenReturn(false);
      when(mockTransactionProcessor.endTransaction()).thenReturn(true);

      // when
      paymentProcessor.processPayment(creditCard, Money.dollor(500));

      // pay 메서드가 거래내역을 실제로 전달했는지 확인할 방법이 없다.
      // 검증할 수 있는 것은 그저 pay() 메서드가 호출되었다는 사실 뿐이다.
      verify(mockCreditCardServer).pay(transaction, creditCard, 500);
    }

    // 스텁을 사용하지 않도록 리팩토링
    @Test
    public void creditCardIsCharged() {
      paymentProcessor = new PaymentProcessor(creditCardServer, transactionProcessor);
      paymentProcessor.processPayment(creditCard, Money.dollor(500));
      assertThat(creditCardServer.getMostRecentCharge(creditCard)).isEqualTo(500);
    }
  ```

- 위에서 테스트가 외부 신용카드 서버와 실제로 통신하는 건 원하지 않을테니 신용카드 서버는 가짜 객체로 대체하는 것이 좋다.

#### 13.7.2 스텁이 적합한 경우

- 스텁은 실제 구현을 포괄적으로 대체하기 보다 특정 함수가 특정 값을 반환하도록 하여 대상 시스템을 원하는 상태로 변경하려 할 때 제격이다. 실제 구현이나 가짜 객체로는 원하는 반환값을 얻거나 특정 오류를 일으키기가 불가능 할 수 있지만 스텁은 함수의 동작을 테스트 코드에서 정의할 수 있으므로 쉽게 원하는 결과를 얻을 수 있다.

### 13.8 상호작용 테스트 하기

- 상호작용 테스트는 함수가 어떻게 호출되는지를 검증하는 기법이다. 모의 객체 프레임워크를 이용하면 상호작용 테스트를 어렵지 않게 수행할 수 있지만, 테스트를 가치있고 잘 읽히고 변경하기 쉽게 관리하려면 꼭 필요할 때만 적용해야 한다.

#### 13.8.1 상호작용 테스트보다 상태 테스트를 우선하자.

- 상태 테스트란 시스템을 호출하여 올바른 값을 반환하는지 혹은 상태가 올바르게 변경되었는지 검증하는 테스트이다.
- 상태 테스트 예

  ```java
    @Test
    public void sortNumbers() {
      NumberSorter numberSorter = new NumberSorter(quickSort, bubbleSort);
      List sortedList = numberSorter.sortNumbers(newList(3, 1, 2));
      // 결과가 올바르다면 어떤 정렬 알고리즘을 이용했든 상관없다.
      assertThat(sortedList).isEuqalTo(newList(1,2,3));
    }
  ```

- 이번엔 상호작용 테스트를 보자. 여기서는 반환값이 실제로 정렬되었는지 확인할 방법이 없다. 그래서 검증하는 기능은 대상 시스템이 정렬을 시도했다 라는 사실 뿐이다.

  ```java
    @Test
    public void sortNumbers() {
      NumberSorter numberSorter = new NumberSorter(mockQuickSort, mockBubbleSort);
      numberSorter.sortNumbers(newList(3, 1, 2));
      // mockQuickSort가 호출되지 않거나 잘못된 인수를 건네면 실패한다.
      verify(mockQuickSort).sort(newList(3, 1, 2));
    }
  ```

- 구글은 상테 테스트에 집중해야 제품과 테스틑 확장할 때 훨씬 유리하다는 사실을 깨달았다. 깨지기 쉬운 테스트가 줄어들고 나중에 테스트를 변경하거나 유지보수하기 쉬워진다.
- 상호작용 테스트의 가장 큰 문제는 특정 함수가 호출되었는지만 알려줄 뿐 올바르게 작동하는지 말해주지 못한다는 점이다. 그래서 해당 코드가 올바르게 동작한다고 `가정하고 넘어가야` 한다.
- 상호작용 테스트의 두 번째 문제는 상세 구현 방식을 활용한다는 점이다. 테스트가 대상 시스템이 그 함수를 호출할 것을 알야 하고, 제품 구현 방식이 바뀌면 테스트가 깨질 수 있다.

#### 13.8.2 상호작용 테스트가 적합한 경우

- 실제 구현이나 가짜 객체를 이용할 수 없어서 상태 테스트가 불가능한 경우.
- 함수 호출 순서나 횟수가 달라지면 기대와 다르게 동작하는 경우, 상태 검증 테스트로는 검증하기 어려운 상황이므로 상호작용 테스트가 제 역할을 할 수 있다.
- 상호작용 테스트는 상태 테스트를 완전히 대체하지 못한다. 따라서 단위 테스트에서 상태 테스트를 수행할 수 없다면 상호작용 테스트를 추가하는 대신, 더 큰 범위에서 상태 테스트를 수행(e2e는 상태 테스트, service는 상호작용 테스트)하는 것이 좋다.

### 13.10 핵심 정리

- 테스트 대역보다는 되도록 실제 구현을 사용해야 한다.
- 테스트 대역에서 실제 구현을 사용할 수 없다면 가짜 객체가 최선일 때가 많다.
- 스텁을 과용하면 테스트가 불명확해지고 꺠지기 쉬워진다.
- 상호작용 테스트는 테스트를 깨지기 쉽게 만들기 때문에 피하는게 좋다.

## 14. 더 큰 테스트

### 14.1 더 큰 테스트란?

- 종단간 테스트 혹은 시스템 테스트라고 하는 범위가 가장 큰 테스트는 대체로 의존하는 외부 모듈을 직접 이용하며 테스트 대역은 거의 쓰지 않는다.
- 큰 테스트는 느릴 수 있고, 비결정적일 수 있다. 이런 단점에도 더 큰 테스트를 이용하는 이유는 실제 기능에 대한 테스트이기 때문이다.
- 단위 테스트는 개별 함수, 객체, 모듈에 대한 확신을 심어주지만 더 큰 테스트들은 시스템 전체가 의도대로 동작한다는 확신을 더해주는 역할을 한다.

### 14.2 더 큰 테스트 @구글

- 구글은 테스트 피라미드를 장려해서 대다수 테스트가 단위 테스트가 되길 원하여 단위 테스트에 집중했다.
- 나머지 더 큰 테스트들은 모두 수명이 더 긴 SW에 유용하다.

### 14.3 큰 테스트의 구조

- 큰 테스트들은 작은 테스트의 제약 조건에 구속받지 않아서 어떤 형태로든 만들 수 있지만 공통된 패턴을 따른다. 다음은 큰 테스트를 진행하는 일반적 흐름이다.
  - 테스트 대상 시스템 확보
  - 필요한 테스트 데이터 준비
  - 동작 수행
  - 행위 검증
- 테스트 대상 시스템(System Under Test, SUT)은 다양한 형태가 존재하며 SUT 범위가 대규모 테스트 자체의 범위를 규정하는 주된 요소이다.
- 밀폐된 SUT 이점
  - 큰 테스트에서 SUT는 테스트 신뢰성을 떨어뜨리고 피드백 시간을 늘리는 주범이 될 수 있다.

### 14.7 핵심 정리

- 더 큰 테스트는 단위 테스트가 다루지 못하는 문제를 책임진다.
- 더 큰 테스트는 테스트 대상 시스템, 데이터, 동작, 검증으로 구성된다.

## 15. 폐기

- 낡은 시스템을 유지보수 하기 보다는 완전히 떼어내는 편이 나을 때가 많은데, 이주를 순차적으로 진행하여 궁극적으로 낡은 시스템을 완전히 걷어내는 과정을 폐기라고 부른다.

### 15.1 폐기시키는 이유

- 코드는 자산이 아니라 부채다라는 기본 전제에서 시작한다. 코드에는 비용이 따라오고 대부분의 비용은 구축 후 생이 끝날때까지 유지보수 하는데서 발생한다.
- 시스템이 오래됐다고 무조건 폐기시켜야 하는 건 아니다. 몇 해에 걸쳐 정교하게 다듬으면 좋은 SW가 될 수도 있다.

### 15.2 폐기는 왜 그리 어려운가?

- 예전 시스템의 쓰임새 하나를 다 살펴봐야 하고, 예전 시스템을 향한 애착이 의외의 저항으로 나타날 수 있다. 또한 비용을 확보해 폐기를 진행하려면 정치라는 관문도 통과해야 한다.
- 완전히 새로운 시스템으로 이주하는 비용은 정말 크고 예상보다 훨씬 많이 들 때가 많음을 구글은 여러 차례 경험해서
시스템 이용자들이 각자의 업무 현장에서 점진적으로 개선시키는 편이 쉬울때가 많다.

### 15.3 폐기 유형

- 폐기의 유형은 크게 권고와 강제로 구분한다.
  - 권고폐기는 기한이 없고, 담당 팀은 고객들이 새로운 시스템으로 이주하길 바라지만 옛 시스템을 바로 걷어낼 계획은 없다.
  - 강제폐기는 시스템의 지원 종료일을 못 박는 형태로 이루어진다. 종료일 이후까지 이주를 끝내지 못한 시스템은 제대로 작동되지 못할 것이다.

### 15.6 핵심 정리

- 소프트웨어 시스템이 존재하는 한 유지보수 비용은 계속 발생하므로 제거하는 비용과 저울질 해봐야 한다.
- 폐기 비용은 일반적으로 새로운 시스템으로 교체하기 보다 기존 시스템을 개선하는 편이 저렴하다.

## 16. 버전 관리와 브랜치 관리

### 16.1.3 진실 공급원

- 중앙집중형 VCS는 시스템 설계에서 진실공급원 이라는 개념을 사용한다. 가장 최근 커밋된 것이 현재 버전이다.
- 반대로 분산형 VCS에는 여러 리포리터지 중 어느 것이 단일 진실 공급원(SSOT)이냐는 개념이 애초에 존재하지 않는다.

### 16.3.4 장수 브랜치는 왠만하면 금지

- 브랜치는 매우 짧게 쓰고 없애야 한다.

## 18. 빌드 시스템과 빌드 철학

### 18.1 빌드 시스템의 목적

- 모든 빌드 시스템의 목적은 단순하다. 작성한 소스 코드를 기계가 읽을 수 있는 바이너리로 변환하는 것이다.
- 훌륭한 빌드 시스템은 다음의 두 가지 중요 속성을 최적화한다.
  - 속도: 개발자가 명령 하나로 빌드를 수행하고 몇 초안에 결과 바이너리를 얻을 수 있어야 한다.
  - 정확성: 소스 파일과 환경이 같다면 어떤 컴퓨터에서 빌드하더라도 동일한 결과를 내야 한다.

### 18.3 모던 빌드 시스템

- 범용 빌드 시스템은 오랜 시간 개발되어 와서 직접 작성한 스크립트보다 훨씬 견고하고 유연하다.

#### 18.3.1 핵심은 의존성

- 본인이 작성한 코드를 관리하는건 간단하지만 외부 의존성 관리는 훨씬 어렵다. 작업 사이의 의존성, 코드에서의 내부 의존성 등 빌드 시스템 구축에는 이러한 의존성을 관리하는게 기본이 되는 작업이다.

#### 18.3.2 태스크 기반 빌드 시스템

- 태스크는 어떠한 로직을 수행할 수 있는 스크립트이며 다른 태스크와의 의존 관계를 명시하여 먼저 수행되도록 할 수 있다.
- 대표적으로 Ant, Maven, Gradle 같은 시스템이 대표적인 태스크 기반 빌디 시스템이다.
- 대부분의 모던 빌드 시스템은 쉘 스크립트 대신 빌드 파일을 이용한다. 빌드 파일은 빌드 수행 방법을 기술한 파일이다.
표현 방식만 다를 뿐 빌드 파일은 빌드 스크립트와 본질적으로 크게 다르진 않다.

